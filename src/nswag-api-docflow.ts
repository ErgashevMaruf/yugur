//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IDocClient {
    getDocsList(table: TableMetaData, idAndControl: string | null): Observable<QueryResultOfDocListDTO>;
    addDoc(item: DocDTO): Observable<DocDTO>;
    getTbDocsByQuery(query: string | null): Observable<SelectItem[]>;
}

@Injectable({
    providedIn: 'root'
})
export class DocClient implements IDocClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getDocsList(table: TableMetaData, idAndControl: string | null): Observable<QueryResultOfDocListDTO> {
        let url_ = this.baseUrl + "/api/docflow/Doc/getDocsList/{idAndControl}";
        if (idAndControl === undefined || idAndControl === null)
            throw new Error("The parameter 'idAndControl' must be defined.");
        url_ = url_.replace("{idAndControl}", encodeURIComponent("" + idAndControl));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(table);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfDocListDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfDocListDTO>;
        }));
    }

    protected processGetDocsList(response: HttpResponseBase): Observable<QueryResultOfDocListDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfDocListDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addDoc(item: DocDTO): Observable<DocDTO> {
        let url_ = this.baseUrl + "/api/docflow/Doc/addDoc";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DocDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DocDTO>;
        }));
    }

    protected processAddDoc(response: HttpResponseBase): Observable<DocDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DocDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTbDocsByQuery(query: string | null): Observable<SelectItem[]> {
        let url_ = this.baseUrl + "/api/docflow/Doc/getTbDocsByQuery/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTbDocsByQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTbDocsByQuery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectItem[]>;
        }));
    }

    protected processGetTbDocsByQuery(response: HttpResponseBase): Observable<SelectItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrgStrucClient {
    getDiagOrgStruc(id: number): Observable<OrgStructureDTO[]>;
    addUpdateOrgStruct(item: OrgStructureDTO): Observable<OrgStructure>;
    deleteOrgStructItem(id: number): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class OrgStrucClient implements IOrgStrucClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getDiagOrgStruc(id: number): Observable<OrgStructureDTO[]> {
        let url_ = this.baseUrl + "/api/docflow/OrgStruc/GetDiagOrgStruc/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDiagOrgStruc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDiagOrgStruc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgStructureDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgStructureDTO[]>;
        }));
    }

    protected processGetDiagOrgStruc(response: HttpResponseBase): Observable<OrgStructureDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrgStructureDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUpdateOrgStruct(item: OrgStructureDTO): Observable<OrgStructure> {
        let url_ = this.baseUrl + "/api/docflow/OrgStruc/addUpdateOrgStruct";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdateOrgStruct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdateOrgStruct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrgStructure>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrgStructure>;
        }));
    }

    protected processAddUpdateOrgStruct(response: HttpResponseBase): Observable<OrgStructure> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrgStructure.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOrgStructItem(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/docflow/OrgStruc/DeleteOrgStructItem/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrgStructItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrgStructItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteOrgStructItem(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStatisticClient {
    getGeneralStatDoc(): Observable<GeneralStatDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class StatisticClient implements IStatisticClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getGeneralStatDoc(): Observable<GeneralStatDTO> {
        let url_ = this.baseUrl + "/api/docflow/Statistic/GetGeneralStatDoc";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStatDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStatDoc(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralStatDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralStatDTO>;
        }));
    }

    protected processGetGeneralStatDoc(response: HttpResponseBase): Observable<GeneralStatDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralStatDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class QueryResultOfDocListDTO implements IQueryResultOfDocListDTO {
    items!: DocListDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfDocListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocListDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfDocListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfDocListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfDocListDTO {
    items: DocListDTO[];
    totalItems: number;
}

export class DocListDTO implements IDocListDTO {
    id!: number;
    codeDoc!: string;
    dateCome!: string;
    codeGetDoc!: string;
    dateGetCome!: string;
    spNomenclatMainIn!: string;
    whereFromOrgName!: string;
    shortDescripDoc!: string;
    dateEnd!: string;
    dateDone!: string;
    spDocCurStat!: string;
    underControl!: boolean;
    staffOtv!: OtvByResolDTO[];
    dateAdd!: string;

    constructor(data?: IDocListDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.staffOtv = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codeDoc = _data["codeDoc"];
            this.dateCome = _data["dateCome"];
            this.codeGetDoc = _data["codeGetDoc"];
            this.dateGetCome = _data["dateGetCome"];
            this.spNomenclatMainIn = _data["spNomenclatMainIn"];
            this.whereFromOrgName = _data["whereFromOrgName"];
            this.shortDescripDoc = _data["shortDescripDoc"];
            this.dateEnd = _data["dateEnd"];
            this.dateDone = _data["dateDone"];
            this.spDocCurStat = _data["spDocCurStat"];
            this.underControl = _data["underControl"];
            if (Array.isArray(_data["staffOtv"])) {
                this.staffOtv = [] as any;
                for (let item of _data["staffOtv"])
                    this.staffOtv!.push(OtvByResolDTO.fromJS(item));
            }
            this.dateAdd = _data["dateAdd"];
        }
    }

    static fromJS(data: any): DocListDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocListDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeDoc"] = this.codeDoc;
        data["dateCome"] = this.dateCome;
        data["codeGetDoc"] = this.codeGetDoc;
        data["dateGetCome"] = this.dateGetCome;
        data["spNomenclatMainIn"] = this.spNomenclatMainIn;
        data["whereFromOrgName"] = this.whereFromOrgName;
        data["shortDescripDoc"] = this.shortDescripDoc;
        data["dateEnd"] = this.dateEnd;
        data["dateDone"] = this.dateDone;
        data["spDocCurStat"] = this.spDocCurStat;
        data["underControl"] = this.underControl;
        if (Array.isArray(this.staffOtv)) {
            data["staffOtv"] = [];
            for (let item of this.staffOtv)
                data["staffOtv"].push(item.toJSON());
        }
        data["dateAdd"] = this.dateAdd;
        return data;
    }
}

export interface IDocListDTO {
    id: number;
    codeDoc: string;
    dateCome: string;
    codeGetDoc: string;
    dateGetCome: string;
    spNomenclatMainIn: string;
    whereFromOrgName: string;
    shortDescripDoc: string;
    dateEnd: string;
    dateDone: string;
    spDocCurStat: string;
    underControl: boolean;
    staffOtv: OtvByResolDTO[];
    dateAdd: string;
}

export class OtvByResolDTO implements IOtvByResolDTO {
    tbDocAccessId?: number | undefined;
    staffId?: number | undefined;
    insitutionId?: number | undefined;
    spDepartmentId?: number | undefined;
    spPositionId?: number | undefined;
    nameText!: string;
    typeOrgStruc!: string;
    svod!: boolean;
    iconText!: string;

    constructor(data?: IOtvByResolDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tbDocAccessId = _data["tbDocAccessId"];
            this.staffId = _data["staffId"];
            this.insitutionId = _data["insitutionId"];
            this.spDepartmentId = _data["spDepartmentId"];
            this.spPositionId = _data["spPositionId"];
            this.nameText = _data["nameText"];
            this.typeOrgStruc = _data["typeOrgStruc"];
            this.svod = _data["svod"];
            this.iconText = _data["iconText"];
        }
    }

    static fromJS(data: any): OtvByResolDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OtvByResolDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tbDocAccessId"] = this.tbDocAccessId;
        data["staffId"] = this.staffId;
        data["insitutionId"] = this.insitutionId;
        data["spDepartmentId"] = this.spDepartmentId;
        data["spPositionId"] = this.spPositionId;
        data["nameText"] = this.nameText;
        data["typeOrgStruc"] = this.typeOrgStruc;
        data["svod"] = this.svod;
        data["iconText"] = this.iconText;
        return data;
    }
}

export interface IOtvByResolDTO {
    tbDocAccessId?: number | undefined;
    staffId?: number | undefined;
    insitutionId?: number | undefined;
    spDepartmentId?: number | undefined;
    spPositionId?: number | undefined;
    nameText: string;
    typeOrgStruc: string;
    svod: boolean;
    iconText: string;
}

export class TableMetaData implements ITableMetaData {
    filters?: string | undefined;
    first!: number;
    rows!: number;
    sortField?: string | undefined;
    sortOrder!: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;

    constructor(data?: ITableMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"];
            this.first = _data["first"];
            this.rows = _data["rows"];
            this.sortField = _data["sortField"];
            this.sortOrder = _data["sortOrder"];
            this.filterHandle = _data["filterHandle"];
            this.tagHandle = _data["tagHandle"];
            this.globalFilter = _data["globalFilter"];
        }
    }

    static fromJS(data: any): TableMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters;
        data["first"] = this.first;
        data["rows"] = this.rows;
        data["sortField"] = this.sortField;
        data["sortOrder"] = this.sortOrder;
        data["filterHandle"] = this.filterHandle;
        data["tagHandle"] = this.tagHandle;
        data["globalFilter"] = this.globalFilter;
        return data;
    }
}

export interface ITableMetaData {
    filters?: string | undefined;
    first: number;
    rows: number;
    sortField?: string | undefined;
    sortOrder: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;
}

export class DocDTO implements IDocDTO {
    id?: number | undefined;
    codeDoc!: string;
    dateCome?: Date | undefined;
    spNomenclatMainInId?: string | undefined;
    spNomenclatMainInCode?: string | undefined;
    spGosVlastId?: string | undefined;
    spCompanyId?: string | undefined;
    spNormaId?: string | undefined;
    whereFromAdress!: string;
    whereFromOrgName!: string;
    codeGetDoc!: string;
    dateGetCome?: Date | undefined;
    shortDescripDoc!: string;
    shortNoteDoc!: string;
    shortNoteDocChange!: string;
    resolStaffId?: number | undefined;
    resolStaffPositionId?: number | undefined;
    dateEnd?: Date | undefined;
    dateDone?: Date | undefined;
    spDocCurStatId?: string | undefined;
    spDocInComeId?: string | undefined;
    spDocInComeOtherText!: string;
    email!: string;
    phone!: string;
    underControl!: boolean;
    fullDoc!: boolean;
    dateAdd?: Date | undefined;
    staffAdd?: number | undefined;
    filesId!: number[];
    blankNumber!: string;
    withoutResol!: boolean;
    tbDocLinkList!: SelectItem[];

    constructor(data?: IDocDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.filesId = [];
            this.tbDocLinkList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.codeDoc = _data["codeDoc"];
            this.dateCome = _data["dateCome"] ? new Date(_data["dateCome"].toString()) : <any>undefined;
            this.spNomenclatMainInId = _data["spNomenclatMainInId"];
            this.spNomenclatMainInCode = _data["spNomenclatMainInCode"];
            this.spGosVlastId = _data["spGosVlastId"];
            this.spCompanyId = _data["spCompanyId"];
            this.spNormaId = _data["spNormaId"];
            this.whereFromAdress = _data["whereFromAdress"];
            this.whereFromOrgName = _data["whereFromOrgName"];
            this.codeGetDoc = _data["codeGetDoc"];
            this.dateGetCome = _data["dateGetCome"] ? new Date(_data["dateGetCome"].toString()) : <any>undefined;
            this.shortDescripDoc = _data["shortDescripDoc"];
            this.shortNoteDoc = _data["shortNoteDoc"];
            this.shortNoteDocChange = _data["shortNoteDocChange"];
            this.resolStaffId = _data["resolStaffId"];
            this.resolStaffPositionId = _data["resolStaffPositionId"];
            this.dateEnd = _data["dateEnd"] ? new Date(_data["dateEnd"].toString()) : <any>undefined;
            this.dateDone = _data["dateDone"] ? new Date(_data["dateDone"].toString()) : <any>undefined;
            this.spDocCurStatId = _data["spDocCurStatId"];
            this.spDocInComeId = _data["spDocInComeId"];
            this.spDocInComeOtherText = _data["spDocInComeOtherText"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.underControl = _data["underControl"];
            this.fullDoc = _data["fullDoc"];
            this.dateAdd = _data["dateAdd"] ? new Date(_data["dateAdd"].toString()) : <any>undefined;
            this.staffAdd = _data["staffAdd"];
            if (Array.isArray(_data["filesId"])) {
                this.filesId = [] as any;
                for (let item of _data["filesId"])
                    this.filesId!.push(item);
            }
            this.blankNumber = _data["blankNumber"];
            this.withoutResol = _data["withoutResol"];
            if (Array.isArray(_data["tbDocLinkList"])) {
                this.tbDocLinkList = [] as any;
                for (let item of _data["tbDocLinkList"])
                    this.tbDocLinkList!.push(SelectItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DocDTO {
        data = typeof data === 'object' ? data : {};
        let result = new DocDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeDoc"] = this.codeDoc;
        data["dateCome"] = this.dateCome ? this.dateCome.toISOString() : <any>undefined;
        data["spNomenclatMainInId"] = this.spNomenclatMainInId;
        data["spNomenclatMainInCode"] = this.spNomenclatMainInCode;
        data["spGosVlastId"] = this.spGosVlastId;
        data["spCompanyId"] = this.spCompanyId;
        data["spNormaId"] = this.spNormaId;
        data["whereFromAdress"] = this.whereFromAdress;
        data["whereFromOrgName"] = this.whereFromOrgName;
        data["codeGetDoc"] = this.codeGetDoc;
        data["dateGetCome"] = this.dateGetCome ? this.dateGetCome.toISOString() : <any>undefined;
        data["shortDescripDoc"] = this.shortDescripDoc;
        data["shortNoteDoc"] = this.shortNoteDoc;
        data["shortNoteDocChange"] = this.shortNoteDocChange;
        data["resolStaffId"] = this.resolStaffId;
        data["resolStaffPositionId"] = this.resolStaffPositionId;
        data["dateEnd"] = this.dateEnd ? this.dateEnd.toISOString() : <any>undefined;
        data["dateDone"] = this.dateDone ? this.dateDone.toISOString() : <any>undefined;
        data["spDocCurStatId"] = this.spDocCurStatId;
        data["spDocInComeId"] = this.spDocInComeId;
        data["spDocInComeOtherText"] = this.spDocInComeOtherText;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["underControl"] = this.underControl;
        data["fullDoc"] = this.fullDoc;
        data["dateAdd"] = this.dateAdd ? this.dateAdd.toISOString() : <any>undefined;
        data["staffAdd"] = this.staffAdd;
        if (Array.isArray(this.filesId)) {
            data["filesId"] = [];
            for (let item of this.filesId)
                data["filesId"].push(item);
        }
        data["blankNumber"] = this.blankNumber;
        data["withoutResol"] = this.withoutResol;
        if (Array.isArray(this.tbDocLinkList)) {
            data["tbDocLinkList"] = [];
            for (let item of this.tbDocLinkList)
                data["tbDocLinkList"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDocDTO {
    id?: number | undefined;
    codeDoc: string;
    dateCome?: Date | undefined;
    spNomenclatMainInId?: string | undefined;
    spNomenclatMainInCode?: string | undefined;
    spGosVlastId?: string | undefined;
    spCompanyId?: string | undefined;
    spNormaId?: string | undefined;
    whereFromAdress: string;
    whereFromOrgName: string;
    codeGetDoc: string;
    dateGetCome?: Date | undefined;
    shortDescripDoc: string;
    shortNoteDoc: string;
    shortNoteDocChange: string;
    resolStaffId?: number | undefined;
    resolStaffPositionId?: number | undefined;
    dateEnd?: Date | undefined;
    dateDone?: Date | undefined;
    spDocCurStatId?: string | undefined;
    spDocInComeId?: string | undefined;
    spDocInComeOtherText: string;
    email: string;
    phone: string;
    underControl: boolean;
    fullDoc: boolean;
    dateAdd?: Date | undefined;
    staffAdd?: number | undefined;
    filesId: number[];
    blankNumber: string;
    withoutResol: boolean;
    tbDocLinkList: SelectItem[];
}

export class SelectItem implements ISelectItem {
    label!: string;
    value!: string;
    dataInt?: number | undefined;
    code?: string | undefined;
    rootCode?: string | undefined;
    dataStr?: string | undefined;
    dataStr2?: string | undefined;
    dateTime?: string | undefined;

    constructor(data?: ISelectItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
            this.dataInt = _data["dataInt"];
            this.code = _data["code"];
            this.rootCode = _data["rootCode"];
            this.dataStr = _data["dataStr"];
            this.dataStr2 = _data["dataStr2"];
            this.dateTime = _data["dateTime"];
        }
    }

    static fromJS(data: any): SelectItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        data["dataInt"] = this.dataInt;
        data["code"] = this.code;
        data["rootCode"] = this.rootCode;
        data["dataStr"] = this.dataStr;
        data["dataStr2"] = this.dataStr2;
        data["dateTime"] = this.dateTime;
        return data;
    }
}

export interface ISelectItem {
    label: string;
    value: string;
    dataInt?: number | undefined;
    code?: string | undefined;
    rootCode?: string | undefined;
    dataStr?: string | undefined;
    dataStr2?: string | undefined;
    dateTime?: string | undefined;
}

export class OrgStructureDTO implements IOrgStructureDTO {
    id!: number;
    rootId!: number;
    staffId?: number | undefined;
    spInstitutionId?: number | undefined;
    spDepartmentId?: number | undefined;
    spPositionId?: number | undefined;
    label?: string | undefined;
    type?: string | undefined;
    typeOrgStruct!: TypeOrgStructure;
    styleClass?: string | undefined;
    expanded!: boolean;
    dataName?: string | undefined;
    dataPicture?: string | undefined;
    children!: OrgStructureDTO[];
    expandedIcon?: string | undefined;
    collapsedIcon?: string | undefined;

    constructor(data?: IOrgStructureDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.children = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.rootId = _data["rootId"];
            this.staffId = _data["staffId"];
            this.spInstitutionId = _data["spInstitutionId"];
            this.spDepartmentId = _data["spDepartmentId"];
            this.spPositionId = _data["spPositionId"];
            this.label = _data["label"];
            this.type = _data["type"];
            this.typeOrgStruct = _data["typeOrgStruct"];
            this.styleClass = _data["styleClass"];
            this.expanded = _data["expanded"];
            this.dataName = _data["dataName"];
            this.dataPicture = _data["dataPicture"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(OrgStructureDTO.fromJS(item));
            }
            this.expandedIcon = _data["expandedIcon"];
            this.collapsedIcon = _data["collapsedIcon"];
        }
    }

    static fromJS(data: any): OrgStructureDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrgStructureDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rootId"] = this.rootId;
        data["staffId"] = this.staffId;
        data["spInstitutionId"] = this.spInstitutionId;
        data["spDepartmentId"] = this.spDepartmentId;
        data["spPositionId"] = this.spPositionId;
        data["label"] = this.label;
        data["type"] = this.type;
        data["typeOrgStruct"] = this.typeOrgStruct;
        data["styleClass"] = this.styleClass;
        data["expanded"] = this.expanded;
        data["dataName"] = this.dataName;
        data["dataPicture"] = this.dataPicture;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["expandedIcon"] = this.expandedIcon;
        data["collapsedIcon"] = this.collapsedIcon;
        return data;
    }
}

export interface IOrgStructureDTO {
    id: number;
    rootId: number;
    staffId?: number | undefined;
    spInstitutionId?: number | undefined;
    spDepartmentId?: number | undefined;
    spPositionId?: number | undefined;
    label?: string | undefined;
    type?: string | undefined;
    typeOrgStruct: TypeOrgStructure;
    styleClass?: string | undefined;
    expanded: boolean;
    dataName?: string | undefined;
    dataPicture?: string | undefined;
    children: OrgStructureDTO[];
    expandedIcon?: string | undefined;
    collapsedIcon?: string | undefined;
}

export enum TypeOrgStructure {
    Institution = 0,
    Department = 1,
    Position = 2,
    Staff = 3,
}

export abstract class EntityBase implements IEntityBase {
    id!: number;
    active!: boolean;
    createdBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedBy?: number | undefined;
    lastModifiedDate?: Date | undefined;
    comment?: string | undefined;

    constructor(data?: IEntityBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.active = _data["active"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): EntityBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["active"] = this.active;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IEntityBase {
    id: number;
    active: boolean;
    createdBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedBy?: number | undefined;
    lastModifiedDate?: Date | undefined;
    comment?: string | undefined;
}

export class OrgStructure extends EntityBase implements IOrgStructure {
    rootId!: number;
    spInstitutionId?: number | undefined;
    spDepartmentId?: number | undefined;
    spPositionId?: number | undefined;
    staffId?: number | undefined;
    typeOrgStruct!: TypeOrgStructure;

    constructor(data?: IOrgStructure) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rootId = _data["rootId"];
            this.spInstitutionId = _data["spInstitutionId"];
            this.spDepartmentId = _data["spDepartmentId"];
            this.spPositionId = _data["spPositionId"];
            this.staffId = _data["staffId"];
            this.typeOrgStruct = _data["typeOrgStruct"];
        }
    }

    static override fromJS(data: any): OrgStructure {
        data = typeof data === 'object' ? data : {};
        let result = new OrgStructure();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootId"] = this.rootId;
        data["spInstitutionId"] = this.spInstitutionId;
        data["spDepartmentId"] = this.spDepartmentId;
        data["spPositionId"] = this.spPositionId;
        data["staffId"] = this.staffId;
        data["typeOrgStruct"] = this.typeOrgStruct;
        super.toJSON(data);
        return data;
    }
}

export interface IOrgStructure extends IEntityBase {
    rootId: number;
    spInstitutionId?: number | undefined;
    spDepartmentId?: number | undefined;
    spPositionId?: number | undefined;
    staffId?: number | undefined;
    typeOrgStruct: TypeOrgStructure;
}

export class GeneralStatDTO implements IGeneralStatDTO {
    gDocs!: number;
    notRead!: number;
    onControl!: number;
    new!: number;
    doc1_2!: number;
    critic!: number;
    onLook!: number;
    done!: number;
    otkaz!: number;
    gRetrivedByCI!: number;
    gAnotherOrg!: number;
    gSvodOnly!: number;
    gNorma!: number;
    outDocs!: number;

    constructor(data?: IGeneralStatDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gDocs = _data["gDocs"];
            this.notRead = _data["notRead"];
            this.onControl = _data["onControl"];
            this.new = _data["new"];
            this.doc1_2 = _data["doc1_2"];
            this.critic = _data["critic"];
            this.onLook = _data["onLook"];
            this.done = _data["done"];
            this.otkaz = _data["otkaz"];
            this.gRetrivedByCI = _data["gRetrivedByCI"];
            this.gAnotherOrg = _data["gAnotherOrg"];
            this.gSvodOnly = _data["gSvodOnly"];
            this.gNorma = _data["gNorma"];
            this.outDocs = _data["outDocs"];
        }
    }

    static fromJS(data: any): GeneralStatDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralStatDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gDocs"] = this.gDocs;
        data["notRead"] = this.notRead;
        data["onControl"] = this.onControl;
        data["new"] = this.new;
        data["doc1_2"] = this.doc1_2;
        data["critic"] = this.critic;
        data["onLook"] = this.onLook;
        data["done"] = this.done;
        data["otkaz"] = this.otkaz;
        data["gRetrivedByCI"] = this.gRetrivedByCI;
        data["gAnotherOrg"] = this.gAnotherOrg;
        data["gSvodOnly"] = this.gSvodOnly;
        data["gNorma"] = this.gNorma;
        data["outDocs"] = this.outDocs;
        return data;
    }
}

export interface IGeneralStatDTO {
    gDocs: number;
    notRead: number;
    onControl: number;
    new: number;
    doc1_2: number;
    critic: number;
    onLook: number;
    done: number;
    otkaz: number;
    gRetrivedByCI: number;
    gAnotherOrg: number;
    gSvodOnly: number;
    gNorma: number;
    outDocs: number;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}