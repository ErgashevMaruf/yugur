//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IMIPClient {
    getToken(): Observable<TokenModel>;
    getTokenPMTAOrYugur(isPima: boolean): Observable<TokenModel>;
    getPassportPersonData(gCPInputData: GCPRequestApi): Observable<PassportPersonApi>;
    getPersonDocDataWithPhoto(requestCadastr: RequestCadastr): Observable<GetDataByPinppResponseData>;
    getByPassportSerialNumberAndPinfl(request: GetByPassportSerialNumberAndPinflRequest): Observable<FileResponse | null>;
    getByPassportSerialNumberAndBirthDate(request: GetByPassportSerialNumberAndBirthDateRequest): Observable<FileResponse | null>;
    getByPinflAndBirthDate(request: GetByPinflAndBirthDateRequest): Observable<FileResponse | null>;
    getByPinflAndBirthDateStatic(request: GetByPinflAndBirthDateRequest): Observable<FileResponse | null>;
    getByPassportSerialNumberAndBirthDateStatic(request: GetByPassportSerialNumberAndBirthDateRequest): Observable<PassportPersonDTO>;
    getCadastrDataMip2(pinfl: string | null): Observable<FileResponse | null>;
    getStudentByPinflFromHemis(pinfl: string | null): Observable<FileResponse | null>;
    getAthleteFromErpByPinfl(pinfl: string | null): Observable<FileResponse | null>;
    getERPSportNTMemberByPinfl(pinfl: string | null): Observable<FileResponse | null>;
    getAthleteByPinflFromERPsport(pinfl: string | null): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class MIPClient implements IMIPClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getToken(): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTokenPMTAOrYugur(isPima: boolean): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetTokenPMTAOrYugur/{isPima}";
        if (isPima === undefined || isPima === null)
            throw new Error("The parameter 'isPima' must be defined.");
        url_ = url_.replace("{isPima}", encodeURIComponent("" + isPima));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTokenPMTAOrYugur(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTokenPMTAOrYugur(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processGetTokenPMTAOrYugur(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPassportPersonData(gCPInputData: GCPRequestApi): Observable<PassportPersonApi> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetPassportPersonData";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(gCPInputData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPassportPersonData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPassportPersonData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassportPersonApi>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassportPersonApi>;
        }));
    }

    protected processGetPassportPersonData(response: HttpResponseBase): Observable<PassportPersonApi> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassportPersonApi.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPersonDocDataWithPhoto(requestCadastr: RequestCadastr): Observable<GetDataByPinppResponseData> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetPersonDocDataWithPhoto";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestCadastr);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonDocDataWithPhoto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonDocDataWithPhoto(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDataByPinppResponseData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDataByPinppResponseData>;
        }));
    }

    protected processGetPersonDocDataWithPhoto(response: HttpResponseBase): Observable<GetDataByPinppResponseData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDataByPinppResponseData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPassportSerialNumberAndPinfl(request: GetByPassportSerialNumberAndPinflRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetByPassportSerialNumberAndPinfl";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPassportSerialNumberAndPinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPassportSerialNumberAndPinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetByPassportSerialNumberAndPinfl(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPassportSerialNumberAndBirthDate(request: GetByPassportSerialNumberAndBirthDateRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetByPassportSerialNumberAndBirthDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPassportSerialNumberAndBirthDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPassportSerialNumberAndBirthDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetByPassportSerialNumberAndBirthDate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPinflAndBirthDate(request: GetByPinflAndBirthDateRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetByPinflAndBirthDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPinflAndBirthDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPinflAndBirthDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetByPinflAndBirthDate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPinflAndBirthDateStatic(request: GetByPinflAndBirthDateRequest): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetByPinflAndBirthDateStatic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPinflAndBirthDateStatic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPinflAndBirthDateStatic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetByPinflAndBirthDateStatic(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByPassportSerialNumberAndBirthDateStatic(request: GetByPassportSerialNumberAndBirthDateRequest): Observable<PassportPersonDTO> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetByPassportSerialNumberAndBirthDateStatic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByPassportSerialNumberAndBirthDateStatic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByPassportSerialNumberAndBirthDateStatic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PassportPersonDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PassportPersonDTO>;
        }));
    }

    protected processGetByPassportSerialNumberAndBirthDateStatic(response: HttpResponseBase): Observable<PassportPersonDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PassportPersonDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCadastrDataMip2(pinfl: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetCadastrDataMip2/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCadastrDataMip2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCadastrDataMip2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetCadastrDataMip2(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getStudentByPinflFromHemis(pinfl: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetStudentByPinflFromHemis/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentByPinflFromHemis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentByPinflFromHemis(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetStudentByPinflFromHemis(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthleteFromErpByPinfl(pinfl: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetAthleteFromErpByPinfl/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthleteFromErpByPinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthleteFromErpByPinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetAthleteFromErpByPinfl(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getERPSportNTMemberByPinfl(pinfl: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetERPSportNTMemberByPinfl/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetERPSportNTMemberByPinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetERPSportNTMemberByPinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetERPSportNTMemberByPinfl(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthleteByPinflFromERPsport(pinfl: string | null): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/mip2/MIP/GetAthleteByPinflFromERPsport/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthleteByPinflFromERPsport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthleteByPinflFromERPsport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetAthleteByPinflFromERPsport(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class TokenModel implements ITokenModel {
    access_token!: string;
    refresh_token!: string;
    scope!: string;
    token_type!: string;
    expires_in!: number;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.refresh_token = _data["refresh_token"];
            this.scope = _data["scope"];
            this.token_type = _data["token_type"];
            this.expires_in = _data["expires_in"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["refresh_token"] = this.refresh_token;
        data["scope"] = this.scope;
        data["token_type"] = this.token_type;
        data["expires_in"] = this.expires_in;
        return data;
    }
}

export interface ITokenModel {
    access_token: string;
    refresh_token: string;
    scope: string;
    token_type: string;
    expires_in: number;
}

export class PassportPersonApi implements IPassportPersonApi {
    pIssuedDate!: string;
    pPlaceBirth!: string;
    pPinpp!: string;
    pPatronym!: string;
    pSurname!: string;
    pName!: string;
    pAnswereId!: string;
    pIssuedBy!: string;
    pSex!: string;
    pSurnameEng!: string;
    pNameEng!: string;
    pPsp!: string;
    pNationality!: string;
    pNationalityId!: string;
    pCitizenship!: string;
    pCitizenshipId!: string;
    pDateBirth!: string;
    pValidDate!: string;
    pAnswereMessage!: string;
    spRegionId!: string;
    spDistrictId!: string;
    address!: string;
    countryId!: string;
    countryName!: string;
    passportSeria!: string;
    passportNumber!: string;
    isFromGCP!: boolean;

    constructor(data?: IPassportPersonApi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pIssuedDate = _data["pIssuedDate"];
            this.pPlaceBirth = _data["pPlaceBirth"];
            this.pPinpp = _data["pPinpp"];
            this.pPatronym = _data["pPatronym"];
            this.pSurname = _data["pSurname"];
            this.pName = _data["pName"];
            this.pAnswereId = _data["pAnswereId"];
            this.pIssuedBy = _data["pIssuedBy"];
            this.pSex = _data["pSex"];
            this.pSurnameEng = _data["pSurnameEng"];
            this.pNameEng = _data["pNameEng"];
            this.pPsp = _data["pPsp"];
            this.pNationality = _data["pNationality"];
            this.pNationalityId = _data["pNationalityId"];
            this.pCitizenship = _data["pCitizenship"];
            this.pCitizenshipId = _data["pCitizenshipId"];
            this.pDateBirth = _data["pDateBirth"];
            this.pValidDate = _data["pValidDate"];
            this.pAnswereMessage = _data["pAnswereMessage"];
            this.spRegionId = _data["spRegionId"];
            this.spDistrictId = _data["spDistrictId"];
            this.address = _data["address"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
            this.passportSeria = _data["passportSeria"];
            this.passportNumber = _data["passportNumber"];
            this.isFromGCP = _data["isFromGCP"];
        }
    }

    static fromJS(data: any): PassportPersonApi {
        data = typeof data === 'object' ? data : {};
        let result = new PassportPersonApi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pIssuedDate"] = this.pIssuedDate;
        data["pPlaceBirth"] = this.pPlaceBirth;
        data["pPinpp"] = this.pPinpp;
        data["pPatronym"] = this.pPatronym;
        data["pSurname"] = this.pSurname;
        data["pName"] = this.pName;
        data["pAnswereId"] = this.pAnswereId;
        data["pIssuedBy"] = this.pIssuedBy;
        data["pSex"] = this.pSex;
        data["pSurnameEng"] = this.pSurnameEng;
        data["pNameEng"] = this.pNameEng;
        data["pPsp"] = this.pPsp;
        data["pNationality"] = this.pNationality;
        data["pNationalityId"] = this.pNationalityId;
        data["pCitizenship"] = this.pCitizenship;
        data["pCitizenshipId"] = this.pCitizenshipId;
        data["pDateBirth"] = this.pDateBirth;
        data["pValidDate"] = this.pValidDate;
        data["pAnswereMessage"] = this.pAnswereMessage;
        data["spRegionId"] = this.spRegionId;
        data["spDistrictId"] = this.spDistrictId;
        data["address"] = this.address;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        data["passportSeria"] = this.passportSeria;
        data["passportNumber"] = this.passportNumber;
        data["isFromGCP"] = this.isFromGCP;
        return data;
    }
}

export interface IPassportPersonApi {
    pIssuedDate: string;
    pPlaceBirth: string;
    pPinpp: string;
    pPatronym: string;
    pSurname: string;
    pName: string;
    pAnswereId: string;
    pIssuedBy: string;
    pSex: string;
    pSurnameEng: string;
    pNameEng: string;
    pPsp: string;
    pNationality: string;
    pNationalityId: string;
    pCitizenship: string;
    pCitizenshipId: string;
    pDateBirth: string;
    pValidDate: string;
    pAnswereMessage: string;
    spRegionId: string;
    spDistrictId: string;
    address: string;
    countryId: string;
    countryName: string;
    passportSeria: string;
    passportNumber: string;
    isFromGCP: boolean;
}

export class GCPRequestApi implements IGCPRequestApi {
    birthDate!: string;
    pspSerial!: string;
    pspNumber!: string;

    constructor(data?: IGCPRequestApi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthDate = _data["birthDate"];
            this.pspSerial = _data["pspSerial"];
            this.pspNumber = _data["pspNumber"];
        }
    }

    static fromJS(data: any): GCPRequestApi {
        data = typeof data === 'object' ? data : {};
        let result = new GCPRequestApi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate;
        data["pspSerial"] = this.pspSerial;
        data["pspNumber"] = this.pspNumber;
        return data;
    }
}

export interface IGCPRequestApi {
    birthDate: string;
    pspSerial: string;
    pspNumber: string;
}

export class GetDataByPinppResponseData implements IGetDataByPinppResponseData {
    result!: number;
    data!: PersonInfoWithPhotoModel;

    constructor(data?: IGetDataByPinppResponseData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new PersonInfoWithPhotoModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.data = _data["data"] ? PersonInfoWithPhotoModel.fromJS(_data["data"]) : new PersonInfoWithPhotoModel();
        }
    }

    static fromJS(data: any): GetDataByPinppResponseData {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataByPinppResponseData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetDataByPinppResponseData {
    result: number;
    data: PersonInfoWithPhotoModel;
}

export class PersonInfoWithPhotoModel implements IPersonInfoWithPhotoModel {
    pinpp!: number;
    doc_seria!: string;
    doc_number!: string;
    surnamelatin!: string;
    namelatin!: string;
    patronymlatin!: string;
    engsurname!: string;
    engname!: string;
    birthdate!: string;
    birthplace!: string;
    birthplaceid?: number | undefined;
    birthcountry!: string;
    birthcountryid?: number | undefined;
    livestatus?: number | undefined;
    nationality!: string;
    nationalityid?: number | undefined;
    citizenship!: string;
    citizenshipid?: number | undefined;
    sex?: number | undefined;
    docgiveplace!: string;
    docgiveplaceid!: string;
    docdatebegin?: Date | undefined;
    docdateend?: Date | undefined;
    photo!: string;

    constructor(data?: IPersonInfoWithPhotoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pinpp = _data["pinpp"];
            this.doc_seria = _data["doc_seria"];
            this.doc_number = _data["doc_number"];
            this.surnamelatin = _data["surnamelatin"];
            this.namelatin = _data["namelatin"];
            this.patronymlatin = _data["patronymlatin"];
            this.engsurname = _data["engsurname"];
            this.engname = _data["engname"];
            this.birthdate = _data["birthdate"];
            this.birthplace = _data["birthplace"];
            this.birthplaceid = _data["birthplaceid"];
            this.birthcountry = _data["birthcountry"];
            this.birthcountryid = _data["birthcountryid"];
            this.livestatus = _data["livestatus"];
            this.nationality = _data["nationality"];
            this.nationalityid = _data["nationalityid"];
            this.citizenship = _data["citizenship"];
            this.citizenshipid = _data["citizenshipid"];
            this.sex = _data["sex"];
            this.docgiveplace = _data["docgiveplace"];
            this.docgiveplaceid = _data["docgiveplaceid"];
            this.docdatebegin = _data["docdatebegin"] ? new Date(_data["docdatebegin"].toString()) : <any>undefined;
            this.docdateend = _data["docdateend"] ? new Date(_data["docdateend"].toString()) : <any>undefined;
            this.photo = _data["photo"];
        }
    }

    static fromJS(data: any): PersonInfoWithPhotoModel {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInfoWithPhotoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pinpp"] = this.pinpp;
        data["doc_seria"] = this.doc_seria;
        data["doc_number"] = this.doc_number;
        data["surnamelatin"] = this.surnamelatin;
        data["namelatin"] = this.namelatin;
        data["patronymlatin"] = this.patronymlatin;
        data["engsurname"] = this.engsurname;
        data["engname"] = this.engname;
        data["birthdate"] = this.birthdate;
        data["birthplace"] = this.birthplace;
        data["birthplaceid"] = this.birthplaceid;
        data["birthcountry"] = this.birthcountry;
        data["birthcountryid"] = this.birthcountryid;
        data["livestatus"] = this.livestatus;
        data["nationality"] = this.nationality;
        data["nationalityid"] = this.nationalityid;
        data["citizenship"] = this.citizenship;
        data["citizenshipid"] = this.citizenshipid;
        data["sex"] = this.sex;
        data["docgiveplace"] = this.docgiveplace;
        data["docgiveplaceid"] = this.docgiveplaceid;
        data["docdatebegin"] = this.docdatebegin ? this.docdatebegin.toISOString() : <any>undefined;
        data["docdateend"] = this.docdateend ? this.docdateend.toISOString() : <any>undefined;
        data["photo"] = this.photo;
        return data;
    }
}

export interface IPersonInfoWithPhotoModel {
    pinpp: number;
    doc_seria: string;
    doc_number: string;
    surnamelatin: string;
    namelatin: string;
    patronymlatin: string;
    engsurname: string;
    engname: string;
    birthdate: string;
    birthplace: string;
    birthplaceid?: number | undefined;
    birthcountry: string;
    birthcountryid?: number | undefined;
    livestatus?: number | undefined;
    nationality: string;
    nationalityid?: number | undefined;
    citizenship: string;
    citizenshipid?: number | undefined;
    sex?: number | undefined;
    docgiveplace: string;
    docgiveplaceid: string;
    docdatebegin?: Date | undefined;
    docdateend?: Date | undefined;
    photo: string;
}

export class RequestCadastr implements IRequestCadastr {
    pinfl!: string;
    docGivenDate!: string;

    constructor(data?: IRequestCadastr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pinfl = _data["pinfl"];
            this.docGivenDate = _data["docGivenDate"];
        }
    }

    static fromJS(data: any): RequestCadastr {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCadastr();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pinfl"] = this.pinfl;
        data["docGivenDate"] = this.docGivenDate;
        return data;
    }
}

export interface IRequestCadastr {
    pinfl: string;
    docGivenDate: string;
}

export class Mip2RequestBase implements IMip2RequestBase {
    transaction_id!: number;
    is_consent!: string;
    sender_pinfl!: string;
    langId!: Language;
    sender!: string;
    is_photo!: string;

    constructor(data?: IMip2RequestBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transaction_id = _data["transaction_id"];
            this.is_consent = _data["is_consent"];
            this.sender_pinfl = _data["sender_pinfl"];
            this.langId = _data["langId"];
            this.sender = _data["sender"];
            this.is_photo = _data["is_photo"];
        }
    }

    static fromJS(data: any): Mip2RequestBase {
        data = typeof data === 'object' ? data : {};
        let result = new Mip2RequestBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transaction_id"] = this.transaction_id;
        data["is_consent"] = this.is_consent;
        data["sender_pinfl"] = this.sender_pinfl;
        data["langId"] = this.langId;
        data["sender"] = this.sender;
        data["is_photo"] = this.is_photo;
        return data;
    }
}

export interface IMip2RequestBase {
    transaction_id: number;
    is_consent: string;
    sender_pinfl: string;
    langId: Language;
    sender: string;
    is_photo: string;
}

export class GetByPassportSerialNumberAndPinflRequest extends Mip2RequestBase implements IGetByPassportSerialNumberAndPinflRequest {
    document!: string;
    pinpp!: string;

    constructor(data?: IGetByPassportSerialNumberAndPinflRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.document = _data["document"];
            this.pinpp = _data["pinpp"];
        }
    }

    static override fromJS(data: any): GetByPassportSerialNumberAndPinflRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetByPassportSerialNumberAndPinflRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document;
        data["pinpp"] = this.pinpp;
        super.toJSON(data);
        return data;
    }
}

export interface IGetByPassportSerialNumberAndPinflRequest extends IMip2RequestBase {
    document: string;
    pinpp: string;
}

export enum Language {
    Russian = 1,
    UzbCyril = 2,
    UzbLatin = 3,
}

export class GetByPassportSerialNumberAndBirthDateRequest extends Mip2RequestBase implements IGetByPassportSerialNumberAndBirthDateRequest {
    document!: string;
    birth_date!: string;

    constructor(data?: IGetByPassportSerialNumberAndBirthDateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.document = _data["document"];
            this.birth_date = _data["birth_date"];
        }
    }

    static override fromJS(data: any): GetByPassportSerialNumberAndBirthDateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetByPassportSerialNumberAndBirthDateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document;
        data["birth_date"] = this.birth_date;
        super.toJSON(data);
        return data;
    }
}

export interface IGetByPassportSerialNumberAndBirthDateRequest extends IMip2RequestBase {
    document: string;
    birth_date: string;
}

export class GetByPinflAndBirthDateRequest extends Mip2RequestBase implements IGetByPinflAndBirthDateRequest {
    pinpp!: string;
    birth_date!: string;

    constructor(data?: IGetByPinflAndBirthDateRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pinpp = _data["pinpp"];
            this.birth_date = _data["birth_date"];
        }
    }

    static override fromJS(data: any): GetByPinflAndBirthDateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetByPinflAndBirthDateRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pinpp"] = this.pinpp;
        data["birth_date"] = this.birth_date;
        super.toJSON(data);
        return data;
    }
}

export interface IGetByPinflAndBirthDateRequest extends IMip2RequestBase {
    pinpp: string;
    birth_date: string;
}

export class PassportPersonDTO implements IPassportPersonDTO {
    result!: string;
    comments!: string;
    transaction_id!: number;
    current_pinpp!: string;
    pinpps!: string;
    current_document!: string;
    surnamelat!: string;
    namelat!: string;
    patronymlat!: string;
    surnamecyr!: string;
    namecyr!: string;
    patronymcyr!: string;
    birth_date!: string;
    birthplace!: string;
    birthcountry!: string;
    birthcountryid!: number;
    livestatus!: number;
    nationality!: string;
    nationalityid!: number;
    citizenship!: string;
    citizenshipid!: number;
    sex!: number;
    photo!: string;
    document!: string;
    type!: string;
    docgiveplace!: string;
    docgiveplaceid!: number;
    datebegin!: string;
    dateend!: string;
    status!: number;
    spRegionId!: string;
    spDistrictId!: string;
    address!: string;
    countryId!: string;
    countryName!: string;

    constructor(data?: IPassportPersonDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
            this.comments = _data["comments"];
            this.transaction_id = _data["transaction_id"];
            this.current_pinpp = _data["current_pinpp"];
            this.pinpps = _data["pinpps"];
            this.current_document = _data["current_document"];
            this.surnamelat = _data["surnamelat"];
            this.namelat = _data["namelat"];
            this.patronymlat = _data["patronymlat"];
            this.surnamecyr = _data["surnamecyr"];
            this.namecyr = _data["namecyr"];
            this.patronymcyr = _data["patronymcyr"];
            this.birth_date = _data["birth_date"];
            this.birthplace = _data["birthplace"];
            this.birthcountry = _data["birthcountry"];
            this.birthcountryid = _data["birthcountryid"];
            this.livestatus = _data["livestatus"];
            this.nationality = _data["nationality"];
            this.nationalityid = _data["nationalityid"];
            this.citizenship = _data["citizenship"];
            this.citizenshipid = _data["citizenshipid"];
            this.sex = _data["sex"];
            this.photo = _data["photo"];
            this.document = _data["document"];
            this.type = _data["type"];
            this.docgiveplace = _data["docgiveplace"];
            this.docgiveplaceid = _data["docgiveplaceid"];
            this.datebegin = _data["datebegin"];
            this.dateend = _data["dateend"];
            this.status = _data["status"];
            this.spRegionId = _data["spRegionId"];
            this.spDistrictId = _data["spDistrictId"];
            this.address = _data["address"];
            this.countryId = _data["countryId"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): PassportPersonDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PassportPersonDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["comments"] = this.comments;
        data["transaction_id"] = this.transaction_id;
        data["current_pinpp"] = this.current_pinpp;
        data["pinpps"] = this.pinpps;
        data["current_document"] = this.current_document;
        data["surnamelat"] = this.surnamelat;
        data["namelat"] = this.namelat;
        data["patronymlat"] = this.patronymlat;
        data["surnamecyr"] = this.surnamecyr;
        data["namecyr"] = this.namecyr;
        data["patronymcyr"] = this.patronymcyr;
        data["birth_date"] = this.birth_date;
        data["birthplace"] = this.birthplace;
        data["birthcountry"] = this.birthcountry;
        data["birthcountryid"] = this.birthcountryid;
        data["livestatus"] = this.livestatus;
        data["nationality"] = this.nationality;
        data["nationalityid"] = this.nationalityid;
        data["citizenship"] = this.citizenship;
        data["citizenshipid"] = this.citizenshipid;
        data["sex"] = this.sex;
        data["photo"] = this.photo;
        data["document"] = this.document;
        data["type"] = this.type;
        data["docgiveplace"] = this.docgiveplace;
        data["docgiveplaceid"] = this.docgiveplaceid;
        data["datebegin"] = this.datebegin;
        data["dateend"] = this.dateend;
        data["status"] = this.status;
        data["spRegionId"] = this.spRegionId;
        data["spDistrictId"] = this.spDistrictId;
        data["address"] = this.address;
        data["countryId"] = this.countryId;
        data["countryName"] = this.countryName;
        return data;
    }
}

export interface IPassportPersonDTO {
    result: string;
    comments: string;
    transaction_id: number;
    current_pinpp: string;
    pinpps: string;
    current_document: string;
    surnamelat: string;
    namelat: string;
    patronymlat: string;
    surnamecyr: string;
    namecyr: string;
    patronymcyr: string;
    birth_date: string;
    birthplace: string;
    birthcountry: string;
    birthcountryid: number;
    livestatus: number;
    nationality: string;
    nationalityid: number;
    citizenship: string;
    citizenshipid: number;
    sex: number;
    photo: string;
    document: string;
    type: string;
    docgiveplace: string;
    docgiveplaceid: number;
    datebegin: string;
    dateend: string;
    status: number;
    spRegionId: string;
    spDistrictId: string;
    address: string;
    countryId: string;
    countryName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}