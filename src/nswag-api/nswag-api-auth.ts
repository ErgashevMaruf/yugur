//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountClient {
    getTotalNumberOfUsers(): Observable<ResponseModelOfInteger>;
    login(model: Login): Observable<TokenModel>;
    forgotPassword(selectUser: SelectUser): Observable<ResponseModelOfBoolean>;
    refreshAccessToken(refreshToken: string | null): Observable<ResponseModelOfTokenModel>;
    getUserLogList(uTData: TableMetaData): Observable<QueryResultOfUserLogDTO>;
    changeUserPassword(model: ChangePassword): Observable<Response>;
    resetPasswordToken(model: ResetPasswordWithEmail): Observable<ResponseModelOfResetPassword>;
    resetPasswordUser(model: ResetPassword): Observable<ResponseModelOfTokenModel>;
    updateUserProfile(model: UserRegistrDTO): Observable<ResponseModelOfBoolean>;
    getUserById(id: string | null): Observable<ResponseModelOfUserRegistrDTO>;
    chooseMainRole(model: MainRoleChoose): Observable<TokenModel>;
    userRolChangeRequest(organization: OrganizationModelDTO): Observable<ResponseModelOfBoolean>;
    registerUser(model: UserRegistrDTO): Observable<ResponseModelOfString>;
    confirmUser(code: EmailConfirmed): Observable<ResponseModelOfTokenModel>;
    notConfirmUser(id: string | null): Observable<ResponseModelOfBoolean>;
    addNewRole(roleName: string): Observable<Response>;
    getByAthletsIdsUserApplications(athletesIds: number[]): Observable<UserApplicationModel[]>;
    userProfile(): Observable<UserProfile>;
    checkUserAuthentication(): Observable<boolean>;
    getRoles(): Observable<SelectItem[]>;
    getUserProfile(): Observable<ResponseModelOfUserRegistrDTO>;
    lockOutUser(userId: string | null | undefined): Observable<ResponseModelOfBoolean>;
    unlockUser(userId: string | null | undefined): Observable<ResponseModelOfBoolean>;
    getUserList(uTData: TableMetaData): Observable<QueryResultOfUserRegistrDTO>;
    getUserApplicationStatusList(uTData: TableMetaData): Observable<QueryResultOfUserRegistrDTO>;
    userApplicationAllow(id: string | null): Observable<ResponseModelOfBoolean>;
    userApplicationNotAllow(id: string | null): Observable<ResponseModelOfBoolean>;
    registerOrUpdateUser(model: UserRegistrDTO): Observable<ResponseModelOfBoolean>;
    isUserExists(athletsId: number): Observable<boolean>;
    addUserToRoles(model: ApplicationUserDTO): Observable<ResponseClassOfString>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTotalNumberOfUsers(): Observable<ResponseModelOfInteger> {
        let url_ = this.baseUrl + "/api/auth/Account/GetTotalNumberOfUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTotalNumberOfUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalNumberOfUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfInteger>;
        }));
    }

    protected processGetTotalNumberOfUsers(response: HttpResponseBase): Observable<ResponseModelOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(model: Login): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(selectUser: SelectUser): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshAccessToken(refreshToken: string | null): Observable<ResponseModelOfTokenModel> {
        let url_ = this.baseUrl + "/api/auth/Account/RefreshAccessToken/{refreshToken}";
        if (refreshToken === undefined || refreshToken === null)
            throw new Error("The parameter 'refreshToken' must be defined.");
        url_ = url_.replace("{refreshToken}", encodeURIComponent("" + refreshToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfTokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfTokenModel>;
        }));
    }

    protected processRefreshAccessToken(response: HttpResponseBase): Observable<ResponseModelOfTokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserLogList(uTData: TableMetaData): Observable<QueryResultOfUserLogDTO> {
        let url_ = this.baseUrl + "/api/auth/Account/GetUserLogList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(uTData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLogList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLogList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfUserLogDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfUserLogDTO>;
        }));
    }

    protected processGetUserLogList(response: HttpResponseBase): Observable<QueryResultOfUserLogDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfUserLogDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeUserPassword(model: ChangePassword): Observable<Response> {
        let url_ = this.baseUrl + "/api/auth/Account/ChangeUserPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processChangeUserPassword(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPasswordToken(model: ResetPasswordWithEmail): Observable<ResponseModelOfResetPassword> {
        let url_ = this.baseUrl + "/api/auth/Account/ResetPasswordToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfResetPassword>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfResetPassword>;
        }));
    }

    protected processResetPasswordToken(response: HttpResponseBase): Observable<ResponseModelOfResetPassword> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfResetPassword.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPasswordUser(model: ResetPassword): Observable<ResponseModelOfTokenModel> {
        let url_ = this.baseUrl + "/api/auth/Account/ResetPasswordUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfTokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfTokenModel>;
        }));
    }

    protected processResetPasswordUser(response: HttpResponseBase): Observable<ResponseModelOfTokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUserProfile(model: UserRegistrDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/UpdateUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateUserProfile(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserById(id: string | null): Observable<ResponseModelOfUserRegistrDTO> {
        let url_ = this.baseUrl + "/api/auth/Account/GetUserById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfUserRegistrDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfUserRegistrDTO>;
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<ResponseModelOfUserRegistrDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfUserRegistrDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    chooseMainRole(model: MainRoleChoose): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/Account/ChooseMainRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChooseMainRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChooseMainRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processChooseMainRole(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userRolChangeRequest(organization: OrganizationModelDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/UserRolChangeRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(organization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserRolChangeRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserRolChangeRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUserRolChangeRequest(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registerUser(model: UserRegistrDTO): Observable<ResponseModelOfString> {
        let url_ = this.baseUrl + "/api/auth/Account/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfString>;
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<ResponseModelOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmUser(code: EmailConfirmed): Observable<ResponseModelOfTokenModel> {
        let url_ = this.baseUrl + "/api/auth/Account/ConfirmUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfTokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfTokenModel>;
        }));
    }

    protected processConfirmUser(response: HttpResponseBase): Observable<ResponseModelOfTokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfTokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    notConfirmUser(id: string | null): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/NotConfirmUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotConfirmUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotConfirmUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processNotConfirmUser(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addNewRole(roleName: string): Observable<Response> {
        let url_ = this.baseUrl + "/api/auth/Account/AddNewRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleName);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Response>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Response>;
        }));
    }

    protected processAddNewRole(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByAthletsIdsUserApplications(athletesIds: number[]): Observable<UserApplicationModel[]> {
        let url_ = this.baseUrl + "/api/auth/Account/GetByAthletsIdsUserApplications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletesIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByAthletsIdsUserApplications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByAthletsIdsUserApplications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserApplicationModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserApplicationModel[]>;
        }));
    }

    protected processGetByAthletsIdsUserApplications(response: HttpResponseBase): Observable<UserApplicationModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApplicationModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userProfile(): Observable<UserProfile> {
        let url_ = this.baseUrl + "/api/auth/Account/UserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfile>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfile>;
        }));
    }

    protected processUserProfile(response: HttpResponseBase): Observable<UserProfile> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfile.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkUserAuthentication(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/auth/Account/CheckUserAuthentication";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUserAuthentication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUserAuthentication(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckUserAuthentication(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoles(): Observable<SelectItem[]> {
        let url_ = this.baseUrl + "/api/auth/Account/getRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectItem[]>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<SelectItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserProfile(): Observable<ResponseModelOfUserRegistrDTO> {
        let url_ = this.baseUrl + "/api/auth/Account/GetUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfUserRegistrDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfUserRegistrDTO>;
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<ResponseModelOfUserRegistrDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfUserRegistrDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    lockOutUser(userId: string | null | undefined): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/LockOutUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockOutUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockOutUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processLockOutUser(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unlockUser(userId: string | null | undefined): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/UnlockUser?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserList(uTData: TableMetaData): Observable<QueryResultOfUserRegistrDTO> {
        let url_ = this.baseUrl + "/api/auth/Account/GetUserList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(uTData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfUserRegistrDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfUserRegistrDTO>;
        }));
    }

    protected processGetUserList(response: HttpResponseBase): Observable<QueryResultOfUserRegistrDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfUserRegistrDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserApplicationStatusList(uTData: TableMetaData): Observable<QueryResultOfUserRegistrDTO> {
        let url_ = this.baseUrl + "/api/auth/Account/GetUserApplicationStatusList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(uTData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserApplicationStatusList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserApplicationStatusList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfUserRegistrDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfUserRegistrDTO>;
        }));
    }

    protected processGetUserApplicationStatusList(response: HttpResponseBase): Observable<QueryResultOfUserRegistrDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfUserRegistrDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userApplicationAllow(id: string | null): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/UserApplicationAllow/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserApplicationAllow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserApplicationAllow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUserApplicationAllow(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userApplicationNotAllow(id: string | null): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/UserApplicationNotAllow/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserApplicationNotAllow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserApplicationNotAllow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUserApplicationNotAllow(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registerOrUpdateUser(model: UserRegistrDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/Account/RegisterOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processRegisterOrUpdateUser(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isUserExists(athletsId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/auth/Account/IsUserExists/{athletsId}";
        if (athletsId === undefined || athletsId === null)
            throw new Error("The parameter 'athletsId' must be defined.");
        url_ = url_.replace("{athletsId}", encodeURIComponent("" + athletsId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsUserExists(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUserToRoles(model: ApplicationUserDTO): Observable<ResponseClassOfString> {
        let url_ = this.baseUrl + "/api/auth/Account/AddUserToRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserToRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseClassOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseClassOfString>;
        }));
    }

    protected processAddUserToRoles(response: HttpResponseBase): Observable<ResponseClassOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseClassOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountMobileClient {
    registerUser(model: UserRegistrDTO): Observable<FileResponse | null>;
    updateUserProfile(model: UpdateUserModel): Observable<FileResponse | null>;
    confirmUser(code: EmailConfirmed): Observable<FileResponse | null>;
    getOldMobileVersion(): Observable<FileResponse | null>;
    login(model: Login): Observable<FileResponse | null>;
    forgotPassword(selectUser: SelectUser): Observable<FileResponse | null>;
    resetPasswordToken(code: ResetPasswordWithEmail): Observable<FileResponse | null>;
    resetPasswordUser(model: ResetPassword): Observable<FileResponse | null>;
    getUserProfile(): Observable<FileResponse | null>;
    refreshAccessToken(refreshToken: string | null | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountMobileClient implements IAccountMobileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    registerUser(model: UserRegistrDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/RegisterUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUserProfile(model: UpdateUserModel): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/UpdateUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateUserProfile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    confirmUser(code: EmailConfirmed): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/ConfirmUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processConfirmUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOldMobileVersion(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/GetOldMobileVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOldMobileVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOldMobileVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetOldMobileVersion(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(model: Login): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(selectUser: SelectUser): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPasswordToken(code: ResetPasswordWithEmail): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/ResetPasswordToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(code);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processResetPasswordToken(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPasswordUser(model: ResetPassword): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/ResetPasswordUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPasswordUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPasswordUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processResetPasswordUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserProfile(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/GetUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshAccessToken(refreshToken: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/AccountMobile/RefreshAccessToken?";
        if (refreshToken !== undefined && refreshToken !== null)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRefreshAccessToken(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGeneralClient {
    getVersion(): Observable<string>;
    testLog(): Observable<string>;
    getTime(): Observable<Date>;
    saveUserLog(model: UserLogDTO): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class GeneralClient implements IGeneralClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getVersion(): Observable<string> {
        let url_ = this.baseUrl + "/api/auth/General/GetVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetVersion(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    testLog(): Observable<string> {
        let url_ = this.baseUrl + "/api/auth/General/TestLog";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processTestLog(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTime(): Observable<Date> {
        let url_ = this.baseUrl + "/api/auth/General/GetTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Date>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Date>;
        }));
    }

    protected processGetTime(response: HttpResponseBase): Observable<Date> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveUserLog(model: UserLogDTO): Observable<number> {
        let url_ = this.baseUrl + "/api/auth/General/SaveUserLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserLog(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserLog(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveUserLog(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INavigationClient {
    getNavigations(): Observable<NavigationDTO[]>;
    getNavigationsTreeTable(): Observable<TreeTableDTO[]>;
    getNavigationsTreeSelect(): Observable<TreeSelectDTO[]>;
    itemById(id: number): Observable<NavigationDTO>;
    addUpdate(item: NavigationDTO): Observable<NavigationDTO>;
    upDownOrder(item: NavigationDTO, upDownOrder: UpDownOrder): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class NavigationClient implements INavigationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getNavigations(): Observable<NavigationDTO[]> {
        let url_ = this.baseUrl + "/api/auth/Navigation/GetNavigations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNavigations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNavigations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NavigationDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NavigationDTO[]>;
        }));
    }

    protected processGetNavigations(response: HttpResponseBase): Observable<NavigationDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NavigationDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNavigationsTreeTable(): Observable<TreeTableDTO[]> {
        let url_ = this.baseUrl + "/api/auth/Navigation/GetNavigationsTreeTable";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNavigationsTreeTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNavigationsTreeTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeTableDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeTableDTO[]>;
        }));
    }

    protected processGetNavigationsTreeTable(response: HttpResponseBase): Observable<TreeTableDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeTableDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNavigationsTreeSelect(): Observable<TreeSelectDTO[]> {
        let url_ = this.baseUrl + "/api/auth/Navigation/GetNavigationsTreeSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNavigationsTreeSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNavigationsTreeSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreeSelectDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreeSelectDTO[]>;
        }));
    }

    protected processGetNavigationsTreeSelect(response: HttpResponseBase): Observable<TreeSelectDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TreeSelectDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    itemById(id: number): Observable<NavigationDTO> {
        let url_ = this.baseUrl + "/api/auth/Navigation/ItemById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processItemById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processItemById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NavigationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NavigationDTO>;
        }));
    }

    protected processItemById(response: HttpResponseBase): Observable<NavigationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NavigationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUpdate(item: NavigationDTO): Observable<NavigationDTO> {
        let url_ = this.baseUrl + "/api/auth/Navigation/AddUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NavigationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NavigationDTO>;
        }));
    }

    protected processAddUpdate(response: HttpResponseBase): Observable<NavigationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NavigationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    upDownOrder(item: NavigationDTO, upDownOrder: UpDownOrder): Observable<boolean> {
        let url_ = this.baseUrl + "/api/auth/Navigation/UpDownOrder/{upDownOrder}";
        if (upDownOrder === undefined || upDownOrder === null)
            throw new Error("The parameter 'upDownOrder' must be defined.");
        url_ = url_.replace("{upDownOrder}", encodeURIComponent("" + upDownOrder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpDownOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpDownOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpDownOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOneIdClient {
    oneIdApi(code: string | null | undefined): Observable<FileResponse | null>;
    oneIdApiMobile(code: string | null | undefined): Observable<FileResponse | null>;
    passportFromPINFL(pinfl: string | null | undefined): Observable<GCPRequestApi>;
    checkUser(sess_id: string | null | undefined): Observable<boolean>;
    loginBySessId(sessId: string | null | undefined): Observable<TokenModel>;
}

@Injectable({
    providedIn: 'root'
})
export class OneIdClient implements IOneIdClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    oneIdApi(code: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/OneId/OneIdApi?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOneIdApi(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOneIdApi(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processOneIdApi(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    oneIdApiMobile(code: string | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/OneId/OneIdApiMobile?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOneIdApiMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOneIdApiMobile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processOneIdApiMobile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    passportFromPINFL(pinfl: string | null | undefined): Observable<GCPRequestApi> {
        let url_ = this.baseUrl + "/api/auth/OneId/PassportFromPINFL?";
        if (pinfl !== undefined && pinfl !== null)
            url_ += "pinfl=" + encodeURIComponent("" + pinfl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPassportFromPINFL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPassportFromPINFL(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GCPRequestApi>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GCPRequestApi>;
        }));
    }

    protected processPassportFromPINFL(response: HttpResponseBase): Observable<GCPRequestApi> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GCPRequestApi.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkUser(sess_id: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/auth/OneId/CheckUser?";
        if (sess_id !== undefined && sess_id !== null)
            url_ += "sess_id=" + encodeURIComponent("" + sess_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    loginBySessId(sessId: string | null | undefined): Observable<TokenModel> {
        let url_ = this.baseUrl + "/api/auth/OneId/LoginBySessId?";
        if (sessId !== undefined && sessId !== null)
            url_ += "sessId=" + encodeURIComponent("" + sessId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginBySessId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginBySessId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenModel>;
        }));
    }

    protected processLoginBySessId(response: HttpResponseBase): Observable<TokenModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISuperAdminClient {
    getAllOrganizators(metaData: TableMetaData): Observable<ResponseModelOfQueryResultOfSelectApplicationUser>;
    addMobileVersions(mobileVersion: MobileVersionDTO): Observable<ResponseModelOfBoolean>;
    updateStudent(pinfl: string | null): Observable<ResponseModelOfBoolean>;
    sendEmail(model: SendEmail): Observable<boolean>;
    emailResultsToAthletes(athletesIds: number[]): Observable<ResponseModelOfBoolean>;
    getOldMobileVersion(): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class SuperAdminClient implements ISuperAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllOrganizators(metaData: TableMetaData): Observable<ResponseModelOfQueryResultOfSelectApplicationUser> {
        let url_ = this.baseUrl + "/api/auth/SuperAdmin/GetAllOrganizators";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(metaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizators(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizators(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfSelectApplicationUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfSelectApplicationUser>;
        }));
    }

    protected processGetAllOrganizators(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfSelectApplicationUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfSelectApplicationUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addMobileVersions(mobileVersion: MobileVersionDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/SuperAdmin/AddMobileVersions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mobileVersion);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMobileVersions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMobileVersions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processAddMobileVersions(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateStudent(pinfl: string | null): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/SuperAdmin/UpdateStudent/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStudent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStudent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateStudent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendEmail(model: SendEmail): Observable<boolean> {
        let url_ = this.baseUrl + "/api/auth/SuperAdmin/SendEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSendEmail(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    emailResultsToAthletes(athletesIds: number[]): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/auth/SuperAdmin/EmailResultsToAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletesIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailResultsToAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailResultsToAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processEmailResultsToAthletes(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOldMobileVersion(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/auth/SuperAdmin/GetOldMobileVersion";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOldMobileVersion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOldMobileVersion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetOldMobileVersion(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ResponseModelOfInteger implements IResponseModelOfInteger {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: number;

    constructor(data?: IResponseModelOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ResponseModelOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result;
        return data;
    }
}

export interface IResponseModelOfInteger {
    statusCode: HttpStatusCode;
    error: string;
    result: number;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

export class TokenModel implements ITokenModel {
    token!: string;
    exp!: Date;
    refreshToken!: string;

    constructor(data?: ITokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.exp = _data["exp"] ? new Date(_data["exp"].toString()) : <any>undefined;
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): TokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["exp"] = this.exp ? this.exp.toISOString() : <any>undefined;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ITokenModel {
    token: string;
    exp: Date;
    refreshToken: string;
}

export class Login implements ILogin {
    userName!: string;
    password!: string;

    constructor(data?: ILogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Login {
        data = typeof data === 'object' ? data : {};
        let result = new Login();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILogin {
    userName: string;
    password: string;
}

export class ResponseModelOfBoolean implements IResponseModelOfBoolean {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: boolean;

    constructor(data?: IResponseModelOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ResponseModelOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result;
        return data;
    }
}

export interface IResponseModelOfBoolean {
    statusCode: HttpStatusCode;
    error: string;
    result: boolean;
}

export class SelectUser implements ISelectUser {
    email!: string;
    userName!: string;

    constructor(data?: ISelectUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): SelectUser {
        data = typeof data === 'object' ? data : {};
        let result = new SelectUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ISelectUser {
    email: string;
    userName: string;
}

export class ResponseModelOfTokenModel implements IResponseModelOfTokenModel {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: TokenModel;

    constructor(data?: IResponseModelOfTokenModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new TokenModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? TokenModel.fromJS(_data["result"]) : new TokenModel();
        }
    }

    static fromJS(data: any): ResponseModelOfTokenModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfTokenModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfTokenModel {
    statusCode: HttpStatusCode;
    error: string;
    result: TokenModel;
}

export class QueryResultOfUserLogDTO implements IQueryResultOfUserLogDTO {
    items!: UserLogDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfUserLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLogDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfUserLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfUserLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfUserLogDTO {
    items: UserLogDTO[];
    totalItems: number;
}

export class UserLogDTO implements IUserLogDTO {
    id!: number;
    applicationUserId!: string;
    applicationUserName!: string;
    applicationUserRole!: string;
    dateTime!: Date;
    ipAddress!: string;
    device!: string;
    actionInfo!: string;
    actionStatus!: ActionStatus;

    constructor(data?: IUserLogDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationUserId = _data["applicationUserId"];
            this.applicationUserName = _data["applicationUserName"];
            this.applicationUserRole = _data["applicationUserRole"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.ipAddress = _data["ipAddress"];
            this.device = _data["device"];
            this.actionInfo = _data["actionInfo"];
            this.actionStatus = _data["actionStatus"];
        }
    }

    static fromJS(data: any): UserLogDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationUserId"] = this.applicationUserId;
        data["applicationUserName"] = this.applicationUserName;
        data["applicationUserRole"] = this.applicationUserRole;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["ipAddress"] = this.ipAddress;
        data["device"] = this.device;
        data["actionInfo"] = this.actionInfo;
        data["actionStatus"] = this.actionStatus;
        return data;
    }
}

export interface IUserLogDTO {
    id: number;
    applicationUserId: string;
    applicationUserName: string;
    applicationUserRole: string;
    dateTime: Date;
    ipAddress: string;
    device: string;
    actionInfo: string;
    actionStatus: ActionStatus;
}

export enum ActionStatus {
    EnterSystem = 0,
    EventJoin = 2,
    EventExit = 3,
    EventCreate = 4,
    EventPaid = 5,
    EventEdit = 6,
    UserCreate = 8,
    UserEdit = 10,
    MediaCreate = 12,
    MediaEdit = 14,
    ResultCreate = 16,
    ResultPublish = 17,
    FeedbackNew = 20,
    AskRefund = 24,
    DoneRefund = 25,
}

export class TableMetaData implements ITableMetaData {
    filters?: string | undefined;
    first!: number;
    rows!: number;
    sortField?: string | undefined;
    sortOrder!: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;

    constructor(data?: ITableMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"];
            this.first = _data["first"];
            this.rows = _data["rows"];
            this.sortField = _data["sortField"];
            this.sortOrder = _data["sortOrder"];
            this.filterHandle = _data["filterHandle"];
            this.tagHandle = _data["tagHandle"];
            this.globalFilter = _data["globalFilter"];
        }
    }

    static fromJS(data: any): TableMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters;
        data["first"] = this.first;
        data["rows"] = this.rows;
        data["sortField"] = this.sortField;
        data["sortOrder"] = this.sortOrder;
        data["filterHandle"] = this.filterHandle;
        data["tagHandle"] = this.tagHandle;
        data["globalFilter"] = this.globalFilter;
        return data;
    }
}

export interface ITableMetaData {
    filters?: string | undefined;
    first: number;
    rows: number;
    sortField?: string | undefined;
    sortOrder: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;
}

export class Response implements IResponse {
    status!: Status;
    message!: string;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        return data;
    }
}

export interface IResponse {
    status: Status;
    message: string;
}

export enum Status {
    Success = 0,
    Error = 1,
}

export class ChangePassword extends Login implements IChangePassword {
    passwordOld!: string;

    constructor(data?: IChangePassword) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.passwordOld = _data["passwordOld"];
        }
    }

    static override fromJS(data: any): ChangePassword {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePassword();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passwordOld"] = this.passwordOld;
        super.toJSON(data);
        return data;
    }
}

export interface IChangePassword extends ILogin {
    passwordOld: string;
}

export class ResponseModelOfResetPassword implements IResponseModelOfResetPassword {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: ResetPassword;

    constructor(data?: IResponseModelOfResetPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new ResetPassword();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? ResetPassword.fromJS(_data["result"]) : new ResetPassword();
        }
    }

    static fromJS(data: any): ResponseModelOfResetPassword {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfResetPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfResetPassword {
    statusCode: HttpStatusCode;
    error: string;
    result: ResetPassword;
}

export class ResetPassword implements IResetPassword {
    userId!: string;
    newPassword!: string;
    token!: string;

    constructor(data?: IResetPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPassword {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        data["token"] = this.token;
        return data;
    }
}

export interface IResetPassword {
    userId: string;
    newPassword: string;
    token: string;
}

export class ResetPasswordWithEmail implements IResetPasswordWithEmail {
    userName!: string;
    email!: string;
    emailConfirmedCode!: string;

    constructor(data?: IResetPasswordWithEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.emailConfirmedCode = _data["emailConfirmedCode"];
        }
    }

    static fromJS(data: any): ResetPasswordWithEmail {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordWithEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["emailConfirmedCode"] = this.emailConfirmedCode;
        return data;
    }
}

export interface IResetPasswordWithEmail {
    userName: string;
    email: string;
    emailConfirmedCode: string;
}

export class UserRegistrDTO implements IUserRegistrDTO {
    id?: string | undefined;
    userName!: string;
    password!: string;
    fullName?: string | undefined;
    userApplicationStatus!: UserApplicationStatus;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    email!: string;
    mainRole?: string | undefined;
    roles?: string[] | undefined;
    rolesStr?: string | undefined;
    countEnter?: number | undefined;
    athletesId?: number | undefined;
    imageFileGuid?: string | undefined;
    applicationUserId?: string | undefined;
    spUserTypeId?: number | undefined;
    isForeign!: boolean;
    isPassportUzb!: boolean;
    pinfl?: string | undefined;
    passportSeria?: string | undefined;
    passportNumber?: string | undefined;
    passportGiven?: string | undefined;
    passportDateBegin?: string | undefined;
    passportDateEnd?: string | undefined;
    birthDate!: string;
    spNationId?: number | undefined;
    spCitizenshipId?: number | undefined;
    citizenship?: string | undefined;
    spCountryId?: number | undefined;
    spRegionId?: number | undefined;
    spDistrictId?: number | undefined;
    address?: string | undefined;
    spSexId?: number | undefined;
    addressBirth?: string | undefined;
    phoneMain!: string;
    phoneAdditional?: string | undefined;
    workPlaceCommit?: string | undefined;
    lockoutEnabled!: boolean;
    isFromGCP!: boolean;
    isChangePassword!: boolean;
    studentDTO?: StudentDTO | undefined;
    erPsportDTO?: ERPsportDTO | undefined;
    organization?: OrganizationDTO | undefined;

    constructor(data?: IUserRegistrDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.fullName = _data["fullName"];
            this.userApplicationStatus = _data["userApplicationStatus"];
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.patronymic = _data["patronymic"];
            this.email = _data["email"];
            this.mainRole = _data["mainRole"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.rolesStr = _data["rolesStr"];
            this.countEnter = _data["countEnter"];
            this.athletesId = _data["athletesId"];
            this.imageFileGuid = _data["imageFileGuid"];
            this.applicationUserId = _data["applicationUserId"];
            this.spUserTypeId = _data["spUserTypeId"];
            this.isForeign = _data["isForeign"];
            this.isPassportUzb = _data["isPassportUzb"];
            this.pinfl = _data["pinfl"];
            this.passportSeria = _data["passportSeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportGiven = _data["passportGiven"];
            this.passportDateBegin = _data["passportDateBegin"];
            this.passportDateEnd = _data["passportDateEnd"];
            this.birthDate = _data["birthDate"];
            this.spNationId = _data["spNationId"];
            this.spCitizenshipId = _data["spCitizenshipId"];
            this.citizenship = _data["citizenship"];
            this.spCountryId = _data["spCountryId"];
            this.spRegionId = _data["spRegionId"];
            this.spDistrictId = _data["spDistrictId"];
            this.address = _data["address"];
            this.spSexId = _data["spSexId"];
            this.addressBirth = _data["addressBirth"];
            this.phoneMain = _data["phoneMain"];
            this.phoneAdditional = _data["phoneAdditional"];
            this.workPlaceCommit = _data["workPlaceCommit"];
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.isFromGCP = _data["isFromGCP"];
            this.isChangePassword = _data["isChangePassword"];
            this.studentDTO = _data["studentDTO"] ? StudentDTO.fromJS(_data["studentDTO"]) : <any>undefined;
            this.erPsportDTO = _data["erPsportDTO"] ? ERPsportDTO.fromJS(_data["erPsportDTO"]) : <any>undefined;
            this.organization = _data["organization"] ? OrganizationDTO.fromJS(_data["organization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRegistrDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegistrDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["fullName"] = this.fullName;
        data["userApplicationStatus"] = this.userApplicationStatus;
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["patronymic"] = this.patronymic;
        data["email"] = this.email;
        data["mainRole"] = this.mainRole;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["rolesStr"] = this.rolesStr;
        data["countEnter"] = this.countEnter;
        data["athletesId"] = this.athletesId;
        data["imageFileGuid"] = this.imageFileGuid;
        data["applicationUserId"] = this.applicationUserId;
        data["spUserTypeId"] = this.spUserTypeId;
        data["isForeign"] = this.isForeign;
        data["isPassportUzb"] = this.isPassportUzb;
        data["pinfl"] = this.pinfl;
        data["passportSeria"] = this.passportSeria;
        data["passportNumber"] = this.passportNumber;
        data["passportGiven"] = this.passportGiven;
        data["passportDateBegin"] = this.passportDateBegin;
        data["passportDateEnd"] = this.passportDateEnd;
        data["birthDate"] = this.birthDate;
        data["spNationId"] = this.spNationId;
        data["spCitizenshipId"] = this.spCitizenshipId;
        data["citizenship"] = this.citizenship;
        data["spCountryId"] = this.spCountryId;
        data["spRegionId"] = this.spRegionId;
        data["spDistrictId"] = this.spDistrictId;
        data["address"] = this.address;
        data["spSexId"] = this.spSexId;
        data["addressBirth"] = this.addressBirth;
        data["phoneMain"] = this.phoneMain;
        data["phoneAdditional"] = this.phoneAdditional;
        data["workPlaceCommit"] = this.workPlaceCommit;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["isFromGCP"] = this.isFromGCP;
        data["isChangePassword"] = this.isChangePassword;
        data["studentDTO"] = this.studentDTO ? this.studentDTO.toJSON() : <any>undefined;
        data["erPsportDTO"] = this.erPsportDTO ? this.erPsportDTO.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserRegistrDTO {
    id?: string | undefined;
    userName: string;
    password: string;
    fullName?: string | undefined;
    userApplicationStatus: UserApplicationStatus;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    email: string;
    mainRole?: string | undefined;
    roles?: string[] | undefined;
    rolesStr?: string | undefined;
    countEnter?: number | undefined;
    athletesId?: number | undefined;
    imageFileGuid?: string | undefined;
    applicationUserId?: string | undefined;
    spUserTypeId?: number | undefined;
    isForeign: boolean;
    isPassportUzb: boolean;
    pinfl?: string | undefined;
    passportSeria?: string | undefined;
    passportNumber?: string | undefined;
    passportGiven?: string | undefined;
    passportDateBegin?: string | undefined;
    passportDateEnd?: string | undefined;
    birthDate: string;
    spNationId?: number | undefined;
    spCitizenshipId?: number | undefined;
    citizenship?: string | undefined;
    spCountryId?: number | undefined;
    spRegionId?: number | undefined;
    spDistrictId?: number | undefined;
    address?: string | undefined;
    spSexId?: number | undefined;
    addressBirth?: string | undefined;
    phoneMain: string;
    phoneAdditional?: string | undefined;
    workPlaceCommit?: string | undefined;
    lockoutEnabled: boolean;
    isFromGCP: boolean;
    isChangePassword: boolean;
    studentDTO?: StudentDTO | undefined;
    erPsportDTO?: ERPsportDTO | undefined;
    organization?: OrganizationDTO | undefined;
}

export enum UserApplicationStatus {
    Default = 0,
    RoleChange = 1,
}

export class StudentDTO implements IStudentDTO {
    hemisId?: number | undefined;
    cource?: string | undefined;
    universityName?: string | undefined;
    educationTypeName?: string | undefined;

    constructor(data?: IStudentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hemisId = _data["hemisId"];
            this.cource = _data["cource"];
            this.universityName = _data["universityName"];
            this.educationTypeName = _data["educationTypeName"];
        }
    }

    static fromJS(data: any): StudentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hemisId"] = this.hemisId;
        data["cource"] = this.cource;
        data["universityName"] = this.universityName;
        data["educationTypeName"] = this.educationTypeName;
        return data;
    }
}

export interface IStudentDTO {
    hemisId?: number | undefined;
    cource?: string | undefined;
    universityName?: string | undefined;
    educationTypeName?: string | undefined;
}

export class ERPsportDTO implements IERPsportDTO {
    sportTitleName?: string | undefined;
    sportTypeClassifiername?: string | undefined;

    constructor(data?: IERPsportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sportTitleName = _data["sportTitleName"];
            this.sportTypeClassifiername = _data["sportTypeClassifiername"];
        }
    }

    static fromJS(data: any): ERPsportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ERPsportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sportTitleName"] = this.sportTitleName;
        data["sportTypeClassifiername"] = this.sportTypeClassifiername;
        return data;
    }
}

export interface IERPsportDTO {
    sportTitleName?: string | undefined;
    sportTypeClassifiername?: string | undefined;
}

export class OrganizationDTO implements IOrganizationDTO {
    id!: number;
    name!: string;
    spOrganizationTypeId!: number;

    constructor(data?: IOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.spOrganizationTypeId = _data["spOrganizationTypeId"];
        }
    }

    static fromJS(data: any): OrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["spOrganizationTypeId"] = this.spOrganizationTypeId;
        return data;
    }
}

export interface IOrganizationDTO {
    id: number;
    name: string;
    spOrganizationTypeId: number;
}

export class ResponseModelOfUserRegistrDTO implements IResponseModelOfUserRegistrDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: UserRegistrDTO;

    constructor(data?: IResponseModelOfUserRegistrDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new UserRegistrDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? UserRegistrDTO.fromJS(_data["result"]) : new UserRegistrDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfUserRegistrDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfUserRegistrDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfUserRegistrDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: UserRegistrDTO;
}

export class MainRoleChoose implements IMainRoleChoose {
    userName!: string;
    mainRole!: string;

    constructor(data?: IMainRoleChoose) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.mainRole = _data["mainRole"];
        }
    }

    static fromJS(data: any): MainRoleChoose {
        data = typeof data === 'object' ? data : {};
        let result = new MainRoleChoose();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["mainRole"] = this.mainRole;
        return data;
    }
}

export interface IMainRoleChoose {
    userName: string;
    mainRole: string;
}

export class OrganizationModelDTO implements IOrganizationModelDTO {
    spUserTypeId!: number;
    name?: string | undefined;
    spOrganizationTypeId?: number | undefined;

    constructor(data?: IOrganizationModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.spUserTypeId = _data["spUserTypeId"];
            this.name = _data["name"];
            this.spOrganizationTypeId = _data["spOrganizationTypeId"];
        }
    }

    static fromJS(data: any): OrganizationModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["spUserTypeId"] = this.spUserTypeId;
        data["name"] = this.name;
        data["spOrganizationTypeId"] = this.spOrganizationTypeId;
        return data;
    }
}

export interface IOrganizationModelDTO {
    spUserTypeId: number;
    name?: string | undefined;
    spOrganizationTypeId?: number | undefined;
}

export class ResponseModelOfString implements IResponseModelOfString {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: string;

    constructor(data?: IResponseModelOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ResponseModelOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result;
        return data;
    }
}

export interface IResponseModelOfString {
    statusCode: HttpStatusCode;
    error: string;
    result: string;
}

export class EmailConfirmed implements IEmailConfirmed {
    id!: string;
    emailConfirmedCode!: string;

    constructor(data?: IEmailConfirmed) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.emailConfirmedCode = _data["emailConfirmedCode"];
        }
    }

    static fromJS(data: any): EmailConfirmed {
        data = typeof data === 'object' ? data : {};
        let result = new EmailConfirmed();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["emailConfirmedCode"] = this.emailConfirmedCode;
        return data;
    }
}

export interface IEmailConfirmed {
    id: string;
    emailConfirmedCode: string;
}

export class UserApplicationModel implements IUserApplicationModel {
    athletesId!: number;
    userId!: string;
    userName!: string;

    constructor(data?: IUserApplicationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.athletesId = _data["athletesId"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserApplicationModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserApplicationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["athletesId"] = this.athletesId;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IUserApplicationModel {
    athletesId: number;
    userId: string;
    userName: string;
}

export class UserProfile implements IUserProfile {
    id!: string;
    userId!: string;
    userName!: string;
    password!: string;
    fio!: string;
    surname!: string;
    name!: string;
    patronymic!: string;
    email!: string;
    mainRole!: string;
    roles!: string[];
    rolesStr!: string;
    dateLastEnter!: string;
    userAdd!: string;
    countEnter!: string;
    dateLastActive!: string;
    athletesId!: number;
    spInstitutionId!: number;
    spDepartmentId?: number | undefined;
    spInstitutionName!: string;
    hospitalInn?: number | undefined;
    mainPositionId?: number | undefined;
    specId?: number | undefined;
    imageFileGuid?: string | undefined;
    applicationUserId?: string | undefined;
    spUserTypeId?: number | undefined;
    isForeign!: boolean;
    isPassportUzb!: boolean;

    constructor(data?: IUserProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.fio = _data["fio"];
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.patronymic = _data["patronymic"];
            this.email = _data["email"];
            this.mainRole = _data["mainRole"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.rolesStr = _data["rolesStr"];
            this.dateLastEnter = _data["dateLastEnter"];
            this.userAdd = _data["userAdd"];
            this.countEnter = _data["countEnter"];
            this.dateLastActive = _data["dateLastActive"];
            this.athletesId = _data["athletesId"];
            this.spInstitutionId = _data["spInstitutionId"];
            this.spDepartmentId = _data["spDepartmentId"];
            this.spInstitutionName = _data["spInstitutionName"];
            this.hospitalInn = _data["hospitalInn"];
            this.mainPositionId = _data["mainPositionId"];
            this.specId = _data["specId"];
            this.imageFileGuid = _data["imageFileGuid"];
            this.applicationUserId = _data["applicationUserId"];
            this.spUserTypeId = _data["spUserTypeId"];
            this.isForeign = _data["isForeign"];
            this.isPassportUzb = _data["isPassportUzb"];
        }
    }

    static fromJS(data: any): UserProfile {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["fio"] = this.fio;
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["patronymic"] = this.patronymic;
        data["email"] = this.email;
        data["mainRole"] = this.mainRole;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["rolesStr"] = this.rolesStr;
        data["dateLastEnter"] = this.dateLastEnter;
        data["userAdd"] = this.userAdd;
        data["countEnter"] = this.countEnter;
        data["dateLastActive"] = this.dateLastActive;
        data["athletesId"] = this.athletesId;
        data["spInstitutionId"] = this.spInstitutionId;
        data["spDepartmentId"] = this.spDepartmentId;
        data["spInstitutionName"] = this.spInstitutionName;
        data["hospitalInn"] = this.hospitalInn;
        data["mainPositionId"] = this.mainPositionId;
        data["specId"] = this.specId;
        data["imageFileGuid"] = this.imageFileGuid;
        data["applicationUserId"] = this.applicationUserId;
        data["spUserTypeId"] = this.spUserTypeId;
        data["isForeign"] = this.isForeign;
        data["isPassportUzb"] = this.isPassportUzb;
        return data;
    }
}

export interface IUserProfile {
    id: string;
    userId: string;
    userName: string;
    password: string;
    fio: string;
    surname: string;
    name: string;
    patronymic: string;
    email: string;
    mainRole: string;
    roles: string[];
    rolesStr: string;
    dateLastEnter: string;
    userAdd: string;
    countEnter: string;
    dateLastActive: string;
    athletesId: number;
    spInstitutionId: number;
    spDepartmentId?: number | undefined;
    spInstitutionName: string;
    hospitalInn?: number | undefined;
    mainPositionId?: number | undefined;
    specId?: number | undefined;
    imageFileGuid?: string | undefined;
    applicationUserId?: string | undefined;
    spUserTypeId?: number | undefined;
    isForeign: boolean;
    isPassportUzb: boolean;
}

export class SelectItem implements ISelectItem {
    label!: string;
    value!: string;
    dataInt?: number | undefined;
    code?: string | undefined;
    rootCode?: string | undefined;
    dataStr?: string | undefined;
    dataStr2?: string | undefined;
    dateTime?: string | undefined;

    constructor(data?: ISelectItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
            this.dataInt = _data["dataInt"];
            this.code = _data["code"];
            this.rootCode = _data["rootCode"];
            this.dataStr = _data["dataStr"];
            this.dataStr2 = _data["dataStr2"];
            this.dateTime = _data["dateTime"];
        }
    }

    static fromJS(data: any): SelectItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        data["dataInt"] = this.dataInt;
        data["code"] = this.code;
        data["rootCode"] = this.rootCode;
        data["dataStr"] = this.dataStr;
        data["dataStr2"] = this.dataStr2;
        data["dateTime"] = this.dateTime;
        return data;
    }
}

export interface ISelectItem {
    label: string;
    value: string;
    dataInt?: number | undefined;
    code?: string | undefined;
    rootCode?: string | undefined;
    dataStr?: string | undefined;
    dataStr2?: string | undefined;
    dateTime?: string | undefined;
}

export class QueryResultOfUserRegistrDTO implements IQueryResultOfUserRegistrDTO {
    items!: UserRegistrDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfUserRegistrDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRegistrDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfUserRegistrDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfUserRegistrDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfUserRegistrDTO {
    items: UserRegistrDTO[];
    totalItems: number;
}

export class ResponseClassOfString extends Response implements IResponseClassOfString {
    result?: string | undefined;

    constructor(data?: IResponseClassOfString) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"];
        }
    }

    static override fromJS(data: any): ResponseClassOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseClassOfString();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        super.toJSON(data);
        return data;
    }
}

export interface IResponseClassOfString extends IResponse {
    result?: string | undefined;
}

export class ApplicationUserDTO implements IApplicationUserDTO {
    id?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    staffId?: number | undefined;
    isChangePassword!: boolean;
    createdByType!: CreatedByType;
    roles!: string[];

    constructor(data?: IApplicationUserDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.staffId = _data["staffId"];
            this.isChangePassword = _data["isChangePassword"];
            this.createdByType = _data["createdByType"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationUserDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["staffId"] = this.staffId;
        data["isChangePassword"] = this.isChangePassword;
        data["createdByType"] = this.createdByType;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IApplicationUserDTO {
    id?: string | undefined;
    userName?: string | undefined;
    password?: string | undefined;
    staffId?: number | undefined;
    isChangePassword: boolean;
    createdByType: CreatedByType;
    roles: string[];
}

export enum CreatedByType {
    Admin = 0,
    OneID = 5,
    SelfRegistration = 10,
    PhoneOneID = 15,
    PnoneSelfRegistration = 20,
}

export class UpdateUserModel implements IUpdateUserModel {
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IUpdateUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): UpdateUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IUpdateUserModel {
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class NavigationDTO implements INavigationDTO {
    id!: string;
    key!: string[];
    idDB!: number;
    title!: string;
    type!: string;
    icon!: string;
    link!: string;
    children!: NavigationDTO[];
    rootId?: number | undefined;
    active!: boolean;

    constructor(data?: INavigationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.key = [];
            this.children = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["key"])) {
                this.key = [] as any;
                for (let item of _data["key"])
                    this.key!.push(item);
            }
            this.idDB = _data["idDB"];
            this.title = _data["title"];
            this.type = _data["type"];
            this.icon = _data["icon"];
            this.link = _data["link"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(NavigationDTO.fromJS(item));
            }
            this.rootId = _data["rootId"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): NavigationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NavigationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.key)) {
            data["key"] = [];
            for (let item of this.key)
                data["key"].push(item);
        }
        data["idDB"] = this.idDB;
        data["title"] = this.title;
        data["type"] = this.type;
        data["icon"] = this.icon;
        data["link"] = this.link;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["rootId"] = this.rootId;
        data["active"] = this.active;
        return data;
    }
}

export interface INavigationDTO {
    id: string;
    key: string[];
    idDB: number;
    title: string;
    type: string;
    icon: string;
    link: string;
    children: NavigationDTO[];
    rootId?: number | undefined;
    active: boolean;
}

export class TreeTableDTO implements ITreeTableDTO {
    data!: NavigationDTO;
    children?: TreeTableDTO[] | undefined;

    constructor(data?: ITreeTableDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = new NavigationDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? NavigationDTO.fromJS(_data["data"]) : new NavigationDTO();
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeTableDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeTableDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TreeTableDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITreeTableDTO {
    data: NavigationDTO;
    children?: TreeTableDTO[] | undefined;
}

export class TreeSelectDTO implements ITreeSelectDTO {
    key!: number;
    label!: string;
    data!: string;
    icon!: string;
    children!: TreeSelectDTO[];

    constructor(data?: ITreeSelectDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.children = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.label = _data["label"];
            this.data = _data["data"];
            this.icon = _data["icon"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(TreeSelectDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TreeSelectDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TreeSelectDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["label"] = this.label;
        data["data"] = this.data;
        data["icon"] = this.icon;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITreeSelectDTO {
    key: number;
    label: string;
    data: string;
    icon: string;
    children: TreeSelectDTO[];
}

export enum UpDownOrder {
    Up = 0,
    Down = 1,
}

export class GCPRequestApi implements IGCPRequestApi {
    birthDate!: string;
    pspSerial!: string;
    pspNumber!: string;
    cadastrGUID!: string;
    cadastrPINPP!: string;

    constructor(data?: IGCPRequestApi) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthDate = _data["birthDate"];
            this.pspSerial = _data["pspSerial"];
            this.pspNumber = _data["pspNumber"];
            this.cadastrGUID = _data["cadastrGUID"];
            this.cadastrPINPP = _data["cadastrPINPP"];
        }
    }

    static fromJS(data: any): GCPRequestApi {
        data = typeof data === 'object' ? data : {};
        let result = new GCPRequestApi();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate;
        data["pspSerial"] = this.pspSerial;
        data["pspNumber"] = this.pspNumber;
        data["cadastrGUID"] = this.cadastrGUID;
        data["cadastrPINPP"] = this.cadastrPINPP;
        return data;
    }
}

export interface IGCPRequestApi {
    birthDate: string;
    pspSerial: string;
    pspNumber: string;
    cadastrGUID: string;
    cadastrPINPP: string;
}

export class ResponseModelOfQueryResultOfSelectApplicationUser implements IResponseModelOfQueryResultOfSelectApplicationUser {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfSelectApplicationUser;

    constructor(data?: IResponseModelOfQueryResultOfSelectApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfSelectApplicationUser();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfSelectApplicationUser.fromJS(_data["result"]) : new QueryResultOfSelectApplicationUser();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfSelectApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfSelectApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfSelectApplicationUser {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfSelectApplicationUser;
}

export class QueryResultOfSelectApplicationUser implements IQueryResultOfSelectApplicationUser {
    items!: SelectApplicationUser[];
    totalItems!: number;

    constructor(data?: IQueryResultOfSelectApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectApplicationUser.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfSelectApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfSelectApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfSelectApplicationUser {
    items: SelectApplicationUser[];
    totalItems: number;
}

export class SelectApplicationUser implements ISelectApplicationUser {
    id!: string;
    userName!: string;
    athletesId!: number;
    fullName!: string;
    phone?: string | undefined;
    email!: string;
    organizationName!: string;
    organizationType!: string;
    applicationInfo?: string | undefined;
    userApplicationStatus!: UserApplicationStatus;
    numberOfEntries!: number;
    countUsers!: number;

    constructor(data?: ISelectApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.athletesId = _data["athletesId"];
            this.fullName = _data["fullName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.organizationName = _data["organizationName"];
            this.organizationType = _data["organizationType"];
            this.applicationInfo = _data["applicationInfo"];
            this.userApplicationStatus = _data["userApplicationStatus"];
            this.numberOfEntries = _data["numberOfEntries"];
            this.countUsers = _data["countUsers"];
        }
    }

    static fromJS(data: any): SelectApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new SelectApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["athletesId"] = this.athletesId;
        data["fullName"] = this.fullName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["organizationName"] = this.organizationName;
        data["organizationType"] = this.organizationType;
        data["applicationInfo"] = this.applicationInfo;
        data["userApplicationStatus"] = this.userApplicationStatus;
        data["numberOfEntries"] = this.numberOfEntries;
        data["countUsers"] = this.countUsers;
        return data;
    }
}

export interface ISelectApplicationUser {
    id: string;
    userName: string;
    athletesId: number;
    fullName: string;
    phone?: string | undefined;
    email: string;
    organizationName: string;
    organizationType: string;
    applicationInfo?: string | undefined;
    userApplicationStatus: UserApplicationStatus;
    numberOfEntries: number;
    countUsers: number;
}

export class MobileVersionDTO implements IMobileVersionDTO {
    android!: string;
    ios!: string;

    constructor(data?: IMobileVersionDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.android = _data["android"];
            this.ios = _data["ios"];
        }
    }

    static fromJS(data: any): MobileVersionDTO {
        data = typeof data === 'object' ? data : {};
        let result = new MobileVersionDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["android"] = this.android;
        data["ios"] = this.ios;
        return data;
    }
}

export interface IMobileVersionDTO {
    android: string;
    ios: string;
}

export class SendEmail implements ISendEmail {
    emailTo?: string | undefined;
    subject!: string;
    message!: string;
    athletesIds?: number[] | undefined;

    constructor(data?: ISendEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTo = _data["emailTo"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            if (Array.isArray(_data["athletesIds"])) {
                this.athletesIds = [] as any;
                for (let item of _data["athletesIds"])
                    this.athletesIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmail {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTo"] = this.emailTo;
        data["subject"] = this.subject;
        data["message"] = this.message;
        if (Array.isArray(this.athletesIds)) {
            data["athletesIds"] = [];
            for (let item of this.athletesIds)
                data["athletesIds"].push(item);
        }
        return data;
    }
}

export interface ISendEmail {
    emailTo?: string | undefined;
    subject: string;
    message: string;
    athletesIds?: number[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}