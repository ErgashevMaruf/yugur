//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAdvertisingClient {
    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAdvertisingDTO>;
    listActive(): Observable<ResponseModelOfQueryResultOfAdvertisingDTO>;
    advertisingById(id: number): Observable<ResponseModelOfAdvertisingDTO>;
    delete(id: number): Observable<ResponseModelOfBoolean>;
    save(item: AdvertisingDTO): Observable<ResponseModelOfAdvertisingDTO>;
    update(item: AdvertisingDTO): Observable<ResponseModelOfAdvertisingDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class AdvertisingClient implements IAdvertisingClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAdvertisingDTO> {
        let url_ = this.baseUrl + "/api/marathon/Advertising/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfAdvertisingDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfAdvertisingDTO>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfAdvertisingDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfAdvertisingDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listActive(): Observable<ResponseModelOfQueryResultOfAdvertisingDTO> {
        let url_ = this.baseUrl + "/api/marathon/Advertising/ListActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfAdvertisingDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfAdvertisingDTO>;
        }));
    }

    protected processListActive(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfAdvertisingDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfAdvertisingDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    advertisingById(id: number): Observable<ResponseModelOfAdvertisingDTO> {
        let url_ = this.baseUrl + "/api/marathon/Advertising/AdvertisingById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdvertisingById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdvertisingById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAdvertisingDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAdvertisingDTO>;
        }));
    }

    protected processAdvertisingById(response: HttpResponseBase): Observable<ResponseModelOfAdvertisingDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAdvertisingDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Advertising/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    save(item: AdvertisingDTO): Observable<ResponseModelOfAdvertisingDTO> {
        let url_ = this.baseUrl + "/api/marathon/Advertising/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAdvertisingDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAdvertisingDTO>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ResponseModelOfAdvertisingDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAdvertisingDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(item: AdvertisingDTO): Observable<ResponseModelOfAdvertisingDTO> {
        let url_ = this.baseUrl + "/api/marathon/Advertising/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAdvertisingDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAdvertisingDTO>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModelOfAdvertisingDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAdvertisingDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IApplicationRepaymentClient {
    saveApplicationRepayment(applicationRepayment: ApplicationRepaymentDTO): Observable<ResponseModelOfBoolean>;
    getAll(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfApplicationRepaymentDTO>;
    accept(applicationAnswer: ApplicationAnswer): Observable<ResponseModelOfBoolean>;
    reject(applicationAnswer: ApplicationAnswer): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ApplicationRepaymentClient implements IApplicationRepaymentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveApplicationRepayment(applicationRepayment: ApplicationRepaymentDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/ApplicationRepayment/SaveApplicationRepayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationRepayment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveApplicationRepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveApplicationRepayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveApplicationRepayment(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfApplicationRepaymentDTO> {
        let url_ = this.baseUrl + "/api/marathon/ApplicationRepayment/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfApplicationRepaymentDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfApplicationRepaymentDTO>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfApplicationRepaymentDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfApplicationRepaymentDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accept(applicationAnswer: ApplicationAnswer): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/ApplicationRepayment/Accept";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationAnswer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccept(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccept(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processAccept(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reject(applicationAnswer: ApplicationAnswer): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/ApplicationRepayment/Reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationAnswer);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processReject(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAthletesClubClient {
    joinClubAthletes(clubId: number): Observable<ResponseModelOfAthletesClubDTO>;
    leftClubAthletes(clubId: number): Observable<ResponseModelOfBoolean>;
    existAhtletesInClub(): Observable<ResponseModelOfAthletesClubDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class AthletesClubClient implements IAthletesClubClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    joinClubAthletes(clubId: number): Observable<ResponseModelOfAthletesClubDTO> {
        let url_ = this.baseUrl + "/api/marathon/AthletesClub/JoinClubAthletes/{clubId}";
        if (clubId === undefined || clubId === null)
            throw new Error("The parameter 'clubId' must be defined.");
        url_ = url_.replace("{clubId}", encodeURIComponent("" + clubId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinClubAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinClubAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAthletesClubDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAthletesClubDTO>;
        }));
    }

    protected processJoinClubAthletes(response: HttpResponseBase): Observable<ResponseModelOfAthletesClubDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAthletesClubDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    leftClubAthletes(clubId: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/AthletesClub/LeftClubAthletes/{clubId}";
        if (clubId === undefined || clubId === null)
            throw new Error("The parameter 'clubId' must be defined.");
        url_ = url_.replace("{clubId}", encodeURIComponent("" + clubId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLeftClubAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLeftClubAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processLeftClubAthletes(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    existAhtletesInClub(): Observable<ResponseModelOfAthletesClubDTO> {
        let url_ = this.baseUrl + "/api/marathon/AthletesClub/ExistAhtletesInClub";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExistAhtletesInClub(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExistAhtletesInClub(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAthletesClubDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAthletesClubDTO>;
        }));
    }

    protected processExistAhtletesInClub(response: HttpResponseBase): Observable<ResponseModelOfAthletesClubDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAthletesClubDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAthletesClient {
    getAllAthletes(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAthletesDTO>;
    getAthletesByIds(athletesIds: number[]): Observable<AthletesDTO[]>;
    getSelectAthletesByIds(athletesIds: number[]): Observable<SelectAthlete[]>;
    getAthletesById(id: number): Observable<AthletesDTO>;
    getAthleteInfo(): Observable<AthletesDTO>;
    getAthletesIdByPinfl(pinfl: string | null): Observable<number | null>;
    getByIdOrganization(athletesId: number): Observable<OrganizationDTO>;
    onSave(athletes: AthletesDTO): Observable<ResponseModelOfBoolean>;
    onUpdate(athletes: AthletesDTO): Observable<ResponseModelOfBoolean>;
    onDelete(athletesId: number): Observable<ResponseModelOfBoolean>;
    isExistAthleteOrganization(athletesId: number): Observable<boolean>;
    createExcelTemplate(excelTemplate: ExcelTemplateDTO): Observable<FileResponse | null>;
    uploadExcelFromAthletes(athletesList: AthletesDTO[]): Observable<ResponseModelOfInteger>;
    exportExcelTemplatesForAthletes(): Observable<FileResponse | null>;
    exportExcelAthletes(organizationId: number | null | undefined): Observable<FileResponse | null>;
    updateAthletes(athletes: AthletesDTO): Observable<boolean>;
    updateAthletesByUser(athletes: UpdateUserModel): Observable<boolean>;
    updateAthleteWorkPlace(commet: string | null): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class AthletesClient implements IAthletesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllAthletes(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAthletesDTO> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetAllAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfAthletesDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfAthletesDTO>;
        }));
    }

    protected processGetAllAthletes(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfAthletesDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfAthletesDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthletesByIds(athletesIds: number[]): Observable<AthletesDTO[]> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetAthletesByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletesIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthletesByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthletesByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AthletesDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AthletesDTO[]>;
        }));
    }

    protected processGetAthletesByIds(response: HttpResponseBase): Observable<AthletesDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AthletesDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSelectAthletesByIds(athletesIds: number[]): Observable<SelectAthlete[]> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetSelectAthletesByIds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletesIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectAthletesByIds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectAthletesByIds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectAthlete[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectAthlete[]>;
        }));
    }

    protected processGetSelectAthletesByIds(response: HttpResponseBase): Observable<SelectAthlete[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectAthlete.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthletesById(id: number): Observable<AthletesDTO> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetAthletesById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthletesById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthletesById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AthletesDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AthletesDTO>;
        }));
    }

    protected processGetAthletesById(response: HttpResponseBase): Observable<AthletesDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AthletesDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthleteInfo(): Observable<AthletesDTO> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetAthleteInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthleteInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthleteInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AthletesDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AthletesDTO>;
        }));
    }

    protected processGetAthleteInfo(response: HttpResponseBase): Observable<AthletesDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AthletesDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthletesIdByPinfl(pinfl: string | null): Observable<number | null> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetAthletesIdByPinfl/{pinfl}";
        if (pinfl === undefined || pinfl === null)
            throw new Error("The parameter 'pinfl' must be defined.");
        url_ = url_.replace("{pinfl}", encodeURIComponent("" + pinfl));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthletesIdByPinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthletesIdByPinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number | null>;
        }));
    }

    protected processGetAthletesIdByPinfl(response: HttpResponseBase): Observable<number | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdOrganization(athletesId: number): Observable<OrganizationDTO> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/GetByIdOrganization/{athletesId}";
        if (athletesId === undefined || athletesId === null)
            throw new Error("The parameter 'athletesId' must be defined.");
        url_ = url_.replace("{athletesId}", encodeURIComponent("" + athletesId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationDTO>;
        }));
    }

    protected processGetByIdOrganization(response: HttpResponseBase): Observable<OrganizationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    onSave(athletes: AthletesDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/OnSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processOnSave(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    onUpdate(athletes: AthletesDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/OnUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processOnUpdate(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    onDelete(athletesId: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/OnDelete/{athletesId}";
        if (athletesId === undefined || athletesId === null)
            throw new Error("The parameter 'athletesId' must be defined.");
        url_ = url_.replace("{athletesId}", encodeURIComponent("" + athletesId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processOnDelete(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isExistAthleteOrganization(athletesId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/IsExistAthleteOrganization/{athletesId}";
        if (athletesId === undefined || athletesId === null)
            throw new Error("The parameter 'athletesId' must be defined.");
        url_ = url_.replace("{athletesId}", encodeURIComponent("" + athletesId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsExistAthleteOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsExistAthleteOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsExistAthleteOrganization(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createExcelTemplate(excelTemplate: ExcelTemplateDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/CreateExcelTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(excelTemplate);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateExcelTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateExcelTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processCreateExcelTemplate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadExcelFromAthletes(athletesList: AthletesDTO[]): Observable<ResponseModelOfInteger> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/UploadExcelFromAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletesList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadExcelFromAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadExcelFromAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfInteger>;
        }));
    }

    protected processUploadExcelFromAthletes(response: HttpResponseBase): Observable<ResponseModelOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelTemplatesForAthletes(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/ExportExcelTemplatesForAthletes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelTemplatesForAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelTemplatesForAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportExcelTemplatesForAthletes(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelAthletes(organizationId: number | null | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/ExportExcelAthletes?";
        if (organizationId !== undefined && organizationId !== null)
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportExcelAthletes(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAthletes(athletes: AthletesDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/UpdateAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateAthletes(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAthletesByUser(athletes: UpdateUserModel): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/UpdateAthletesByUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAthletesByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAthletesByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateAthletesByUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAthleteWorkPlace(commet: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Athletes/UpdateAthleteWorkPlace/{commet}";
        if (commet === undefined || commet === null)
            throw new Error("The parameter 'commet' must be defined.");
        url_ = url_.replace("{commet}", encodeURIComponent("" + commet));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAthleteWorkPlace(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAthleteWorkPlace(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processUpdateAthleteWorkPlace(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IClubClient {
    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfClubDTO>;
    clubById(id: number): Observable<ResponseModelOfClubDTO>;
    delete(id: number): Observable<ResponseModelOfBoolean>;
    save(item: ClubDTO): Observable<ResponseModelOfClubDTO>;
    update(item: ClubDTO): Observable<ResponseModelOfClubDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class ClubClient implements IClubClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfClubDTO> {
        let url_ = this.baseUrl + "/api/marathon/Club/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfClubDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfClubDTO>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfClubDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfClubDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clubById(id: number): Observable<ResponseModelOfClubDTO> {
        let url_ = this.baseUrl + "/api/marathon/Club/ClubById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClubById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClubById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfClubDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfClubDTO>;
        }));
    }

    protected processClubById(response: HttpResponseBase): Observable<ResponseModelOfClubDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfClubDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Club/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    save(item: ClubDTO): Observable<ResponseModelOfClubDTO> {
        let url_ = this.baseUrl + "/api/marathon/Club/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfClubDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfClubDTO>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ResponseModelOfClubDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfClubDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(item: ClubDTO): Observable<ResponseModelOfClubDTO> {
        let url_ = this.baseUrl + "/api/marathon/Club/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfClubDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfClubDTO>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModelOfClubDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfClubDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEventClient {
    saveEventBox(model: EventBoxDTO): Observable<ResponseModelOfBoolean>;
    updateEventBox(model: EventBoxDTO): Observable<ResponseModelOfBoolean>;
    eventBoxById(id: number): Observable<ResponseModelOfEventBoxDTO>;
    eventBoxesList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
    getAllEventBoxMini(eventStatus: EventStatus | null | undefined): Observable<ResponseModelOfListOfEventBoxMiniDTO>;
    myEventBoxList(): Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
    getActiveEventBoxesByAthletes(athletesId: number | undefined): Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
    allActiveEventEventBoxesList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
    getAllActiveEvents(tableMeta: TableMetaData): Observable<SelectEventBoxDTO[]>;
    allEventBoxesList(tableMeta: TableMetaData, isFinish: boolean | undefined): Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
    allResultEventList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfSelectEvent>;
    getDistinctRaceDistances(): Observable<ResponseModelOfListOfString>;
    eventByIdEdit(id: number): Observable<ResponseModelOfEventDTO>;
    addEvent(model: EventDTO): Observable<ResponseModelOfBoolean>;
    updateEvent(model: EventDTO): Observable<ResponseModelOfBoolean>;
    deleteEvent(id: number): Observable<ResponseModelOfBoolean>;
    allActiveEventBoxesList(): Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
    activeEventByboxIdList(eventboxId: number): Observable<ResponseModelOfQueryResultOfEventDTO>;
    getByEventBoxIdEventsList(eventBoxId: number): Observable<ResponseModelOfQueryResultOfEventDTO>;
    getNoteFirstEventByUser(): Observable<ResponseModelOfEventBoxDTO>;
    getNoteFirstEvents(): Observable<ResponseModelOfEventBoxDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class EventClient implements IEventClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    saveEventBox(model: EventBoxDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Event/SaveEventBox";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEventBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEventBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveEventBox(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateEventBox(model: EventBoxDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Event/UpdateEventBox";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEventBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEventBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateEventBox(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventBoxById(id: number): Observable<ResponseModelOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/EventBoxById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventBoxById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventBoxById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfEventBoxDTO>;
        }));
    }

    protected processEventBoxById(response: HttpResponseBase): Observable<ResponseModelOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventBoxesList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/EventBoxesList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventBoxesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventBoxesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
        }));
    }

    protected processEventBoxesList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllEventBoxMini(eventStatus: EventStatus | null | undefined): Observable<ResponseModelOfListOfEventBoxMiniDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetAllEventBoxMini?";
        if (eventStatus !== undefined && eventStatus !== null)
            url_ += "eventStatus=" + encodeURIComponent("" + eventStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEventBoxMini(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEventBoxMini(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfEventBoxMiniDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfEventBoxMiniDTO>;
        }));
    }

    protected processGetAllEventBoxMini(response: HttpResponseBase): Observable<ResponseModelOfListOfEventBoxMiniDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfEventBoxMiniDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    myEventBoxList(): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/MyEventBoxList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyEventBoxList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyEventBoxList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
        }));
    }

    protected processMyEventBoxList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveEventBoxesByAthletes(athletesId: number | undefined): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetActiveEventBoxesByAthletes?";
        if (athletesId === null)
            throw new Error("The parameter 'athletesId' cannot be null.");
        else if (athletesId !== undefined)
            url_ += "athletesId=" + encodeURIComponent("" + athletesId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveEventBoxesByAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveEventBoxesByAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
        }));
    }

    protected processGetActiveEventBoxesByAthletes(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allActiveEventEventBoxesList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/AllActiveEventEventBoxesList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllActiveEventEventBoxesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllActiveEventEventBoxesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
        }));
    }

    protected processAllActiveEventEventBoxesList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllActiveEvents(tableMeta: TableMetaData): Observable<SelectEventBoxDTO[]> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetAllActiveEvents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllActiveEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllActiveEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectEventBoxDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectEventBoxDTO[]>;
        }));
    }

    protected processGetAllActiveEvents(response: HttpResponseBase): Observable<SelectEventBoxDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectEventBoxDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allEventBoxesList(tableMeta: TableMetaData, isFinish: boolean | undefined): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/AllEventBoxesList?";
        if (isFinish === null)
            throw new Error("The parameter 'isFinish' cannot be null.");
        else if (isFinish !== undefined)
            url_ += "isFinish=" + encodeURIComponent("" + isFinish) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllEventBoxesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllEventBoxesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
        }));
    }

    protected processAllEventBoxesList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allResultEventList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfSelectEvent> {
        let url_ = this.baseUrl + "/api/marathon/Event/AllResultEventList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllResultEventList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllResultEventList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfSelectEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfSelectEvent>;
        }));
    }

    protected processAllResultEventList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfSelectEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfSelectEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDistinctRaceDistances(): Observable<ResponseModelOfListOfString> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetDistinctRaceDistances";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDistinctRaceDistances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDistinctRaceDistances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfString>;
        }));
    }

    protected processGetDistinctRaceDistances(response: HttpResponseBase): Observable<ResponseModelOfListOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventByIdEdit(id: number): Observable<ResponseModelOfEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/EventByIdEdit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventByIdEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventByIdEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfEventDTO>;
        }));
    }

    protected processEventByIdEdit(response: HttpResponseBase): Observable<ResponseModelOfEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addEvent(model: EventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Event/AddEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processAddEvent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateEvent(model: EventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Event/UpdateEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateEvent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteEvent(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Event/DeleteEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteEvent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allActiveEventBoxesList(): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/AllActiveEventBoxesList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllActiveEventBoxesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllActiveEventBoxesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventBoxDTO>;
        }));
    }

    protected processAllActiveEventBoxesList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activeEventByboxIdList(eventboxId: number): Observable<ResponseModelOfQueryResultOfEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/ActiveEventByboxIdList/{eventboxId}";
        if (eventboxId === undefined || eventboxId === null)
            throw new Error("The parameter 'eventboxId' must be defined.");
        url_ = url_.replace("{eventboxId}", encodeURIComponent("" + eventboxId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActiveEventByboxIdList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActiveEventByboxIdList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventDTO>;
        }));
    }

    protected processActiveEventByboxIdList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByEventBoxIdEventsList(eventBoxId: number): Observable<ResponseModelOfQueryResultOfEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetByEventBoxIdEventsList/{eventBoxId}";
        if (eventBoxId === undefined || eventBoxId === null)
            throw new Error("The parameter 'eventBoxId' must be defined.");
        url_ = url_.replace("{eventBoxId}", encodeURIComponent("" + eventBoxId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByEventBoxIdEventsList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByEventBoxIdEventsList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfEventDTO>;
        }));
    }

    protected processGetByEventBoxIdEventsList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNoteFirstEventByUser(): Observable<ResponseModelOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetNoteFirstEventByUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoteFirstEventByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoteFirstEventByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfEventBoxDTO>;
        }));
    }

    protected processGetNoteFirstEventByUser(response: HttpResponseBase): Observable<ResponseModelOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getNoteFirstEvents(): Observable<ResponseModelOfEventBoxDTO> {
        let url_ = this.baseUrl + "/api/marathon/Event/GetNoteFirstEvents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNoteFirstEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNoteFirstEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfEventBoxDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfEventBoxDTO>;
        }));
    }

    protected processGetNoteFirstEvents(response: HttpResponseBase): Observable<ResponseModelOfEventBoxDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfEventBoxDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFaceIDClient {
    sendEnrolleesNewOnly(sessionNumber: number, eventId: number | undefined): Observable<number>;
    getAthletesPhotofromGcP(): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class FaceIDClient implements IFaceIDClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    sendEnrolleesNewOnly(sessionNumber: number, eventId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/marathon/FaceID/SendEnrolleesNewOnly/{sessionNumber}?";
        if (sessionNumber === undefined || sessionNumber === null)
            throw new Error("The parameter 'sessionNumber' must be defined.");
        url_ = url_.replace("{sessionNumber}", encodeURIComponent("" + sessionNumber));
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEnrolleesNewOnly(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEnrolleesNewOnly(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSendEnrolleesNewOnly(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthletesPhotofromGcP(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/FaceID/GetAthletesPhotofromGcP";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthletesPhotofromGcP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthletesPhotofromGcP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetAthletesPhotofromGcP(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFaceIDMobileClient {
    getPhotoById(id: number): Observable<ResponseModelOfAthletesInfoDTO>;
    athletePhotoSaveInBase64(extraPhotoAndroidDTO: AthleteCameraPhoto): Observable<FileResponse | null>;
    loginGetSmenaId(): Observable<FileResponse | null>;
    extraPhotoSaveInBase64(extraPhotoAndroidDTO: ExtraPhotoAndroidDTO): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class FaceIDMobileClient implements IFaceIDMobileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPhotoById(id: number): Observable<ResponseModelOfAthletesInfoDTO> {
        let url_ = this.baseUrl + "/api/marathon/FaceIDMobile/GetPhotoById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhotoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhotoById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAthletesInfoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAthletesInfoDTO>;
        }));
    }

    protected processGetPhotoById(response: HttpResponseBase): Observable<ResponseModelOfAthletesInfoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAthletesInfoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    athletePhotoSaveInBase64(extraPhotoAndroidDTO: AthleteCameraPhoto): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/FaceIDMobile/AthletePhotoSaveInBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(extraPhotoAndroidDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAthletePhotoSaveInBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAthletePhotoSaveInBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processAthletePhotoSaveInBase64(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    loginGetSmenaId(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/FaceIDMobile/LoginGetSmenaId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginGetSmenaId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginGetSmenaId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processLoginGetSmenaId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    extraPhotoSaveInBase64(extraPhotoAndroidDTO: ExtraPhotoAndroidDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/FaceIDMobile/ExtraPhotoSaveInBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(extraPhotoAndroidDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtraPhotoSaveInBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtraPhotoSaveInBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExtraPhotoSaveInBase64(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFeedBackClient {
    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
    listByUserSend(): Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
    listByUserGet(): Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
    feedBackById(id: number): Observable<ResponseModelOfFeedBackDTO>;
    delete(id: number): Observable<ResponseModelOfBoolean>;
    onSave(item: FeedBackDTO): Observable<ResponseModelOfBoolean>;
    save(item: FeedBackDTO): Observable<ResponseModelOfBoolean>;
    update(item: FeedBackDTO): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class FeedBackClient implements IFeedBackClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfFeedBackDTO> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfFeedBackDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfFeedBackDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listByUserSend(): Observable<ResponseModelOfQueryResultOfFeedBackDTO> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/ListByUserSend";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListByUserSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListByUserSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
        }));
    }

    protected processListByUserSend(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfFeedBackDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfFeedBackDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listByUserGet(): Observable<ResponseModelOfQueryResultOfFeedBackDTO> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/ListByUserGet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListByUserGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListByUserGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfFeedBackDTO>;
        }));
    }

    protected processListByUserGet(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfFeedBackDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfFeedBackDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    feedBackById(id: number): Observable<ResponseModelOfFeedBackDTO> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/FeedBackById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFeedBackById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFeedBackById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfFeedBackDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfFeedBackDTO>;
        }));
    }

    protected processFeedBackById(response: HttpResponseBase): Observable<ResponseModelOfFeedBackDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfFeedBackDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    onSave(item: FeedBackDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/OnSave";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processOnSave(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    save(item: FeedBackDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(item: FeedBackDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/FeedBack/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IFilesClient {
    getFile(id: string): Observable<FileResponse | null>;
    getImageByIdFromFolderInBase64(id: string): Observable<string>;
    uploadForImage(): Observable<FileResponse | null>;
    uploadFile(): Observable<FileResponse | null>;
    uploadForVideo(): Observable<FileResponse | null>;
    deleteFileById(id: string | undefined): Observable<boolean>;
    uploadForImageBase64(base64Image: FileBase64): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class FilesClient implements IFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getFile(id: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Files/GetFile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getImageByIdFromFolderInBase64(id: string): Observable<string> {
        let url_ = this.baseUrl + "/api/marathon/Files/GetImageByIdFromFolderInBase64/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageByIdFromFolderInBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageByIdFromFolderInBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetImageByIdFromFolderInBase64(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForImage(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Files/UploadForImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForImage(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadFile(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Files/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForVideo(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Files/uploadForVideo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForVideo(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteFileById(id: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Files/DeleteFileById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFileById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFileById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processDeleteFileById(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadForImageBase64(base64Image: FileBase64): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Files/uploadForImageBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(base64Image);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadForImageBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadForImageBase64(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUploadForImageBase64(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMarathonMobileClient {
    allResultEvents(name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null>;
    getResultEventById(eventId: number): Observable<FileResponse | null>;
    getResultDetailsResultId(resultId: number): Observable<FileResponse | null>;
    getAllResultUserByEventId(eventId: number | undefined, spGenderTypeId: number | null | undefined, category: string | null | undefined, name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null>;
    getAllEventBoxList(name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null>;
    getByIdEventBox(eventBoxId: number): Observable<FileResponse | null>;
    myEventBoxList(name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null>;
    getSmenas(eventId: number): Observable<FileResponse | null>;
    bibCodeReservation(joinEventBibDTO: JoinEventBibDTO): Observable<FileResponse | null>;
    updateOnAthleteActiveBibNumber(eventId: number): Observable<FileResponse | null>;
    joinEventAthletes(joinEventBibDTO: JoinEventBibDTO): Observable<FileResponse | null>;
    deleteRegisteredEventAthlete(eventId: number): Observable<FileResponse | null>;
    saveApplicationRepayment(applicationRepayment: ApplicationRepaymentDTO): Observable<FileResponse | null>;
    getAllNotificationMB(): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class MarathonMobileClient implements IMarathonMobileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    allResultEvents(name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/AllResultEvents?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "First=" + encodeURIComponent("" + first) + "&";
        if (rows === null)
            throw new Error("The parameter 'rows' cannot be null.");
        else if (rows !== undefined)
            url_ += "Rows=" + encodeURIComponent("" + rows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllResultEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllResultEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processAllResultEvents(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getResultEventById(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetResultEventById/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResultEventById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResultEventById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetResultEventById(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getResultDetailsResultId(resultId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetResultDetailsResultId/{resultId}";
        if (resultId === undefined || resultId === null)
            throw new Error("The parameter 'resultId' must be defined.");
        url_ = url_.replace("{resultId}", encodeURIComponent("" + resultId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetResultDetailsResultId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetResultDetailsResultId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetResultDetailsResultId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllResultUserByEventId(eventId: number | undefined, spGenderTypeId: number | null | undefined, category: string | null | undefined, name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetAllResultUserByEventId?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "EventId=" + encodeURIComponent("" + eventId) + "&";
        if (spGenderTypeId !== undefined && spGenderTypeId !== null)
            url_ += "SpGenderTypeId=" + encodeURIComponent("" + spGenderTypeId) + "&";
        if (category !== undefined && category !== null)
            url_ += "Category=" + encodeURIComponent("" + category) + "&";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "First=" + encodeURIComponent("" + first) + "&";
        if (rows === null)
            throw new Error("The parameter 'rows' cannot be null.");
        else if (rows !== undefined)
            url_ += "Rows=" + encodeURIComponent("" + rows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllResultUserByEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllResultUserByEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetAllResultUserByEventId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllEventBoxList(name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetAllEventBoxList?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "First=" + encodeURIComponent("" + first) + "&";
        if (rows === null)
            throw new Error("The parameter 'rows' cannot be null.");
        else if (rows !== undefined)
            url_ += "Rows=" + encodeURIComponent("" + rows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEventBoxList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEventBoxList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetAllEventBoxList(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdEventBox(eventBoxId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetByIdEventBox/{eventBoxId}";
        if (eventBoxId === undefined || eventBoxId === null)
            throw new Error("The parameter 'eventBoxId' must be defined.");
        url_ = url_.replace("{eventBoxId}", encodeURIComponent("" + eventBoxId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdEventBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdEventBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetByIdEventBox(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    myEventBoxList(name: string | null | undefined, first: number | undefined, rows: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/MyEventBoxList?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (first === null)
            throw new Error("The parameter 'first' cannot be null.");
        else if (first !== undefined)
            url_ += "First=" + encodeURIComponent("" + first) + "&";
        if (rows === null)
            throw new Error("The parameter 'rows' cannot be null.");
        else if (rows !== undefined)
            url_ += "Rows=" + encodeURIComponent("" + rows) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyEventBoxList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyEventBoxList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processMyEventBoxList(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSmenas(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetSmenas/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSmenas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSmenas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetSmenas(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bibCodeReservation(joinEventBibDTO: JoinEventBibDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/BibCodeReservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventBibDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBibCodeReservation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBibCodeReservation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processBibCodeReservation(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOnAthleteActiveBibNumber(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/UpdateOnAthleteActiveBibNumber/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOnAthleteActiveBibNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOnAthleteActiveBibNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateOnAthleteActiveBibNumber(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    joinEventAthletes(joinEventBibDTO: JoinEventBibDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/JoinEventAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventBibDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinEventAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinEventAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processJoinEventAthletes(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegisteredEventAthlete(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/DeleteRegisteredEventAthlete/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegisteredEventAthlete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegisteredEventAthlete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processDeleteRegisteredEventAthlete(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveApplicationRepayment(applicationRepayment: ApplicationRepaymentDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/SaveApplicationRepayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(applicationRepayment);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveApplicationRepayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveApplicationRepayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSaveApplicationRepayment(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllNotificationMB(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/MarathonMobile/GetAllNotificationMB";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotificationMB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotificationMB(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetAllNotificationMB(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INewsClient {
    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfNewsDTO>;
    listActive(): Observable<ResponseModelOfQueryResultOfNewsDTO>;
    newsById(id: number): Observable<ResponseModelOfNewsDTO>;
    delete(id: number): Observable<ResponseModelOfBoolean>;
    save(item: NewsDTO): Observable<ResponseModelOfNewsDTO>;
    update(item: NewsDTO): Observable<ResponseModelOfNewsDTO>;
    sendNotification(item: NotificationDTO): Observable<ResponseModelOfBoolean>;
    sendNotificationForUser(item: NotificationDTO): Observable<boolean>;
    seenNotification(id: number): Observable<ResponseModelOfBoolean>;
    removeNotification(id: number): Observable<ResponseModelOfBoolean>;
    seenNotificationMB(id: number): Observable<FileResponse | null>;
    removeNotificationMB(id: number): Observable<FileResponse | null>;
    getAllNotificationForAdmin(metaData: TableMetaData): Observable<NotificationDTO[]>;
    getAllNotification(): Observable<NotificationDTO[]>;
}

@Injectable({
    providedIn: 'root'
})
export class NewsClient implements INewsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    list(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfNewsDTO> {
        let url_ = this.baseUrl + "/api/marathon/News/List";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfNewsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfNewsDTO>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfNewsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfNewsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listActive(): Observable<ResponseModelOfQueryResultOfNewsDTO> {
        let url_ = this.baseUrl + "/api/marathon/News/ListActive";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfNewsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfNewsDTO>;
        }));
    }

    protected processListActive(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfNewsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfNewsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    newsById(id: number): Observable<ResponseModelOfNewsDTO> {
        let url_ = this.baseUrl + "/api/marathon/News/NewsById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfNewsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfNewsDTO>;
        }));
    }

    protected processNewsById(response: HttpResponseBase): Observable<ResponseModelOfNewsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfNewsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/News/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    save(item: NewsDTO): Observable<ResponseModelOfNewsDTO> {
        let url_ = this.baseUrl + "/api/marathon/News/Save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfNewsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfNewsDTO>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<ResponseModelOfNewsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfNewsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(item: NewsDTO): Observable<ResponseModelOfNewsDTO> {
        let url_ = this.baseUrl + "/api/marathon/News/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfNewsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfNewsDTO>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResponseModelOfNewsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfNewsDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendNotification(item: NotificationDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/News/SendNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSendNotification(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendNotificationForUser(item: NotificationDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/News/SendNotificationForUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotificationForUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotificationForUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSendNotificationForUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    seenNotification(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/News/SeenNotification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeenNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeenNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSeenNotification(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeNotification(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/News/RemoveNotification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processRemoveNotification(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    seenNotificationMB(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/News/SeenNotificationMB/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeenNotificationMB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeenNotificationMB(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSeenNotificationMB(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeNotificationMB(id: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/News/RemoveNotificationMB/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveNotificationMB(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveNotificationMB(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processRemoveNotificationMB(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllNotificationForAdmin(metaData: TableMetaData): Observable<NotificationDTO[]> {
        let url_ = this.baseUrl + "/api/marathon/News/GetAllNotificationForAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(metaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotificationForAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotificationForAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDTO[]>;
        }));
    }

    protected processGetAllNotificationForAdmin(response: HttpResponseBase): Observable<NotificationDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllNotification(): Observable<NotificationDTO[]> {
        let url_ = this.baseUrl + "/api/marathon/News/GetAllNotification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotificationDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotificationDTO[]>;
        }));
    }

    protected processGetAllNotification(response: HttpResponseBase): Observable<NotificationDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotificationDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INotificationClient {
    sendMessageByUserId(userId: string | null | undefined, message: NotificationDTO): Observable<FileResponse | null>;
    sendMessage(method: string | null | undefined, message: NotificationDTO): Observable<FileResponse | null>;
    sendNotification(group: string | null | undefined, method: string | null | undefined, message: NotificationDTO): Observable<FileResponse | null>;
    sendGroupNotification(message: NotificationDTO): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class NotificationClient implements INotificationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    sendMessageByUserId(userId: string | null | undefined, message: NotificationDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Notification/SendMessageByUserId?";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessageByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessageByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSendMessageByUserId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendMessage(method: string | null | undefined, message: NotificationDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Notification/SendMessage?";
        if (method !== undefined && method !== null)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSendMessage(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendNotification(group: string | null | undefined, method: string | null | undefined, message: NotificationDTO): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Notification/SendNotification?";
        if (group !== undefined && group !== null)
            url_ += "group=" + encodeURIComponent("" + group) + "&";
        if (method !== undefined && method !== null)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processSendNotification(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendGroupNotification(message: NotificationDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Notification/SendGroupNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendGroupNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendGroupNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processSendGroupNotification(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOrganizationClient {
    getAllOrganizations(): Observable<ResponseModelOfQueryResultOfOrganizationDTO>;
    getByIdOrganization(id: number): Observable<ResponseModelOfOrganizationDTO>;
    saveOrganization(oragnization: OrganizationDTO): Observable<ResponseModelOfOrganizationDTO>;
    onSaveOrganization(oragnization: OrganizationModelDTO): Observable<boolean>;
    updateOrganization(organizationId: number, oragnization: OrganizationDTO): Observable<ResponseModelOfBoolean>;
    deleteOrganization(organizationId: number): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationClient implements IOrganizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllOrganizations(): Observable<ResponseModelOfQueryResultOfOrganizationDTO> {
        let url_ = this.baseUrl + "/api/marathon/Organization/GetAllOrganizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfOrganizationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfOrganizationDTO>;
        }));
    }

    protected processGetAllOrganizations(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfOrganizationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfOrganizationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdOrganization(id: number): Observable<ResponseModelOfOrganizationDTO> {
        let url_ = this.baseUrl + "/api/marathon/Organization/GetByIdOrganization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfOrganizationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfOrganizationDTO>;
        }));
    }

    protected processGetByIdOrganization(response: HttpResponseBase): Observable<ResponseModelOfOrganizationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfOrganizationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveOrganization(oragnization: OrganizationDTO): Observable<ResponseModelOfOrganizationDTO> {
        let url_ = this.baseUrl + "/api/marathon/Organization/SaveOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oragnization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfOrganizationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfOrganizationDTO>;
        }));
    }

    protected processSaveOrganization(response: HttpResponseBase): Observable<ResponseModelOfOrganizationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfOrganizationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    onSaveOrganization(oragnization: OrganizationModelDTO): Observable<boolean> {
        let url_ = this.baseUrl + "/api/marathon/Organization/OnSaveOrganization";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oragnization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnSaveOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnSaveOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processOnSaveOrganization(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOrganization(organizationId: number, oragnization: OrganizationDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Organization/UpdateOrganization/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oragnization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateOrganization(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOrganization(organizationId: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Organization/DeleteOrganization/{organizationId}";
        if (organizationId === undefined || organizationId === null)
            throw new Error("The parameter 'organizationId' must be defined.");
        url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganization(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteOrganization(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPaymentClient {
    payme(model: PaymeViewModel): Observable<PaymeResponse>;
    clickprepare(model: ClickRequest): Observable<ClickResponse>;
    clickcomplete(model: ClickRequest): Observable<ClickResponse>;
    paymentHistory(): Observable<AthletesPaymentDTO[]>;
}

@Injectable({
    providedIn: 'root'
})
export class PaymentClient implements IPaymentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    payme(model: PaymeViewModel): Observable<PaymeResponse> {
        let url_ = this.baseUrl + "/api/marathon/Payment/Payme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymeResponse>;
        }));
    }

    protected processPayme(response: HttpResponseBase): Observable<PaymeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clickprepare(model: ClickRequest): Observable<ClickResponse> {
        let url_ = this.baseUrl + "/api/marathon/Payment/clickprepare";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClickprepare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClickprepare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClickResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClickResponse>;
        }));
    }

    protected processClickprepare(response: HttpResponseBase): Observable<ClickResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClickResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clickcomplete(model: ClickRequest): Observable<ClickResponse> {
        let url_ = this.baseUrl + "/api/marathon/Payment/clickcomplete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClickcomplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClickcomplete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClickResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClickResponse>;
        }));
    }

    protected processClickcomplete(response: HttpResponseBase): Observable<ClickResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClickResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentHistory(): Observable<AthletesPaymentDTO[]> {
        let url_ = this.baseUrl + "/api/marathon/Payment/PaymentHistory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AthletesPaymentDTO[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AthletesPaymentDTO[]>;
        }));
    }

    protected processPaymentHistory(response: HttpResponseBase): Observable<AthletesPaymentDTO[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AthletesPaymentDTO.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPhotoVideoClient {
    listImage(): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
    getListImageRandom(): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
    getListVideoRandom(): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
    deleteImage(id: number): Observable<ResponseModelOfBoolean>;
    saveImage(item: PhotoVideoDTO): Observable<ResponseModelOfBoolean>;
    saveImageList(items: PhotoVideoDTO[]): Observable<ResponseModelOfBoolean>;
    listVideo(): Observable<QueryResultOfPhotoVideoDTO>;
    deleteVideo(id: number): Observable<ResponseModelOfBoolean>;
    saveVideo(item: PhotoVideoDTO): Observable<ResponseModelOfBoolean>;
    saveVideoList(items: PhotoVideoDTO[]): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class PhotoVideoClient implements IPhotoVideoClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listImage(): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/ListImage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
        }));
    }

    protected processListImage(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfPhotoVideoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListImageRandom(): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/GetListImageRandom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListImageRandom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListImageRandom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
        }));
    }

    protected processGetListImageRandom(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfPhotoVideoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getListVideoRandom(): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/GetListVideoRandom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListVideoRandom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListVideoRandom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfPhotoVideoDTO>;
        }));
    }

    protected processGetListVideoRandom(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfPhotoVideoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfPhotoVideoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/DeleteImage/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveImage(item: PhotoVideoDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/SaveImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveImage(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveImageList(items: PhotoVideoDTO[]): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/SaveImageList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveImageList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveImageList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveImageList(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listVideo(): Observable<QueryResultOfPhotoVideoDTO> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/ListVideo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfPhotoVideoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfPhotoVideoDTO>;
        }));
    }

    protected processListVideo(response: HttpResponseBase): Observable<QueryResultOfPhotoVideoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfPhotoVideoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVideo(id: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/DeleteVideo/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteVideo(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveVideo(item: PhotoVideoDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/SaveVideo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(item);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveVideo(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveVideoList(items: PhotoVideoDTO[]): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PhotoVideo/SaveVideoList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(items);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVideoList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVideoList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveVideoList(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPublishResultClient {
    addPublishResult(publishResultDTO: PublishResultDTO): Observable<ResponseModelOfBoolean>;
    updatePublishResult(publishResultDTO: PublishResultDTO): Observable<ResponseModelOfBoolean>;
    publishResultById(eventId: number): Observable<ResponseModelOfPublishResultDTO>;
    getAllPuplishResultView(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAllResultView>;
    addPublishFilterFormula(filterFormulaDTO: PublishFilterFormulaDTO): Observable<ResponseModelOfBoolean>;
    updatePublishFilterFormula(filterFormulaDTO: PublishFilterFormulaDTO): Observable<ResponseModelOfBoolean>;
    deletePublishFilterFormula(formulaId: number): Observable<ResponseModelOfBoolean>;
    publishFilterFormulaById(formulaId: number): Observable<ResponseModelOfPublishFilterFormulaDTO>;
    getAllSelectPublishFilterFormula(eventId: number): Observable<SelectPublishFilterFormula[]>;
    getAllPublishFilterFormulaView(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfPublishFilterFormulaDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class PublishResultClient implements IPublishResultClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addPublishResult(publishResultDTO: PublishResultDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/AddPublishResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishResultDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPublishResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPublishResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processAddPublishResult(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePublishResult(publishResultDTO: PublishResultDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/UpdatePublishResult";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(publishResultDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePublishResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePublishResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdatePublishResult(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    publishResultById(eventId: number): Observable<ResponseModelOfPublishResultDTO> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/PublishResultById/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishResultById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishResultById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfPublishResultDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfPublishResultDTO>;
        }));
    }

    protected processPublishResultById(response: HttpResponseBase): Observable<ResponseModelOfPublishResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfPublishResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPuplishResultView(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAllResultView> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/GetAllPuplishResultView/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPuplishResultView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPuplishResultView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfAllResultView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfAllResultView>;
        }));
    }

    protected processGetAllPuplishResultView(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfAllResultView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfAllResultView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addPublishFilterFormula(filterFormulaDTO: PublishFilterFormulaDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/AddPublishFilterFormula";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterFormulaDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPublishFilterFormula(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPublishFilterFormula(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processAddPublishFilterFormula(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePublishFilterFormula(filterFormulaDTO: PublishFilterFormulaDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/UpdatePublishFilterFormula";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filterFormulaDTO);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePublishFilterFormula(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePublishFilterFormula(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdatePublishFilterFormula(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePublishFilterFormula(formulaId: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/DeletePublishFilterFormula/{formulaId}";
        if (formulaId === undefined || formulaId === null)
            throw new Error("The parameter 'formulaId' must be defined.");
        url_ = url_.replace("{formulaId}", encodeURIComponent("" + formulaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePublishFilterFormula(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePublishFilterFormula(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeletePublishFilterFormula(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    publishFilterFormulaById(formulaId: number): Observable<ResponseModelOfPublishFilterFormulaDTO> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/PublishFilterFormulaById/{formulaId}";
        if (formulaId === undefined || formulaId === null)
            throw new Error("The parameter 'formulaId' must be defined.");
        url_ = url_.replace("{formulaId}", encodeURIComponent("" + formulaId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishFilterFormulaById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishFilterFormulaById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfPublishFilterFormulaDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfPublishFilterFormulaDTO>;
        }));
    }

    protected processPublishFilterFormulaById(response: HttpResponseBase): Observable<ResponseModelOfPublishFilterFormulaDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfPublishFilterFormulaDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllSelectPublishFilterFormula(eventId: number): Observable<SelectPublishFilterFormula[]> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/GetAllSelectPublishFilterFormula/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSelectPublishFilterFormula(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSelectPublishFilterFormula(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SelectPublishFilterFormula[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SelectPublishFilterFormula[]>;
        }));
    }

    protected processGetAllSelectPublishFilterFormula(response: HttpResponseBase): Observable<SelectPublishFilterFormula[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SelectPublishFilterFormula.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPublishFilterFormulaView(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfPublishFilterFormulaDTO> {
        let url_ = this.baseUrl + "/api/marathon/PublishResult/GetAllPublishFilterFormulaView/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPublishFilterFormulaView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPublishFilterFormulaView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfPublishFilterFormulaDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfPublishFilterFormulaDTO>;
        }));
    }

    protected processGetAllPublishFilterFormulaView(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfPublishFilterFormulaDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfPublishFilterFormulaDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRegistationEventClient {
    getUniversitiesFromRegistrationEvents(): Observable<ResponseModelOfListOfUniversityDTO>;
    registeredEventAthletesList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
    getAllRegisteredEventByEvenId(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryCheckedResultOfRegistationEventDTO>;
    getAllRegisteredEventForAdmiOrModerator(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
    eventAthletesApprovedByTheAdmin(addEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    eventAthletesRejecedByTheAdmin(addEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    isGivenNumberRegistationEvent(selectRegistationEvents: SelectRegistationEventDTO[], isGivenNumber: boolean | undefined): Observable<ResponseModelOfBoolean>;
    allCompletedByEventId(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
    exportRegisteredEventByEventId(eventId: number, tableMeta: TableMetaData): Observable<FileResponse | null>;
    exportRegisteredEventByEventIdForOrganizator(eventId: number): Observable<FileResponse | null>;
    getAthletesByEventIdForOrganizator(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
    getAllCartInformations(tableMetaData: TableMetaData): Observable<ResponseModelOfQueryResultOfCartInformationDTO>;
    addInformationToCart(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    bibCodeReservationForOrganizator(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBibCodeInfoModel>;
    onUpdateAthleteActiveBibNumber(athleteEvent: AthleteEventDto): Observable<ResponseModelOfBoolean>;
    joinEventAthletesForOrganizator(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfRegistationEventDTO>;
    deleteRegisteredEventAthleteForOrganizator(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    saveEventAthletesForOrganizator(addEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    getByIdRegisteredEvent(id: number): Observable<ResponseModelOfRegistationEventDTO>;
    getSmenas(eventId: number): Observable<ResponseModelOfQueryResultOfSmenaDTO>;
    getPacketByEventId(eventId: number): Observable<ResponseModelOfListOfEventPacketDTO>;
    bibCodeReservation(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBibCodeInfoModel>;
    joinEventAthletes(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    deleteRegisteredEventAthlete(eventId: number): Observable<ResponseModelOfBoolean>;
    updateOnAthleteActiveBibNumber(eventId: number): Observable<ResponseModelOfBoolean>;
    myResults(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
    isPinflExistsInERPSport(pinfl: string | null | undefined): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class RegistationEventClient implements IRegistationEventClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUniversitiesFromRegistrationEvents(): Observable<ResponseModelOfListOfUniversityDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetUniversitiesFromRegistrationEvents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniversitiesFromRegistrationEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniversitiesFromRegistrationEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfUniversityDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfUniversityDTO>;
        }));
    }

    protected processGetUniversitiesFromRegistrationEvents(response: HttpResponseBase): Observable<ResponseModelOfListOfUniversityDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfUniversityDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registeredEventAthletesList(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/RegisteredEventAthletesList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisteredEventAthletesList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisteredEventAthletesList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
        }));
    }

    protected processRegisteredEventAthletesList(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllRegisteredEventByEvenId(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryCheckedResultOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetAllRegisteredEventByEvenId/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRegisteredEventByEvenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRegisteredEventByEvenId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryCheckedResultOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryCheckedResultOfRegistationEventDTO>;
        }));
    }

    protected processGetAllRegisteredEventByEvenId(response: HttpResponseBase): Observable<ResponseModelOfQueryCheckedResultOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryCheckedResultOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllRegisteredEventForAdmiOrModerator(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetAllRegisteredEventForAdmiOrModerator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRegisteredEventForAdmiOrModerator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRegisteredEventForAdmiOrModerator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
        }));
    }

    protected processGetAllRegisteredEventForAdmiOrModerator(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventAthletesApprovedByTheAdmin(addEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/EventAthletesApprovedByTheAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventAthletesApprovedByTheAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventAthletesApprovedByTheAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processEventAthletesApprovedByTheAdmin(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventAthletesRejecedByTheAdmin(addEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/EventAthletesRejecedByTheAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventAthletesRejecedByTheAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventAthletesRejecedByTheAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processEventAthletesRejecedByTheAdmin(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isGivenNumberRegistationEvent(selectRegistationEvents: SelectRegistationEventDTO[], isGivenNumber: boolean | undefined): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/IsGivenNumberRegistationEvent?";
        if (isGivenNumber === null)
            throw new Error("The parameter 'isGivenNumber' cannot be null.");
        else if (isGivenNumber !== undefined)
            url_ += "isGivenNumber=" + encodeURIComponent("" + isGivenNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectRegistationEvents);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsGivenNumberRegistationEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsGivenNumberRegistationEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processIsGivenNumberRegistationEvent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allCompletedByEventId(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/AllCompletedByEventId/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllCompletedByEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllCompletedByEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
        }));
    }

    protected processAllCompletedByEventId(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportRegisteredEventByEventId(eventId: number, tableMeta: TableMetaData): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/ExportRegisteredEventByEventId/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportRegisteredEventByEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportRegisteredEventByEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportRegisteredEventByEventId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportRegisteredEventByEventIdForOrganizator(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/ExportRegisteredEventByEventIdForOrganizator/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportRegisteredEventByEventIdForOrganizator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportRegisteredEventByEventIdForOrganizator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportRegisteredEventByEventIdForOrganizator(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthletesByEventIdForOrganizator(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetAthletesByEventIdForOrganizator/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthletesByEventIdForOrganizator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthletesByEventIdForOrganizator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
        }));
    }

    protected processGetAthletesByEventIdForOrganizator(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCartInformations(tableMetaData: TableMetaData): Observable<ResponseModelOfQueryResultOfCartInformationDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetAllCartInformations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMetaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCartInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCartInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfCartInformationDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfCartInformationDTO>;
        }));
    }

    protected processGetAllCartInformations(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfCartInformationDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfCartInformationDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addInformationToCart(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/AddInformationToCart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddInformationToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddInformationToCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processAddInformationToCart(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bibCodeReservationForOrganizator(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBibCodeInfoModel> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/BibCodeReservationForOrganizator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBibCodeReservationForOrganizator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBibCodeReservationForOrganizator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBibCodeInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBibCodeInfoModel>;
        }));
    }

    protected processBibCodeReservationForOrganizator(response: HttpResponseBase): Observable<ResponseModelOfBibCodeInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBibCodeInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    onUpdateAthleteActiveBibNumber(athleteEvent: AthleteEventDto): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/OnUpdateAthleteActiveBibNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athleteEvent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnUpdateAthleteActiveBibNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnUpdateAthleteActiveBibNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processOnUpdateAthleteActiveBibNumber(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    joinEventAthletesForOrganizator(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/JoinEventAthletesForOrganizator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinEventAthletesForOrganizator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinEventAthletesForOrganizator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfRegistationEventDTO>;
        }));
    }

    protected processJoinEventAthletesForOrganizator(response: HttpResponseBase): Observable<ResponseModelOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegisteredEventAthleteForOrganizator(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/DeleteRegisteredEventAthleteForOrganizator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectRegistationEvent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegisteredEventAthleteForOrganizator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegisteredEventAthleteForOrganizator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteRegisteredEventAthleteForOrganizator(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveEventAthletesForOrganizator(addEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/SaveEventAthletesForOrganizator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveEventAthletesForOrganizator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveEventAthletesForOrganizator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSaveEventAthletesForOrganizator(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdRegisteredEvent(id: number): Observable<ResponseModelOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetByIdRegisteredEvent/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdRegisteredEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdRegisteredEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfRegistationEventDTO>;
        }));
    }

    protected processGetByIdRegisteredEvent(response: HttpResponseBase): Observable<ResponseModelOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSmenas(eventId: number): Observable<ResponseModelOfQueryResultOfSmenaDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetSmenas/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSmenas(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSmenas(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfSmenaDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfSmenaDTO>;
        }));
    }

    protected processGetSmenas(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfSmenaDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfSmenaDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPacketByEventId(eventId: number): Observable<ResponseModelOfListOfEventPacketDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/GetPacketByEventId/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPacketByEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPacketByEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfEventPacketDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfEventPacketDTO>;
        }));
    }

    protected processGetPacketByEventId(response: HttpResponseBase): Observable<ResponseModelOfListOfEventPacketDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfEventPacketDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bibCodeReservation(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBibCodeInfoModel> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/BibCodeReservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBibCodeReservation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBibCodeReservation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBibCodeInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBibCodeInfoModel>;
        }));
    }

    protected processBibCodeReservation(response: HttpResponseBase): Observable<ResponseModelOfBibCodeInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBibCodeInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    joinEventAthletes(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/JoinEventAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinEventAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinEventAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processJoinEventAthletes(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegisteredEventAthlete(eventId: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/DeleteRegisteredEventAthlete/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegisteredEventAthlete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegisteredEventAthlete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteRegisteredEventAthlete(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOnAthleteActiveBibNumber(eventId: number): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/UpdateOnAthleteActiveBibNumber/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOnAthleteActiveBibNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOnAthleteActiveBibNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateOnAthleteActiveBibNumber(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    myResults(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/MyResults";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfRegistationEventDTO>;
        }));
    }

    protected processMyResults(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfRegistationEventDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfRegistationEventDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isPinflExistsInERPSport(pinfl: string | null | undefined): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/RegistationEvent/IsPinflExistsInERPSport?";
        if (pinfl !== undefined && pinfl !== null)
            url_ += "pinfl=" + encodeURIComponent("" + pinfl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsPinflExistsInERPSport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsPinflExistsInERPSport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processIsPinflExistsInERPSport(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IResultClient {
    getByEventIdMyResult(eventId: number): Observable<ResponseModelOfAllResultViewDTO>;
    myResults(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAllResultViewDTO>;
    getAllCompletedMarathons(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfSelectEvent>;
    getAllResult(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAllResultDTO>;
    exportAllResultToExcelByEventId(eventId: number): Observable<FileResponse | null>;
    exportAllResultToExcelByEventIdAndFormulaIdWithoutPublishResult(tableMeta: TableMetaData, eventId: number): Observable<FileResponse | null>;
    exportAllResultToExcelByEventIdAndFormulaIdWithPublishResult(tableMeta: TableMetaData, eventId: number): Observable<FileResponse | null>;
    importResultRegistationEvent(eventId: number): Observable<FileResponse | null>;
    updateResult(): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class ResultClient implements IResultClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getByEventIdMyResult(eventId: number): Observable<ResponseModelOfAllResultViewDTO> {
        let url_ = this.baseUrl + "/api/marathon/Result/GetByEventIdMyResult/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByEventIdMyResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByEventIdMyResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfAllResultViewDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfAllResultViewDTO>;
        }));
    }

    protected processGetByEventIdMyResult(response: HttpResponseBase): Observable<ResponseModelOfAllResultViewDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfAllResultViewDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    myResults(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAllResultViewDTO> {
        let url_ = this.baseUrl + "/api/marathon/Result/MyResults";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyResults(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyResults(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfAllResultViewDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfAllResultViewDTO>;
        }));
    }

    protected processMyResults(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfAllResultViewDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfAllResultViewDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllCompletedMarathons(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfSelectEvent> {
        let url_ = this.baseUrl + "/api/marathon/Result/GetAllCompletedMarathons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCompletedMarathons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompletedMarathons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfSelectEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfSelectEvent>;
        }));
    }

    protected processGetAllCompletedMarathons(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfSelectEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfSelectEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllResult(eventId: number, tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfAllResultDTO> {
        let url_ = this.baseUrl + "/api/marathon/Result/GetAllResult/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfAllResultDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfAllResultDTO>;
        }));
    }

    protected processGetAllResult(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfAllResultDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfAllResultDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportAllResultToExcelByEventId(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Result/ExportAllResultToExcelByEventId/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllResultToExcelByEventId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllResultToExcelByEventId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportAllResultToExcelByEventId(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportAllResultToExcelByEventIdAndFormulaIdWithoutPublishResult(tableMeta: TableMetaData, eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Result/ExportAllResultToExcelByEventIdAndFormulaIdWithoutPublishResult/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllResultToExcelByEventIdAndFormulaIdWithoutPublishResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllResultToExcelByEventIdAndFormulaIdWithoutPublishResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportAllResultToExcelByEventIdAndFormulaIdWithoutPublishResult(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportAllResultToExcelByEventIdAndFormulaIdWithPublishResult(tableMeta: TableMetaData, eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Result/ExportAllResultToExcelByEventIdAndFormulaIdWithPublishResult/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportAllResultToExcelByEventIdAndFormulaIdWithPublishResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportAllResultToExcelByEventIdAndFormulaIdWithPublishResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportAllResultToExcelByEventIdAndFormulaIdWithPublishResult(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importResultRegistationEvent(eventId: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Result/ImportResultRegistationEvent/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportResultRegistationEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportResultRegistationEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processImportResultRegistationEvent(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateResult(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Result/UpdateResult";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateResult(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRunnersClient {
    getTime(): Observable<FileResponse | null>;
    test(a: string | null | undefined): Observable<ResponseModelOfBoolean>;
    generateFakePinfl(): Observable<ResponseModelOfBoolean>;
    changeFakePinfl(): Observable<ResponseModelOfBoolean>;
    setFakePinfl(): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class RunnersClient implements IRunnersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTime(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/Runners/GetTime";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetTime(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    test(a: string | null | undefined): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Runners/Test?";
        if (a !== undefined && a !== null)
            url_ += "a=" + encodeURIComponent("" + a) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    generateFakePinfl(): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Runners/GenerateFakePinfl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateFakePinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateFakePinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processGenerateFakePinfl(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeFakePinfl(): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Runners/ChangeFakePinfl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeFakePinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeFakePinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processChangeFakePinfl(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setFakePinfl(): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/Runners/SetFakePinfl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFakePinfl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFakePinfl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processSetFakePinfl(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStatisticsClient {
    getAllStatistics(fromAge: number | null | undefined, toAge: number | null | undefined): Observable<ResponseModelOfStatisticsAll>;
    getActiveEventBoxesStatistics(filters: Filter[]): Observable<ResponseModelOfListOfActiveEventBoxStatistics>;
    getAllResultStatistics(tableMeta: TableMetaData): Observable<QueryResultOfResultStatistics>;
    getRegistrationEventsCountByRegion(filters: Filter[]): Observable<ResponseModelOfRegionStatistics>;
    getMonthlyEventBoxesCount(filters: Filter[]): Observable<ResponseModelOfInt32Of>;
    getPaymentStatisticsOfEventBox(filters: Filter[]): Observable<ResponseModelOfEventBoxPaymentStatistics>;
    getMonthlyRegistrationEvents(filters: Filter[]): Observable<ResponseModelOfInt32Of>;
    getRecordsmenList(filters: Filter[]): Observable<ResponseModelOfListOfAthleteStatistics>;
    getAthleteCountsByRegions(fromAge: number | null | undefined, toAge: number | null | undefined): Observable<ResponseModelOfStatisticsByAllRegions>;
    getActiveAthletes(filters: Filter[]): Observable<ResponseModelOfListOfAthleteStatistics>;
    getTopAthletes(metaData: TableMetaData): Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO>;
    getTopUniversityAthletes(metaData: TableMetaData): Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO>;
    getUniversitiesStatistics(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfUniversityStatistics>;
    getFinishedEventBoxesStatistics(tableMeta: TableMetaData): Observable<ResponseModelOfListOfFinishedEventBoxStatistics>;
}

@Injectable({
    providedIn: 'root'
})
export class StatisticsClient implements IStatisticsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllStatistics(fromAge: number | null | undefined, toAge: number | null | undefined): Observable<ResponseModelOfStatisticsAll> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetAllStatistics?";
        if (fromAge !== undefined && fromAge !== null)
            url_ += "FromAge=" + encodeURIComponent("" + fromAge) + "&";
        if (toAge !== undefined && toAge !== null)
            url_ += "ToAge=" + encodeURIComponent("" + toAge) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfStatisticsAll>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfStatisticsAll>;
        }));
    }

    protected processGetAllStatistics(response: HttpResponseBase): Observable<ResponseModelOfStatisticsAll> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfStatisticsAll.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveEventBoxesStatistics(filters: Filter[]): Observable<ResponseModelOfListOfActiveEventBoxStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetActiveEventBoxesStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveEventBoxesStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveEventBoxesStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfActiveEventBoxStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfActiveEventBoxStatistics>;
        }));
    }

    protected processGetActiveEventBoxesStatistics(response: HttpResponseBase): Observable<ResponseModelOfListOfActiveEventBoxStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfActiveEventBoxStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllResultStatistics(tableMeta: TableMetaData): Observable<QueryResultOfResultStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetAllResultStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllResultStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllResultStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueryResultOfResultStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueryResultOfResultStatistics>;
        }));
    }

    protected processGetAllResultStatistics(response: HttpResponseBase): Observable<QueryResultOfResultStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueryResultOfResultStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRegistrationEventsCountByRegion(filters: Filter[]): Observable<ResponseModelOfRegionStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetRegistrationEventsCountByRegion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegistrationEventsCountByRegion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegistrationEventsCountByRegion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfRegionStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfRegionStatistics>;
        }));
    }

    protected processGetRegistrationEventsCountByRegion(response: HttpResponseBase): Observable<ResponseModelOfRegionStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfRegionStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMonthlyEventBoxesCount(filters: Filter[]): Observable<ResponseModelOfInt32Of> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetMonthlyEventBoxesCount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonthlyEventBoxesCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthlyEventBoxesCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfInt32Of>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfInt32Of>;
        }));
    }

    protected processGetMonthlyEventBoxesCount(response: HttpResponseBase): Observable<ResponseModelOfInt32Of> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfInt32Of.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPaymentStatisticsOfEventBox(filters: Filter[]): Observable<ResponseModelOfEventBoxPaymentStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetPaymentStatisticsOfEventBox";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentStatisticsOfEventBox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentStatisticsOfEventBox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfEventBoxPaymentStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfEventBoxPaymentStatistics>;
        }));
    }

    protected processGetPaymentStatisticsOfEventBox(response: HttpResponseBase): Observable<ResponseModelOfEventBoxPaymentStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfEventBoxPaymentStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getMonthlyRegistrationEvents(filters: Filter[]): Observable<ResponseModelOfInt32Of> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetMonthlyRegistrationEvents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMonthlyRegistrationEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMonthlyRegistrationEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfInt32Of>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfInt32Of>;
        }));
    }

    protected processGetMonthlyRegistrationEvents(response: HttpResponseBase): Observable<ResponseModelOfInt32Of> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfInt32Of.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRecordsmenList(filters: Filter[]): Observable<ResponseModelOfListOfAthleteStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetRecordsmenList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecordsmenList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecordsmenList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfAthleteStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfAthleteStatistics>;
        }));
    }

    protected processGetRecordsmenList(response: HttpResponseBase): Observable<ResponseModelOfListOfAthleteStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfAthleteStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAthleteCountsByRegions(fromAge: number | null | undefined, toAge: number | null | undefined): Observable<ResponseModelOfStatisticsByAllRegions> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetAthleteCountsByRegions?";
        if (fromAge !== undefined && fromAge !== null)
            url_ += "FromAge=" + encodeURIComponent("" + fromAge) + "&";
        if (toAge !== undefined && toAge !== null)
            url_ += "ToAge=" + encodeURIComponent("" + toAge) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAthleteCountsByRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAthleteCountsByRegions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfStatisticsByAllRegions>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfStatisticsByAllRegions>;
        }));
    }

    protected processGetAthleteCountsByRegions(response: HttpResponseBase): Observable<ResponseModelOfStatisticsByAllRegions> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfStatisticsByAllRegions.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveAthletes(filters: Filter[]): Observable<ResponseModelOfListOfAthleteStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetActiveAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfAthleteStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfAthleteStatistics>;
        }));
    }

    protected processGetActiveAthletes(response: HttpResponseBase): Observable<ResponseModelOfListOfAthleteStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfAthleteStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTopAthletes(metaData: TableMetaData): Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetTopAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(metaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO>;
        }));
    }

    protected processGetTopAthletes(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfTopAthleteInfoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getTopUniversityAthletes(metaData: TableMetaData): Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetTopUniversityAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(metaData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopUniversityAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopUniversityAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO>;
        }));
    }

    protected processGetTopUniversityAthletes(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfTopAthleteInfoDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfTopAthleteInfoDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUniversitiesStatistics(tableMeta: TableMetaData): Observable<ResponseModelOfQueryResultOfUniversityStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetUniversitiesStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUniversitiesStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUniversitiesStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfQueryResultOfUniversityStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfQueryResultOfUniversityStatistics>;
        }));
    }

    protected processGetUniversitiesStatistics(response: HttpResponseBase): Observable<ResponseModelOfQueryResultOfUniversityStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfQueryResultOfUniversityStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFinishedEventBoxesStatistics(tableMeta: TableMetaData): Observable<ResponseModelOfListOfFinishedEventBoxStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetFinishedEventBoxesStatistics";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tableMeta);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinishedEventBoxesStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinishedEventBoxesStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfFinishedEventBoxStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfFinishedEventBoxStatistics>;
        }));
    }

    protected processGetFinishedEventBoxesStatistics(response: HttpResponseBase): Observable<ResponseModelOfListOfFinishedEventBoxStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfFinishedEventBoxStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IGetPaymentStatisticsOfEventBoxClient {
    noPagination(filters: Filter[]): Observable<ResponseModelOfEventBoxPaymentStatistics>;
}

@Injectable({
    providedIn: 'root'
})
export class GetPaymentStatisticsOfEventBoxClient implements IGetPaymentStatisticsOfEventBoxClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    noPagination(filters: Filter[]): Observable<ResponseModelOfEventBoxPaymentStatistics> {
        let url_ = this.baseUrl + "/api/marathon/Statistics/GetPaymentStatisticsOfEventBox_NoPagination";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filters);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNoPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNoPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfEventBoxPaymentStatistics>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfEventBoxPaymentStatistics>;
        }));
    }

    protected processNoPagination(response: HttpResponseBase): Observable<ResponseModelOfEventBoxPaymentStatistics> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfEventBoxPaymentStatistics.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISuperAdminClient {
    updateOnRegistrationEvent(selectModels: SelectModel[]): Observable<ResponseModelOfBoolean>;
    getSelectRegistrationEvent(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfSelectRegistationEvent>;
    getAllFilteredAthleteFullName(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfListOfSelectRegistationEvent>;
    getAllFilteredEventBibs(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfListOfSelectRegistationEvent>;
    getAllVipNumbers(eventId: number): Observable<ResponseModelOfListOfEventBibDTO>;
    bibCodeReservation(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBibCodeInfoModel>;
    joinEventAthletes(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean>;
    deleteOnRegistrationEvent(athleteEvent: AthleteEventDto): Observable<ResponseModelOfBoolean>;
    updateTeacher(): Observable<FileResponse | null>;
    updateERPsportTeamSquads(): Observable<ResponseModelOfBoolean>;
    updateREventOldBibCodes(eventId: number | undefined): Observable<FileResponse | null>;
    updateAthletesCadastr(): Observable<FileResponse | null>;
    exportExcelResultStatistic(eventIds: number[]): Observable<FileResponse | null>;
    emailResultsToAthletes(eventId: number | null | undefined, sendEmail: SendEmail): Observable<ResponseModelOfBoolean>;
}

@Injectable({
    providedIn: 'root'
})
export class SuperAdminClient implements ISuperAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    updateOnRegistrationEvent(selectModels: SelectModel[]): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/UpdateOnRegistrationEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectModels);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOnRegistrationEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOnRegistrationEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateOnRegistrationEvent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSelectRegistrationEvent(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfSelectRegistationEvent> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/GetSelectRegistrationEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectRegistationEvent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectRegistrationEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectRegistrationEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfSelectRegistationEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfSelectRegistationEvent>;
        }));
    }

    protected processGetSelectRegistrationEvent(response: HttpResponseBase): Observable<ResponseModelOfSelectRegistationEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfSelectRegistationEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFilteredAthleteFullName(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfListOfSelectRegistationEvent> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/GetAllFilteredAthleteFullName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectRegistationEvent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFilteredAthleteFullName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFilteredAthleteFullName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfSelectRegistationEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfSelectRegistationEvent>;
        }));
    }

    protected processGetAllFilteredAthleteFullName(response: HttpResponseBase): Observable<ResponseModelOfListOfSelectRegistationEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfSelectRegistationEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllFilteredEventBibs(selectRegistationEvent: SelectRegistationEventDTO): Observable<ResponseModelOfListOfSelectRegistationEvent> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/GetAllFilteredEventBibs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectRegistationEvent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFilteredEventBibs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFilteredEventBibs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfSelectRegistationEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfSelectRegistationEvent>;
        }));
    }

    protected processGetAllFilteredEventBibs(response: HttpResponseBase): Observable<ResponseModelOfListOfSelectRegistationEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfSelectRegistationEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllVipNumbers(eventId: number): Observable<ResponseModelOfListOfEventBibDTO> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/GetAllVipNumbers/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVipNumbers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVipNumbers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfListOfEventBibDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfListOfEventBibDTO>;
        }));
    }

    protected processGetAllVipNumbers(response: HttpResponseBase): Observable<ResponseModelOfListOfEventBibDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfListOfEventBibDTO.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bibCodeReservation(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBibCodeInfoModel> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/BibCodeReservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBibCodeReservation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBibCodeReservation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBibCodeInfoModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBibCodeInfoModel>;
        }));
    }

    protected processBibCodeReservation(response: HttpResponseBase): Observable<ResponseModelOfBibCodeInfoModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBibCodeInfoModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    joinEventAthletes(joinEventAthletes: JoinRegistationEventDTO): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/JoinEventAthletes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(joinEventAthletes);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processJoinEventAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processJoinEventAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processJoinEventAthletes(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOnRegistrationEvent(athleteEvent: AthleteEventDto): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/DeleteOnRegistrationEvent";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(athleteEvent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOnRegistrationEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOnRegistrationEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processDeleteOnRegistrationEvent(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateTeacher(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/UpdateTeacher";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTeacher(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTeacher(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateTeacher(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateERPsportTeamSquads(): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/UpdateERPsportTeamSquads";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateERPsportTeamSquads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateERPsportTeamSquads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processUpdateERPsportTeamSquads(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateREventOldBibCodes(eventId: number | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/UpdateREventOldBibCodes?";
        if (eventId === null)
            throw new Error("The parameter 'eventId' cannot be null.");
        else if (eventId !== undefined)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateREventOldBibCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateREventOldBibCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateREventOldBibCodes(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAthletesCadastr(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/UpdateAthletesCadastr";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAthletesCadastr(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAthletesCadastr(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processUpdateAthletesCadastr(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    exportExcelResultStatistic(eventIds: number[]): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/ExportExcelResultStatistic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportExcelResultStatistic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportExcelResultStatistic(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processExportExcelResultStatistic(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    emailResultsToAthletes(eventId: number | null | undefined, sendEmail: SendEmail): Observable<ResponseModelOfBoolean> {
        let url_ = this.baseUrl + "/api/marathon/SuperAdmin/EmailResultsToAthletes?";
        if (eventId !== undefined && eventId !== null)
            url_ += "eventId=" + encodeURIComponent("" + eventId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendEmail);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEmailResultsToAthletes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEmailResultsToAthletes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseModelOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseModelOfBoolean>;
        }));
    }

    protected processEmailResultsToAthletes(response: HttpResponseBase): Observable<ResponseModelOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseModelOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ResponseModelOfQueryResultOfAdvertisingDTO implements IResponseModelOfQueryResultOfAdvertisingDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfAdvertisingDTO;

    constructor(data?: IResponseModelOfQueryResultOfAdvertisingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfAdvertisingDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfAdvertisingDTO.fromJS(_data["result"]) : new QueryResultOfAdvertisingDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfAdvertisingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfAdvertisingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfAdvertisingDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfAdvertisingDTO;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 300,
    MovedPermanently = 301,
    Moved = 301,
    Found = 302,
    Redirect = 302,
    SeeOther = 303,
    RedirectMethod = 303,
    NotModified = 304,
    UseProxy = 305,
    Unused = 306,
    TemporaryRedirect = 307,
    RedirectKeepVerb = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthenticationRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    RequestEntityTooLarge = 413,
    RequestUriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    UpgradeRequired = 426,
    PreconditionRequired = 428,
    TooManyRequests = 429,
    RequestHeaderFieldsTooLarge = 431,
    UnavailableForLegalReasons = 451,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthenticationRequired = 511,
}

export class QueryResultOfAdvertisingDTO implements IQueryResultOfAdvertisingDTO {
    items!: AdvertisingDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfAdvertisingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AdvertisingDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfAdvertisingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfAdvertisingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfAdvertisingDTO {
    items: AdvertisingDTO[];
    totalItems: number;
}

export class AdvertisingDTO implements IAdvertisingDTO {
    id!: number;
    imageFileId!: string;
    titleInfo!: string;
    advertisingStatus!: AdvertisingStatus;

    constructor(data?: IAdvertisingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imageFileId = _data["imageFileId"];
            this.titleInfo = _data["titleInfo"];
            this.advertisingStatus = _data["advertisingStatus"];
        }
    }

    static fromJS(data: any): AdvertisingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AdvertisingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imageFileId"] = this.imageFileId;
        data["titleInfo"] = this.titleInfo;
        data["advertisingStatus"] = this.advertisingStatus;
        return data;
    }
}

export interface IAdvertisingDTO {
    id: number;
    imageFileId: string;
    titleInfo: string;
    advertisingStatus: AdvertisingStatus;
}

export enum AdvertisingStatus {
    Active = 10,
    NotActive = 20,
}

export class TableMetaData implements ITableMetaData {
    filters?: string | undefined;
    first!: number;
    rows!: number;
    sortField?: string | undefined;
    sortOrder!: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;

    constructor(data?: ITableMetaData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filters = _data["filters"];
            this.first = _data["first"];
            this.rows = _data["rows"];
            this.sortField = _data["sortField"];
            this.sortOrder = _data["sortOrder"];
            this.filterHandle = _data["filterHandle"];
            this.tagHandle = _data["tagHandle"];
            this.globalFilter = _data["globalFilter"];
        }
    }

    static fromJS(data: any): TableMetaData {
        data = typeof data === 'object' ? data : {};
        let result = new TableMetaData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filters"] = this.filters;
        data["first"] = this.first;
        data["rows"] = this.rows;
        data["sortField"] = this.sortField;
        data["sortOrder"] = this.sortOrder;
        data["filterHandle"] = this.filterHandle;
        data["tagHandle"] = this.tagHandle;
        data["globalFilter"] = this.globalFilter;
        return data;
    }
}

export interface ITableMetaData {
    filters?: string | undefined;
    first: number;
    rows: number;
    sortField?: string | undefined;
    sortOrder: number;
    filterHandle?: string | undefined;
    tagHandle?: string | undefined;
    globalFilter?: string | undefined;
}

export class ResponseModelOfAdvertisingDTO implements IResponseModelOfAdvertisingDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: AdvertisingDTO;

    constructor(data?: IResponseModelOfAdvertisingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new AdvertisingDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? AdvertisingDTO.fromJS(_data["result"]) : new AdvertisingDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfAdvertisingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfAdvertisingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfAdvertisingDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: AdvertisingDTO;
}

export class ResponseModelOfBoolean implements IResponseModelOfBoolean {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: boolean;

    constructor(data?: IResponseModelOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ResponseModelOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result;
        return data;
    }
}

export interface IResponseModelOfBoolean {
    statusCode: HttpStatusCode;
    error: string;
    result: boolean;
}

export class ApplicationRepaymentDTO implements IApplicationRepaymentDTO {
    id!: number;
    athletesId?: number | undefined;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    orderId?: number | undefined;
    text!: string;
    answerText?: string | undefined;
    answerAthletesId?: number | undefined;
    repaymentStatus?: RepaymentStatus | undefined;

    constructor(data?: IApplicationRepaymentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.athletesId = _data["athletesId"];
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.patronymic = _data["patronymic"];
            this.orderId = _data["orderId"];
            this.text = _data["text"];
            this.answerText = _data["answerText"];
            this.answerAthletesId = _data["answerAthletesId"];
            this.repaymentStatus = _data["repaymentStatus"];
        }
    }

    static fromJS(data: any): ApplicationRepaymentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRepaymentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["athletesId"] = this.athletesId;
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["patronymic"] = this.patronymic;
        data["orderId"] = this.orderId;
        data["text"] = this.text;
        data["answerText"] = this.answerText;
        data["answerAthletesId"] = this.answerAthletesId;
        data["repaymentStatus"] = this.repaymentStatus;
        return data;
    }
}

export interface IApplicationRepaymentDTO {
    id: number;
    athletesId?: number | undefined;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    orderId?: number | undefined;
    text: string;
    answerText?: string | undefined;
    answerAthletesId?: number | undefined;
    repaymentStatus?: RepaymentStatus | undefined;
}

export enum RepaymentStatus {
    NEW = 0,
    Accept = 5,
    Reject = 10,
}

export class ResponseModelOfQueryResultOfApplicationRepaymentDTO implements IResponseModelOfQueryResultOfApplicationRepaymentDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfApplicationRepaymentDTO;

    constructor(data?: IResponseModelOfQueryResultOfApplicationRepaymentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfApplicationRepaymentDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfApplicationRepaymentDTO.fromJS(_data["result"]) : new QueryResultOfApplicationRepaymentDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfApplicationRepaymentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfApplicationRepaymentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfApplicationRepaymentDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfApplicationRepaymentDTO;
}

export class QueryResultOfApplicationRepaymentDTO implements IQueryResultOfApplicationRepaymentDTO {
    items!: ApplicationRepaymentDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfApplicationRepaymentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationRepaymentDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfApplicationRepaymentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfApplicationRepaymentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfApplicationRepaymentDTO {
    items: ApplicationRepaymentDTO[];
    totalItems: number;
}

export class ApplicationAnswer implements IApplicationAnswer {
    applicationRepaymentId!: number;
    answerText?: string | undefined;

    constructor(data?: IApplicationAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationRepaymentId = _data["applicationRepaymentId"];
            this.answerText = _data["answerText"];
        }
    }

    static fromJS(data: any): ApplicationAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["applicationRepaymentId"] = this.applicationRepaymentId;
        data["answerText"] = this.answerText;
        return data;
    }
}

export interface IApplicationAnswer {
    applicationRepaymentId: number;
    answerText?: string | undefined;
}

export class ResponseModelOfAthletesClubDTO implements IResponseModelOfAthletesClubDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: AthletesClubDTO;

    constructor(data?: IResponseModelOfAthletesClubDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new AthletesClubDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? AthletesClubDTO.fromJS(_data["result"]) : new AthletesClubDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfAthletesClubDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfAthletesClubDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfAthletesClubDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: AthletesClubDTO;
}

export class AthletesClubDTO implements IAthletesClubDTO {
    clubId!: number;
    club?: ClubDTO | undefined;
    athletesId!: number;

    constructor(data?: IAthletesClubDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clubId = _data["clubId"];
            this.club = _data["club"] ? ClubDTO.fromJS(_data["club"]) : <any>undefined;
            this.athletesId = _data["athletesId"];
        }
    }

    static fromJS(data: any): AthletesClubDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AthletesClubDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clubId"] = this.clubId;
        data["club"] = this.club ? this.club.toJSON() : <any>undefined;
        data["athletesId"] = this.athletesId;
        return data;
    }
}

export interface IAthletesClubDTO {
    clubId: number;
    club?: ClubDTO | undefined;
    athletesId: number;
}

export class ClubDTO implements IClubDTO {
    id!: number;
    name!: string;
    athletesCount!: number;
    eventDate?: string | undefined;

    constructor(data?: IClubDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.athletesCount = _data["athletesCount"];
            this.eventDate = _data["eventDate"];
        }
    }

    static fromJS(data: any): ClubDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ClubDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["athletesCount"] = this.athletesCount;
        data["eventDate"] = this.eventDate;
        return data;
    }
}

export interface IClubDTO {
    id: number;
    name: string;
    athletesCount: number;
    eventDate?: string | undefined;
}

export class ResponseModelOfQueryResultOfAthletesDTO implements IResponseModelOfQueryResultOfAthletesDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfAthletesDTO;

    constructor(data?: IResponseModelOfQueryResultOfAthletesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfAthletesDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfAthletesDTO.fromJS(_data["result"]) : new QueryResultOfAthletesDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfAthletesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfAthletesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfAthletesDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfAthletesDTO;
}

export class QueryResultOfAthletesDTO implements IQueryResultOfAthletesDTO {
    items!: AthletesDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfAthletesDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AthletesDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfAthletesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfAthletesDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfAthletesDTO {
    items: AthletesDTO[];
    totalItems: number;
}

export abstract class EntityBase implements IEntityBase {
    id!: number;
    active!: boolean;
    createdBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedBy?: number | undefined;
    lastModifiedDate?: Date | undefined;
    comment?: string | undefined;

    constructor(data?: IEntityBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.active = _data["active"];
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): EntityBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["active"] = this.active;
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IEntityBase {
    id: number;
    active: boolean;
    createdBy?: number | undefined;
    createdDate?: Date | undefined;
    lastModifiedBy?: number | undefined;
    lastModifiedDate?: Date | undefined;
    comment?: string | undefined;
}

export class GCPBaseModel extends EntityBase implements IGCPBaseModel {
    surname!: string;
    name!: string;
    patronymic?: string | undefined;
    fullName!: string;
    pinfl?: string | undefined;
    passportSeria?: string | undefined;
    passportNumber?: string | undefined;
    passportGiven?: string | undefined;
    passportDateBegin?: Date | undefined;
    passportDateEnd?: Date | undefined;
    birthDate!: Date;
    spNationId?: number | undefined;
    spCitizenshipId?: number | undefined;
    citizenship?: string | undefined;
    spCountryId?: number | undefined;
    spRegionId?: number | undefined;
    spDistrictId?: number | undefined;
    address?: string | undefined;
    spSexId?: number | undefined;
    addressBirth?: string | undefined;
    phoneMain!: string;
    phoneAdditional?: string | undefined;
    eMail!: string;
    eMailAdditional?: string | undefined;
    isFromGCP!: boolean;

    constructor(data?: IGCPBaseModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.patronymic = _data["patronymic"];
            this.fullName = _data["fullName"];
            this.pinfl = _data["pinfl"];
            this.passportSeria = _data["passportSeria"];
            this.passportNumber = _data["passportNumber"];
            this.passportGiven = _data["passportGiven"];
            this.passportDateBegin = _data["passportDateBegin"] ? new Date(_data["passportDateBegin"].toString()) : <any>undefined;
            this.passportDateEnd = _data["passportDateEnd"] ? new Date(_data["passportDateEnd"].toString()) : <any>undefined;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.spNationId = _data["spNationId"];
            this.spCitizenshipId = _data["spCitizenshipId"];
            this.citizenship = _data["citizenship"];
            this.spCountryId = _data["spCountryId"];
            this.spRegionId = _data["spRegionId"];
            this.spDistrictId = _data["spDistrictId"];
            this.address = _data["address"];
            this.spSexId = _data["spSexId"];
            this.addressBirth = _data["addressBirth"];
            this.phoneMain = _data["phoneMain"];
            this.phoneAdditional = _data["phoneAdditional"];
            this.eMail = _data["eMail"];
            this.eMailAdditional = _data["eMailAdditional"];
            this.isFromGCP = _data["isFromGCP"];
        }
    }

    static override fromJS(data: any): GCPBaseModel {
        data = typeof data === 'object' ? data : {};
        let result = new GCPBaseModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["patronymic"] = this.patronymic;
        data["fullName"] = this.fullName;
        data["pinfl"] = this.pinfl;
        data["passportSeria"] = this.passportSeria;
        data["passportNumber"] = this.passportNumber;
        data["passportGiven"] = this.passportGiven;
        data["passportDateBegin"] = this.passportDateBegin ? this.passportDateBegin.toISOString() : <any>undefined;
        data["passportDateEnd"] = this.passportDateEnd ? this.passportDateEnd.toISOString() : <any>undefined;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["spNationId"] = this.spNationId;
        data["spCitizenshipId"] = this.spCitizenshipId;
        data["citizenship"] = this.citizenship;
        data["spCountryId"] = this.spCountryId;
        data["spRegionId"] = this.spRegionId;
        data["spDistrictId"] = this.spDistrictId;
        data["address"] = this.address;
        data["spSexId"] = this.spSexId;
        data["addressBirth"] = this.addressBirth;
        data["phoneMain"] = this.phoneMain;
        data["phoneAdditional"] = this.phoneAdditional;
        data["eMail"] = this.eMail;
        data["eMailAdditional"] = this.eMailAdditional;
        data["isFromGCP"] = this.isFromGCP;
        super.toJSON(data);
        return data;
    }
}

export interface IGCPBaseModel extends IEntityBase {
    surname: string;
    name: string;
    patronymic?: string | undefined;
    fullName: string;
    pinfl?: string | undefined;
    passportSeria?: string | undefined;
    passportNumber?: string | undefined;
    passportGiven?: string | undefined;
    passportDateBegin?: Date | undefined;
    passportDateEnd?: Date | undefined;
    birthDate: Date;
    spNationId?: number | undefined;
    spCitizenshipId?: number | undefined;
    citizenship?: string | undefined;
    spCountryId?: number | undefined;
    spRegionId?: number | undefined;
    spDistrictId?: number | undefined;
    address?: string | undefined;
    spSexId?: number | undefined;
    addressBirth?: string | undefined;
    phoneMain: string;
    phoneAdditional?: string | undefined;
    eMail: string;
    eMailAdditional?: string | undefined;
    isFromGCP: boolean;
}

export class GCPBaseModelDTO extends GCPBaseModel implements IGCPBaseModelDTO {
    studentDTO?: StudentDTO | undefined;
    erPsportDTO?: ERPsportDTO | undefined;

    constructor(data?: IGCPBaseModelDTO) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.studentDTO = _data["studentDTO"] ? StudentDTO.fromJS(_data["studentDTO"]) : <any>undefined;
            this.erPsportDTO = _data["erPsportDTO"] ? ERPsportDTO.fromJS(_data["erPsportDTO"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): GCPBaseModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new GCPBaseModelDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentDTO"] = this.studentDTO ? this.studentDTO.toJSON() : <any>undefined;
        data["erPsportDTO"] = this.erPsportDTO ? this.erPsportDTO.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IGCPBaseModelDTO extends IGCPBaseModel {
    studentDTO?: StudentDTO | undefined;
    erPsportDTO?: ERPsportDTO | undefined;
}

export class AthletesDTO extends GCPBaseModelDTO implements IAthletesDTO {
    imageFileGuid?: string | undefined;
    applicationUserId?: string | undefined;
    spUserTypeId?: number | undefined;
    isForeign!: boolean;
    isPassportUzb!: boolean;
    isFakePINFL!: boolean;
    spRegionStr?: string | undefined;
    registeredStatus?: string | undefined;
    student?: StudentModel | undefined;
    organization?: OrganizationDTO | undefined;
    athleteSportInfos?: AthleteSportInfo[] | undefined;

    constructor(data?: IAthletesDTO) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.imageFileGuid = _data["imageFileGuid"];
            this.applicationUserId = _data["applicationUserId"];
            this.spUserTypeId = _data["spUserTypeId"];
            this.isForeign = _data["isForeign"];
            this.isPassportUzb = _data["isPassportUzb"];
            this.isFakePINFL = _data["isFakePINFL"];
            this.spRegionStr = _data["spRegionStr"];
            this.registeredStatus = _data["registeredStatus"];
            this.student = _data["student"] ? StudentModel.fromJS(_data["student"]) : <any>undefined;
            this.organization = _data["organization"] ? OrganizationDTO.fromJS(_data["organization"]) : <any>undefined;
            if (Array.isArray(_data["athleteSportInfos"])) {
                this.athleteSportInfos = [] as any;
                for (let item of _data["athleteSportInfos"])
                    this.athleteSportInfos!.push(AthleteSportInfo.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): AthletesDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AthletesDTO();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageFileGuid"] = this.imageFileGuid;
        data["applicationUserId"] = this.applicationUserId;
        data["spUserTypeId"] = this.spUserTypeId;
        data["isForeign"] = this.isForeign;
        data["isPassportUzb"] = this.isPassportUzb;
        data["isFakePINFL"] = this.isFakePINFL;
        data["spRegionStr"] = this.spRegionStr;
        data["registeredStatus"] = this.registeredStatus;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        if (Array.isArray(this.athleteSportInfos)) {
            data["athleteSportInfos"] = [];
            for (let item of this.athleteSportInfos)
                data["athleteSportInfos"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IAthletesDTO extends IGCPBaseModelDTO {
    imageFileGuid?: string | undefined;
    applicationUserId?: string | undefined;
    spUserTypeId?: number | undefined;
    isForeign: boolean;
    isPassportUzb: boolean;
    isFakePINFL: boolean;
    spRegionStr?: string | undefined;
    registeredStatus?: string | undefined;
    student?: StudentModel | undefined;
    organization?: OrganizationDTO | undefined;
    athleteSportInfos?: AthleteSportInfo[] | undefined;
}

export class StudentModel implements IStudentModel {
    id!: string;
    pinfl!: string;
    serial_number!: string;
    firstname!: string;
    lastname!: string;
    fathername!: string;
    birthday!: string;
    gender_code!: string;
    gender_name!: string;
    nationality_code!: string;
    nationality_name!: string;
    citizenship_code!: string;
    citizenship_name!: string;
    education_type_code!: string;
    education_type_name!: string;
    education_form_code!: string;
    education_form_name!: string;
    payment_type_code!: string;
    payment_type_name!: string;
    university_code!: string;
    university_name!: string;
    university_ownership_code!: string;
    university_ownership_name!: string;
    university_type_code!: string;
    university_type_name!: string;
    faculty_code!: string;
    faculty_name!: string;
    speciality_id!: string;
    speciality_code!: string;
    speciality_name!: string;
    course_code!: string;
    course!: string;
    country_code!: string;
    country_name!: string;
    soato_code!: string;
    region!: string;
    district!: string;
    address!: string;
    regionCurrent!: string;
    districtCurrent!: string;
    address_current!: string;
    accomodation_code!: string;
    accomodation_name!: string;
    social_category_code!: string;
    social_category_name!: string;
    education_year!: string;
    education_language_code!: string;
    education_language_name!: string;
    group_id!: string;
    group_name!: string;
    status_code!: string;
    status_name!: string;
    student_type_code!: string;
    student_type_name!: string;

    constructor(data?: IStudentModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pinfl = _data["pinfl"];
            this.serial_number = _data["serial_number"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.fathername = _data["fathername"];
            this.birthday = _data["birthday"];
            this.gender_code = _data["gender_code"];
            this.gender_name = _data["gender_name"];
            this.nationality_code = _data["nationality_code"];
            this.nationality_name = _data["nationality_name"];
            this.citizenship_code = _data["citizenship_code"];
            this.citizenship_name = _data["citizenship_name"];
            this.education_type_code = _data["education_type_code"];
            this.education_type_name = _data["education_type_name"];
            this.education_form_code = _data["education_form_code"];
            this.education_form_name = _data["education_form_name"];
            this.payment_type_code = _data["payment_type_code"];
            this.payment_type_name = _data["payment_type_name"];
            this.university_code = _data["university_code"];
            this.university_name = _data["university_name"];
            this.university_ownership_code = _data["university_ownership_code"];
            this.university_ownership_name = _data["university_ownership_name"];
            this.university_type_code = _data["university_type_code"];
            this.university_type_name = _data["university_type_name"];
            this.faculty_code = _data["faculty_code"];
            this.faculty_name = _data["faculty_name"];
            this.speciality_id = _data["speciality_id"];
            this.speciality_code = _data["speciality_code"];
            this.speciality_name = _data["speciality_name"];
            this.course_code = _data["course_code"];
            this.course = _data["course"];
            this.country_code = _data["country_code"];
            this.country_name = _data["country_name"];
            this.soato_code = _data["soato_code"];
            this.region = _data["region"];
            this.district = _data["district"];
            this.address = _data["address"];
            this.regionCurrent = _data["regionCurrent"];
            this.districtCurrent = _data["districtCurrent"];
            this.address_current = _data["address_current"];
            this.accomodation_code = _data["accomodation_code"];
            this.accomodation_name = _data["accomodation_name"];
            this.social_category_code = _data["social_category_code"];
            this.social_category_name = _data["social_category_name"];
            this.education_year = _data["education_year"];
            this.education_language_code = _data["education_language_code"];
            this.education_language_name = _data["education_language_name"];
            this.group_id = _data["group_id"];
            this.group_name = _data["group_name"];
            this.status_code = _data["status_code"];
            this.status_name = _data["status_name"];
            this.student_type_code = _data["student_type_code"];
            this.student_type_name = _data["student_type_name"];
        }
    }

    static fromJS(data: any): StudentModel {
        data = typeof data === 'object' ? data : {};
        let result = new StudentModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pinfl"] = this.pinfl;
        data["serial_number"] = this.serial_number;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["fathername"] = this.fathername;
        data["birthday"] = this.birthday;
        data["gender_code"] = this.gender_code;
        data["gender_name"] = this.gender_name;
        data["nationality_code"] = this.nationality_code;
        data["nationality_name"] = this.nationality_name;
        data["citizenship_code"] = this.citizenship_code;
        data["citizenship_name"] = this.citizenship_name;
        data["education_type_code"] = this.education_type_code;
        data["education_type_name"] = this.education_type_name;
        data["education_form_code"] = this.education_form_code;
        data["education_form_name"] = this.education_form_name;
        data["payment_type_code"] = this.payment_type_code;
        data["payment_type_name"] = this.payment_type_name;
        data["university_code"] = this.university_code;
        data["university_name"] = this.university_name;
        data["university_ownership_code"] = this.university_ownership_code;
        data["university_ownership_name"] = this.university_ownership_name;
        data["university_type_code"] = this.university_type_code;
        data["university_type_name"] = this.university_type_name;
        data["faculty_code"] = this.faculty_code;
        data["faculty_name"] = this.faculty_name;
        data["speciality_id"] = this.speciality_id;
        data["speciality_code"] = this.speciality_code;
        data["speciality_name"] = this.speciality_name;
        data["course_code"] = this.course_code;
        data["course"] = this.course;
        data["country_code"] = this.country_code;
        data["country_name"] = this.country_name;
        data["soato_code"] = this.soato_code;
        data["region"] = this.region;
        data["district"] = this.district;
        data["address"] = this.address;
        data["regionCurrent"] = this.regionCurrent;
        data["districtCurrent"] = this.districtCurrent;
        data["address_current"] = this.address_current;
        data["accomodation_code"] = this.accomodation_code;
        data["accomodation_name"] = this.accomodation_name;
        data["social_category_code"] = this.social_category_code;
        data["social_category_name"] = this.social_category_name;
        data["education_year"] = this.education_year;
        data["education_language_code"] = this.education_language_code;
        data["education_language_name"] = this.education_language_name;
        data["group_id"] = this.group_id;
        data["group_name"] = this.group_name;
        data["status_code"] = this.status_code;
        data["status_name"] = this.status_name;
        data["student_type_code"] = this.student_type_code;
        data["student_type_name"] = this.student_type_name;
        return data;
    }
}

export interface IStudentModel {
    id: string;
    pinfl: string;
    serial_number: string;
    firstname: string;
    lastname: string;
    fathername: string;
    birthday: string;
    gender_code: string;
    gender_name: string;
    nationality_code: string;
    nationality_name: string;
    citizenship_code: string;
    citizenship_name: string;
    education_type_code: string;
    education_type_name: string;
    education_form_code: string;
    education_form_name: string;
    payment_type_code: string;
    payment_type_name: string;
    university_code: string;
    university_name: string;
    university_ownership_code: string;
    university_ownership_name: string;
    university_type_code: string;
    university_type_name: string;
    faculty_code: string;
    faculty_name: string;
    speciality_id: string;
    speciality_code: string;
    speciality_name: string;
    course_code: string;
    course: string;
    country_code: string;
    country_name: string;
    soato_code: string;
    region: string;
    district: string;
    address: string;
    regionCurrent: string;
    districtCurrent: string;
    address_current: string;
    accomodation_code: string;
    accomodation_name: string;
    social_category_code: string;
    social_category_name: string;
    education_year: string;
    education_language_code: string;
    education_language_name: string;
    group_id: string;
    group_name: string;
    status_code: string;
    status_name: string;
    student_type_code: string;
    student_type_name: string;
}

export class OrganizationDTO implements IOrganizationDTO {
    id!: number;
    name!: string;
    spOrganizationTypeId!: number;

    constructor(data?: IOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.spOrganizationTypeId = _data["spOrganizationTypeId"];
        }
    }

    static fromJS(data: any): OrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["spOrganizationTypeId"] = this.spOrganizationTypeId;
        return data;
    }
}

export interface IOrganizationDTO {
    id: number;
    name: string;
    spOrganizationTypeId: number;
}

export class AthleteSportInfo implements IAthleteSportInfo {
    responseid!: string;
    sporttitledocumentid!: number;
    personid!: number;
    personname!: string;
    pinfl!: string;
    sporttypeclassifierid!: number;
    sporttypeclassifiername?: string | undefined;
    sporttitleid!: number;
    sporttitlename?: string | undefined;
    highereduclassifiername?: string | undefined;
    highereduclassifiercode?: string | undefined;

    constructor(data?: IAthleteSportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseid = _data["responseid"];
            this.sporttitledocumentid = _data["sporttitledocumentid"];
            this.personid = _data["personid"];
            this.personname = _data["personname"];
            this.pinfl = _data["pinfl"];
            this.sporttypeclassifierid = _data["sporttypeclassifierid"];
            this.sporttypeclassifiername = _data["sporttypeclassifiername"];
            this.sporttitleid = _data["sporttitleid"];
            this.sporttitlename = _data["sporttitlename"];
            this.highereduclassifiername = _data["highereduclassifiername"];
            this.highereduclassifiercode = _data["highereduclassifiercode"];
        }
    }

    static fromJS(data: any): AthleteSportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AthleteSportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseid"] = this.responseid;
        data["sporttitledocumentid"] = this.sporttitledocumentid;
        data["personid"] = this.personid;
        data["personname"] = this.personname;
        data["pinfl"] = this.pinfl;
        data["sporttypeclassifierid"] = this.sporttypeclassifierid;
        data["sporttypeclassifiername"] = this.sporttypeclassifiername;
        data["sporttitleid"] = this.sporttitleid;
        data["sporttitlename"] = this.sporttitlename;
        data["highereduclassifiername"] = this.highereduclassifiername;
        data["highereduclassifiercode"] = this.highereduclassifiercode;
        return data;
    }
}

export interface IAthleteSportInfo {
    responseid: string;
    sporttitledocumentid: number;
    personid: number;
    personname: string;
    pinfl: string;
    sporttypeclassifierid: number;
    sporttypeclassifiername?: string | undefined;
    sporttitleid: number;
    sporttitlename?: string | undefined;
    highereduclassifiername?: string | undefined;
    highereduclassifiercode?: string | undefined;
}

export class StudentDTO implements IStudentDTO {
    hemisId?: number | undefined;
    cource?: string | undefined;
    universityName?: string | undefined;
    educationTypeName?: string | undefined;

    constructor(data?: IStudentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hemisId = _data["hemisId"];
            this.cource = _data["cource"];
            this.universityName = _data["universityName"];
            this.educationTypeName = _data["educationTypeName"];
        }
    }

    static fromJS(data: any): StudentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hemisId"] = this.hemisId;
        data["cource"] = this.cource;
        data["universityName"] = this.universityName;
        data["educationTypeName"] = this.educationTypeName;
        return data;
    }
}

export interface IStudentDTO {
    hemisId?: number | undefined;
    cource?: string | undefined;
    universityName?: string | undefined;
    educationTypeName?: string | undefined;
}

export class ERPsportDTO implements IERPsportDTO {
    sportTitleName?: string | undefined;
    sportTypeClassifiername?: string | undefined;

    constructor(data?: IERPsportDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sportTitleName = _data["sportTitleName"];
            this.sportTypeClassifiername = _data["sportTypeClassifiername"];
        }
    }

    static fromJS(data: any): ERPsportDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ERPsportDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sportTitleName"] = this.sportTitleName;
        data["sportTypeClassifiername"] = this.sportTypeClassifiername;
        return data;
    }
}

export interface IERPsportDTO {
    sportTitleName?: string | undefined;
    sportTypeClassifiername?: string | undefined;
}

export class SelectAthlete implements ISelectAthlete {
    athletesId!: number;
    countAthletes!: number;
    organizationId!: number;
    organizationName!: string;
    organizationType!: string;

    constructor(data?: ISelectAthlete) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.athletesId = _data["athletesId"];
            this.countAthletes = _data["countAthletes"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.organizationType = _data["organizationType"];
        }
    }

    static fromJS(data: any): SelectAthlete {
        data = typeof data === 'object' ? data : {};
        let result = new SelectAthlete();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["athletesId"] = this.athletesId;
        data["countAthletes"] = this.countAthletes;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["organizationType"] = this.organizationType;
        return data;
    }
}

export interface ISelectAthlete {
    athletesId: number;
    countAthletes: number;
    organizationId: number;
    organizationName: string;
    organizationType: string;
}

export class ExcelTemplateDTO implements IExcelTemplateDTO {
    id!: number;
    engFileId!: string;
    ruFileId!: string;
    uzFileId!: string;

    constructor(data?: IExcelTemplateDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.engFileId = _data["engFileId"];
            this.ruFileId = _data["ruFileId"];
            this.uzFileId = _data["uzFileId"];
        }
    }

    static fromJS(data: any): ExcelTemplateDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExcelTemplateDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["engFileId"] = this.engFileId;
        data["ruFileId"] = this.ruFileId;
        data["uzFileId"] = this.uzFileId;
        return data;
    }
}

export interface IExcelTemplateDTO {
    id: number;
    engFileId: string;
    ruFileId: string;
    uzFileId: string;
}

export class ResponseModelOfInteger implements IResponseModelOfInteger {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: number;

    constructor(data?: IResponseModelOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ResponseModelOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result;
        return data;
    }
}

export interface IResponseModelOfInteger {
    statusCode: HttpStatusCode;
    error: string;
    result: number;
}

export class UpdateUserModel implements IUpdateUserModel {
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IUpdateUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): UpdateUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IUpdateUserModel {
    password?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
}

export class ResponseModelOfQueryResultOfClubDTO implements IResponseModelOfQueryResultOfClubDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfClubDTO;

    constructor(data?: IResponseModelOfQueryResultOfClubDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfClubDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfClubDTO.fromJS(_data["result"]) : new QueryResultOfClubDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfClubDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfClubDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfClubDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfClubDTO;
}

export class QueryResultOfClubDTO implements IQueryResultOfClubDTO {
    items!: ClubDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfClubDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ClubDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfClubDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfClubDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfClubDTO {
    items: ClubDTO[];
    totalItems: number;
}

export class ResponseModelOfClubDTO implements IResponseModelOfClubDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: ClubDTO;

    constructor(data?: IResponseModelOfClubDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new ClubDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? ClubDTO.fromJS(_data["result"]) : new ClubDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfClubDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfClubDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfClubDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: ClubDTO;
}

export class EventBoxDTO implements IEventBoxDTO {
    id!: number;
    nameUZ!: string;
    nameRU?: string | undefined;
    nameEN?: string | undefined;
    descriptionUZ!: string;
    descriptionRU?: string | undefined;
    descriptionEN?: string | undefined;
    location!: string;
    addressUZ!: string;
    addressRU?: string | undefined;
    addressEN?: string | undefined;
    spEventCategoryId?: number | undefined;
    athleteMaxLimit?: number | undefined;
    eventDate!: string;
    startRegstrDate!: string;
    status!: EventStatus;
    endRegstrDate!: string;
    imageFileId!: string;
    mapFileId!: string;
    offerFileId!: string;
    countEventAthletes?: number | undefined;
    myRegistrationEvent?: MyRegistrationEvent | undefined;
    spRegionId!: number;
    events?: EventDTO[] | undefined;
    eventBoxCategories!: number[];

    constructor(data?: IEventBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventBoxCategories = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameUZ = _data["nameUZ"];
            this.nameRU = _data["nameRU"];
            this.nameEN = _data["nameEN"];
            this.descriptionUZ = _data["descriptionUZ"];
            this.descriptionRU = _data["descriptionRU"];
            this.descriptionEN = _data["descriptionEN"];
            this.location = _data["location"];
            this.addressUZ = _data["addressUZ"];
            this.addressRU = _data["addressRU"];
            this.addressEN = _data["addressEN"];
            this.spEventCategoryId = _data["spEventCategoryId"];
            this.athleteMaxLimit = _data["athleteMaxLimit"];
            this.eventDate = _data["eventDate"];
            this.startRegstrDate = _data["startRegstrDate"];
            this.status = _data["status"];
            this.endRegstrDate = _data["endRegstrDate"];
            this.imageFileId = _data["imageFileId"];
            this.mapFileId = _data["mapFileId"];
            this.offerFileId = _data["offerFileId"];
            this.countEventAthletes = _data["countEventAthletes"];
            this.myRegistrationEvent = _data["myRegistrationEvent"] ? MyRegistrationEvent.fromJS(_data["myRegistrationEvent"]) : <any>undefined;
            this.spRegionId = _data["spRegionId"];
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(EventDTO.fromJS(item));
            }
            if (Array.isArray(_data["eventBoxCategories"])) {
                this.eventBoxCategories = [] as any;
                for (let item of _data["eventBoxCategories"])
                    this.eventBoxCategories!.push(item);
            }
        }
    }

    static fromJS(data: any): EventBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameUZ"] = this.nameUZ;
        data["nameRU"] = this.nameRU;
        data["nameEN"] = this.nameEN;
        data["descriptionUZ"] = this.descriptionUZ;
        data["descriptionRU"] = this.descriptionRU;
        data["descriptionEN"] = this.descriptionEN;
        data["location"] = this.location;
        data["addressUZ"] = this.addressUZ;
        data["addressRU"] = this.addressRU;
        data["addressEN"] = this.addressEN;
        data["spEventCategoryId"] = this.spEventCategoryId;
        data["athleteMaxLimit"] = this.athleteMaxLimit;
        data["eventDate"] = this.eventDate;
        data["startRegstrDate"] = this.startRegstrDate;
        data["status"] = this.status;
        data["endRegstrDate"] = this.endRegstrDate;
        data["imageFileId"] = this.imageFileId;
        data["mapFileId"] = this.mapFileId;
        data["offerFileId"] = this.offerFileId;
        data["countEventAthletes"] = this.countEventAthletes;
        data["myRegistrationEvent"] = this.myRegistrationEvent ? this.myRegistrationEvent.toJSON() : <any>undefined;
        data["spRegionId"] = this.spRegionId;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        if (Array.isArray(this.eventBoxCategories)) {
            data["eventBoxCategories"] = [];
            for (let item of this.eventBoxCategories)
                data["eventBoxCategories"].push(item);
        }
        return data;
    }
}

export interface IEventBoxDTO {
    id: number;
    nameUZ: string;
    nameRU?: string | undefined;
    nameEN?: string | undefined;
    descriptionUZ: string;
    descriptionRU?: string | undefined;
    descriptionEN?: string | undefined;
    location: string;
    addressUZ: string;
    addressRU?: string | undefined;
    addressEN?: string | undefined;
    spEventCategoryId?: number | undefined;
    athleteMaxLimit?: number | undefined;
    eventDate: string;
    startRegstrDate: string;
    status: EventStatus;
    endRegstrDate: string;
    imageFileId: string;
    mapFileId: string;
    offerFileId: string;
    countEventAthletes?: number | undefined;
    myRegistrationEvent?: MyRegistrationEvent | undefined;
    spRegionId: number;
    events?: EventDTO[] | undefined;
    eventBoxCategories: number[];
}

export enum EventStatus {
    Active = 0,
    ParticipantsFull = 1,
    Finish = 3,
    Results = 5,
}

export class MyRegistrationEvent implements IMyRegistrationEvent {
    bibNumber?: number | undefined;
    bibCodeAmount!: number;
    eventAmount!: number;
    eventId?: number | undefined;
    status?: Status | undefined;
    orderId?: number | undefined;
    allSum!: number;
    isPrice!: boolean;
    payedDateTime?: Date | undefined;
    repaymentStatus?: RepaymentStatus | undefined;
    smenaId!: number;
    eventPacketId!: number;
    smenaName?: string | undefined;

    constructor(data?: IMyRegistrationEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bibNumber = _data["bibNumber"];
            this.bibCodeAmount = _data["bibCodeAmount"];
            this.eventAmount = _data["eventAmount"];
            this.eventId = _data["eventId"];
            this.status = _data["status"];
            this.orderId = _data["orderId"];
            this.allSum = _data["allSum"];
            this.isPrice = _data["isPrice"];
            this.payedDateTime = _data["payedDateTime"] ? new Date(_data["payedDateTime"].toString()) : <any>undefined;
            this.repaymentStatus = _data["repaymentStatus"];
            this.smenaId = _data["smenaId"];
            this.eventPacketId = _data["eventPacketId"];
            this.smenaName = _data["smenaName"];
        }
    }

    static fromJS(data: any): MyRegistrationEvent {
        data = typeof data === 'object' ? data : {};
        let result = new MyRegistrationEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bibNumber"] = this.bibNumber;
        data["bibCodeAmount"] = this.bibCodeAmount;
        data["eventAmount"] = this.eventAmount;
        data["eventId"] = this.eventId;
        data["status"] = this.status;
        data["orderId"] = this.orderId;
        data["allSum"] = this.allSum;
        data["isPrice"] = this.isPrice;
        data["payedDateTime"] = this.payedDateTime ? this.payedDateTime.toISOString() : <any>undefined;
        data["repaymentStatus"] = this.repaymentStatus;
        data["smenaId"] = this.smenaId;
        data["eventPacketId"] = this.eventPacketId;
        data["smenaName"] = this.smenaName;
        return data;
    }
}

export interface IMyRegistrationEvent {
    bibNumber?: number | undefined;
    bibCodeAmount: number;
    eventAmount: number;
    eventId?: number | undefined;
    status?: Status | undefined;
    orderId?: number | undefined;
    allSum: number;
    isPrice: boolean;
    payedDateTime?: Date | undefined;
    repaymentStatus?: RepaymentStatus | undefined;
    smenaId: number;
    eventPacketId: number;
    smenaName?: string | undefined;
}

export enum Status {
    InProgrees = 0,
    Rejected = 2,
    Inserted = 3,
    Registered = 5,
    Canceled = 8,
    Completed = 10,
}

export class EventDTO implements IEventDTO {
    id!: number;
    titleUZ?: string | undefined;
    titleEN?: string | undefined;
    titleRU?: string | undefined;
    startTime?: string | undefined;
    raceDistanceUZ!: string;
    raceDistanceEN!: string;
    raceDistanceRU!: string;
    spRaceDistanceId!: number;
    spEventCategoryId?: number | undefined;
    uzsPrice!: number;
    uzsPriceOne!: number;
    uzsPriceDateOne?: string | undefined;
    uzsPriceTwo!: number;
    uzsPriceDateTwo?: string | undefined;
    platinumNumberPrice?: number | undefined;
    goldenNumberPrice?: number | undefined;
    silverNumberPrice?: number | undefined;
    usdPrice?: number | undefined;
    uzsPriceCalculated?: number | undefined;
    status!: EventStatus;
    isPrice!: boolean;
    isResult!: boolean;
    isPublishFilterFormula!: boolean;
    ageFrom?: number | undefined;
    toAgeYears?: number | undefined;
    bibFrom!: number;
    bibUntil!: number;
    participants?: number | undefined;
    smenaParticipants?: number | undefined;
    eventBoxId!: number;
    eventBibs!: EventBibDTO[];
    smenas!: SmenaDTO[];
    packets!: EventPacketDTO[];
    eventCategories!: number[];
    eventGenderAgeCategories?: EventGenderAgeCategoryDTO[] | undefined;

    constructor(data?: IEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.eventBibs = [];
            this.smenas = [];
            this.packets = [];
            this.eventCategories = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleUZ = _data["titleUZ"];
            this.titleEN = _data["titleEN"];
            this.titleRU = _data["titleRU"];
            this.startTime = _data["startTime"];
            this.raceDistanceUZ = _data["raceDistanceUZ"];
            this.raceDistanceEN = _data["raceDistanceEN"];
            this.raceDistanceRU = _data["raceDistanceRU"];
            this.spRaceDistanceId = _data["spRaceDistanceId"];
            this.spEventCategoryId = _data["spEventCategoryId"];
            this.uzsPrice = _data["uzsPrice"];
            this.uzsPriceOne = _data["uzsPriceOne"];
            this.uzsPriceDateOne = _data["uzsPriceDateOne"];
            this.uzsPriceTwo = _data["uzsPriceTwo"];
            this.uzsPriceDateTwo = _data["uzsPriceDateTwo"];
            this.platinumNumberPrice = _data["platinumNumberPrice"];
            this.goldenNumberPrice = _data["goldenNumberPrice"];
            this.silverNumberPrice = _data["silverNumberPrice"];
            this.usdPrice = _data["usdPrice"];
            this.uzsPriceCalculated = _data["uzsPriceCalculated"];
            this.status = _data["status"];
            this.isPrice = _data["isPrice"];
            this.isResult = _data["isResult"];
            this.isPublishFilterFormula = _data["isPublishFilterFormula"];
            this.ageFrom = _data["ageFrom"];
            this.toAgeYears = _data["toAgeYears"];
            this.bibFrom = _data["bibFrom"];
            this.bibUntil = _data["bibUntil"];
            this.participants = _data["participants"];
            this.smenaParticipants = _data["smenaParticipants"];
            this.eventBoxId = _data["eventBoxId"];
            if (Array.isArray(_data["eventBibs"])) {
                this.eventBibs = [] as any;
                for (let item of _data["eventBibs"])
                    this.eventBibs!.push(EventBibDTO.fromJS(item));
            }
            if (Array.isArray(_data["smenas"])) {
                this.smenas = [] as any;
                for (let item of _data["smenas"])
                    this.smenas!.push(SmenaDTO.fromJS(item));
            }
            if (Array.isArray(_data["packets"])) {
                this.packets = [] as any;
                for (let item of _data["packets"])
                    this.packets!.push(EventPacketDTO.fromJS(item));
            }
            if (Array.isArray(_data["eventCategories"])) {
                this.eventCategories = [] as any;
                for (let item of _data["eventCategories"])
                    this.eventCategories!.push(item);
            }
            if (Array.isArray(_data["eventGenderAgeCategories"])) {
                this.eventGenderAgeCategories = [] as any;
                for (let item of _data["eventGenderAgeCategories"])
                    this.eventGenderAgeCategories!.push(EventGenderAgeCategoryDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleUZ"] = this.titleUZ;
        data["titleEN"] = this.titleEN;
        data["titleRU"] = this.titleRU;
        data["startTime"] = this.startTime;
        data["raceDistanceUZ"] = this.raceDistanceUZ;
        data["raceDistanceEN"] = this.raceDistanceEN;
        data["raceDistanceRU"] = this.raceDistanceRU;
        data["spRaceDistanceId"] = this.spRaceDistanceId;
        data["spEventCategoryId"] = this.spEventCategoryId;
        data["uzsPrice"] = this.uzsPrice;
        data["uzsPriceOne"] = this.uzsPriceOne;
        data["uzsPriceDateOne"] = this.uzsPriceDateOne;
        data["uzsPriceTwo"] = this.uzsPriceTwo;
        data["uzsPriceDateTwo"] = this.uzsPriceDateTwo;
        data["platinumNumberPrice"] = this.platinumNumberPrice;
        data["goldenNumberPrice"] = this.goldenNumberPrice;
        data["silverNumberPrice"] = this.silverNumberPrice;
        data["usdPrice"] = this.usdPrice;
        data["uzsPriceCalculated"] = this.uzsPriceCalculated;
        data["status"] = this.status;
        data["isPrice"] = this.isPrice;
        data["isResult"] = this.isResult;
        data["isPublishFilterFormula"] = this.isPublishFilterFormula;
        data["ageFrom"] = this.ageFrom;
        data["toAgeYears"] = this.toAgeYears;
        data["bibFrom"] = this.bibFrom;
        data["bibUntil"] = this.bibUntil;
        data["participants"] = this.participants;
        data["smenaParticipants"] = this.smenaParticipants;
        data["eventBoxId"] = this.eventBoxId;
        if (Array.isArray(this.eventBibs)) {
            data["eventBibs"] = [];
            for (let item of this.eventBibs)
                data["eventBibs"].push(item.toJSON());
        }
        if (Array.isArray(this.smenas)) {
            data["smenas"] = [];
            for (let item of this.smenas)
                data["smenas"].push(item.toJSON());
        }
        if (Array.isArray(this.packets)) {
            data["packets"] = [];
            for (let item of this.packets)
                data["packets"].push(item.toJSON());
        }
        if (Array.isArray(this.eventCategories)) {
            data["eventCategories"] = [];
            for (let item of this.eventCategories)
                data["eventCategories"].push(item);
        }
        if (Array.isArray(this.eventGenderAgeCategories)) {
            data["eventGenderAgeCategories"] = [];
            for (let item of this.eventGenderAgeCategories)
                data["eventGenderAgeCategories"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEventDTO {
    id: number;
    titleUZ?: string | undefined;
    titleEN?: string | undefined;
    titleRU?: string | undefined;
    startTime?: string | undefined;
    raceDistanceUZ: string;
    raceDistanceEN: string;
    raceDistanceRU: string;
    spRaceDistanceId: number;
    spEventCategoryId?: number | undefined;
    uzsPrice: number;
    uzsPriceOne: number;
    uzsPriceDateOne?: string | undefined;
    uzsPriceTwo: number;
    uzsPriceDateTwo?: string | undefined;
    platinumNumberPrice?: number | undefined;
    goldenNumberPrice?: number | undefined;
    silverNumberPrice?: number | undefined;
    usdPrice?: number | undefined;
    uzsPriceCalculated?: number | undefined;
    status: EventStatus;
    isPrice: boolean;
    isResult: boolean;
    isPublishFilterFormula: boolean;
    ageFrom?: number | undefined;
    toAgeYears?: number | undefined;
    bibFrom: number;
    bibUntil: number;
    participants?: number | undefined;
    smenaParticipants?: number | undefined;
    eventBoxId: number;
    eventBibs: EventBibDTO[];
    smenas: SmenaDTO[];
    packets: EventPacketDTO[];
    eventCategories: number[];
    eventGenderAgeCategories?: EventGenderAgeCategoryDTO[] | undefined;
}

export class EventBibDTO implements IEventBibDTO {
    id?: number | undefined;
    eventId?: number | undefined;
    bibCode!: number;
    status!: BibStatus;
    bibType!: BibType;

    constructor(data?: IEventBibDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventId = _data["eventId"];
            this.bibCode = _data["bibCode"];
            this.status = _data["status"];
            this.bibType = _data["bibType"];
        }
    }

    static fromJS(data: any): EventBibDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventBibDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventId"] = this.eventId;
        data["bibCode"] = this.bibCode;
        data["status"] = this.status;
        data["bibType"] = this.bibType;
        return data;
    }
}

export interface IEventBibDTO {
    id?: number | undefined;
    eventId?: number | undefined;
    bibCode: number;
    status: BibStatus;
    bibType: BibType;
}

export enum BibStatus {
    Active = 0,
    Selected = 1,
    Accepted = 2,
    Invalid = 3,
    Vip = 4,
}

export enum BibType {
    NormalNumber = 1,
    SilverNumber = 2,
    GoldenNumber = 3,
    PlatinumNumber = 4,
    VipNumber = 5,
}

export class SmenaDTO implements ISmenaDTO {
    id?: number | undefined;
    eventId?: number | undefined;
    name!: string;

    constructor(data?: ISmenaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventId = _data["eventId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SmenaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SmenaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventId"] = this.eventId;
        data["name"] = this.name;
        return data;
    }
}

export interface ISmenaDTO {
    id?: number | undefined;
    eventId?: number | undefined;
    name: string;
}

export class EventPacketDTO implements IEventPacketDTO {
    id!: number;
    packetNameUZ!: string;
    packetNameEN?: string | undefined;
    packetNameRU?: string | undefined;
    packetAmount!: number;
    bibFrom!: number;
    bibUntil!: number;

    constructor(data?: IEventPacketDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.packetNameUZ = _data["packetNameUZ"];
            this.packetNameEN = _data["packetNameEN"];
            this.packetNameRU = _data["packetNameRU"];
            this.packetAmount = _data["packetAmount"];
            this.bibFrom = _data["bibFrom"];
            this.bibUntil = _data["bibUntil"];
        }
    }

    static fromJS(data: any): EventPacketDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventPacketDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["packetNameUZ"] = this.packetNameUZ;
        data["packetNameEN"] = this.packetNameEN;
        data["packetNameRU"] = this.packetNameRU;
        data["packetAmount"] = this.packetAmount;
        data["bibFrom"] = this.bibFrom;
        data["bibUntil"] = this.bibUntil;
        return data;
    }
}

export interface IEventPacketDTO {
    id: number;
    packetNameUZ: string;
    packetNameEN?: string | undefined;
    packetNameRU?: string | undefined;
    packetAmount: number;
    bibFrom: number;
    bibUntil: number;
}

export class EventGenderAgeCategoryDTO implements IEventGenderAgeCategoryDTO {
    id!: number;
    spGenderId!: number;
    fromAge!: number;
    endAge!: number;
    eventId!: number;

    constructor(data?: IEventGenderAgeCategoryDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.spGenderId = _data["spGenderId"];
            this.fromAge = _data["fromAge"];
            this.endAge = _data["endAge"];
            this.eventId = _data["eventId"];
        }
    }

    static fromJS(data: any): EventGenderAgeCategoryDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventGenderAgeCategoryDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["spGenderId"] = this.spGenderId;
        data["fromAge"] = this.fromAge;
        data["endAge"] = this.endAge;
        data["eventId"] = this.eventId;
        return data;
    }
}

export interface IEventGenderAgeCategoryDTO {
    id: number;
    spGenderId: number;
    fromAge: number;
    endAge: number;
    eventId: number;
}

export class ResponseModelOfEventBoxDTO implements IResponseModelOfEventBoxDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: EventBoxDTO;

    constructor(data?: IResponseModelOfEventBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new EventBoxDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? EventBoxDTO.fromJS(_data["result"]) : new EventBoxDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfEventBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfEventBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfEventBoxDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: EventBoxDTO;
}

export class ResponseModelOfQueryResultOfEventBoxDTO implements IResponseModelOfQueryResultOfEventBoxDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfEventBoxDTO;

    constructor(data?: IResponseModelOfQueryResultOfEventBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfEventBoxDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfEventBoxDTO.fromJS(_data["result"]) : new QueryResultOfEventBoxDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfEventBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfEventBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfEventBoxDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfEventBoxDTO;
}

export class QueryResultOfEventBoxDTO implements IQueryResultOfEventBoxDTO {
    items!: EventBoxDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfEventBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EventBoxDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfEventBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfEventBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfEventBoxDTO {
    items: EventBoxDTO[];
    totalItems: number;
}

export class ResponseModelOfListOfEventBoxMiniDTO implements IResponseModelOfListOfEventBoxMiniDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: EventBoxMiniDTO[];

    constructor(data?: IResponseModelOfListOfEventBoxMiniDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EventBoxMiniDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfEventBoxMiniDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfEventBoxMiniDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfEventBoxMiniDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: EventBoxMiniDTO[];
}

export class EventBoxMiniDTO implements IEventBoxMiniDTO {
    id!: number;
    nameUZ!: string;
    nameRU?: string | undefined;
    nameEN?: string | undefined;

    constructor(data?: IEventBoxMiniDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameUZ = _data["nameUZ"];
            this.nameRU = _data["nameRU"];
            this.nameEN = _data["nameEN"];
        }
    }

    static fromJS(data: any): EventBoxMiniDTO {
        data = typeof data === 'object' ? data : {};
        let result = new EventBoxMiniDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameUZ"] = this.nameUZ;
        data["nameRU"] = this.nameRU;
        data["nameEN"] = this.nameEN;
        return data;
    }
}

export interface IEventBoxMiniDTO {
    id: number;
    nameUZ: string;
    nameRU?: string | undefined;
    nameEN?: string | undefined;
}

export class SelectEventBoxDTO implements ISelectEventBoxDTO {
    eventBoxId!: number;
    eventBoxName!: string;
    address!: string;
    participants!: number;
    distance!: string;
    eventAmount!: number;
    eventDate!: Date;
    fileName?: string | undefined;

    constructor(data?: ISelectEventBoxDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventBoxId = _data["eventBoxId"];
            this.eventBoxName = _data["eventBoxName"];
            this.address = _data["address"];
            this.participants = _data["participants"];
            this.distance = _data["distance"];
            this.eventAmount = _data["eventAmount"];
            this.eventDate = _data["eventDate"] ? new Date(_data["eventDate"].toString()) : <any>undefined;
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): SelectEventBoxDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SelectEventBoxDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventBoxId"] = this.eventBoxId;
        data["eventBoxName"] = this.eventBoxName;
        data["address"] = this.address;
        data["participants"] = this.participants;
        data["distance"] = this.distance;
        data["eventAmount"] = this.eventAmount;
        data["eventDate"] = this.eventDate ? this.eventDate.toISOString() : <any>undefined;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface ISelectEventBoxDTO {
    eventBoxId: number;
    eventBoxName: string;
    address: string;
    participants: number;
    distance: string;
    eventAmount: number;
    eventDate: Date;
    fileName?: string | undefined;
}

export class ResponseModelOfQueryResultOfSelectEvent implements IResponseModelOfQueryResultOfSelectEvent {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfSelectEvent;

    constructor(data?: IResponseModelOfQueryResultOfSelectEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfSelectEvent();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfSelectEvent.fromJS(_data["result"]) : new QueryResultOfSelectEvent();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfSelectEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfSelectEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfSelectEvent {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfSelectEvent;
}

export class QueryResultOfSelectEvent implements IQueryResultOfSelectEvent {
    items!: SelectEvent[];
    totalItems!: number;

    constructor(data?: IQueryResultOfSelectEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SelectEvent.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfSelectEvent {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfSelectEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfSelectEvent {
    items: SelectEvent[];
    totalItems: number;
}

export class SelectEvent implements ISelectEvent {
    eventId!: number;
    eventBoxNameUZ!: string;
    eventBoxNameRU!: string;
    eventBoxNameEN!: string;
    titleUZ!: string;
    titleRU!: string;
    titleEN!: string;
    raceDistanceUZ!: string;
    raceDistanceEN!: string;
    raceDistanceRU!: string;
    spRaceDistanceId!: number;
    participants?: number | undefined;
    eventAmount!: number;
    eventDate!: string;

    constructor(data?: ISelectEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.eventBoxNameUZ = _data["eventBoxNameUZ"];
            this.eventBoxNameRU = _data["eventBoxNameRU"];
            this.eventBoxNameEN = _data["eventBoxNameEN"];
            this.titleUZ = _data["titleUZ"];
            this.titleRU = _data["titleRU"];
            this.titleEN = _data["titleEN"];
            this.raceDistanceUZ = _data["raceDistanceUZ"];
            this.raceDistanceEN = _data["raceDistanceEN"];
            this.raceDistanceRU = _data["raceDistanceRU"];
            this.spRaceDistanceId = _data["spRaceDistanceId"];
            this.participants = _data["participants"];
            this.eventAmount = _data["eventAmount"];
            this.eventDate = _data["eventDate"];
        }
    }

    static fromJS(data: any): SelectEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SelectEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["eventBoxNameUZ"] = this.eventBoxNameUZ;
        data["eventBoxNameRU"] = this.eventBoxNameRU;
        data["eventBoxNameEN"] = this.eventBoxNameEN;
        data["titleUZ"] = this.titleUZ;
        data["titleRU"] = this.titleRU;
        data["titleEN"] = this.titleEN;
        data["raceDistanceUZ"] = this.raceDistanceUZ;
        data["raceDistanceEN"] = this.raceDistanceEN;
        data["raceDistanceRU"] = this.raceDistanceRU;
        data["spRaceDistanceId"] = this.spRaceDistanceId;
        data["participants"] = this.participants;
        data["eventAmount"] = this.eventAmount;
        data["eventDate"] = this.eventDate;
        return data;
    }
}

export interface ISelectEvent {
    eventId: number;
    eventBoxNameUZ: string;
    eventBoxNameRU: string;
    eventBoxNameEN: string;
    titleUZ: string;
    titleRU: string;
    titleEN: string;
    raceDistanceUZ: string;
    raceDistanceEN: string;
    raceDistanceRU: string;
    spRaceDistanceId: number;
    participants?: number | undefined;
    eventAmount: number;
    eventDate: string;
}

export class ResponseModelOfListOfString implements IResponseModelOfListOfString {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: string[];

    constructor(data?: IResponseModelOfListOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        return data;
    }
}

export interface IResponseModelOfListOfString {
    statusCode: HttpStatusCode;
    error: string;
    result: string[];
}

export class ResponseModelOfEventDTO implements IResponseModelOfEventDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: EventDTO;

    constructor(data?: IResponseModelOfEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new EventDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? EventDTO.fromJS(_data["result"]) : new EventDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfEventDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: EventDTO;
}

export class ResponseModelOfQueryResultOfEventDTO implements IResponseModelOfQueryResultOfEventDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfEventDTO;

    constructor(data?: IResponseModelOfQueryResultOfEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfEventDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfEventDTO.fromJS(_data["result"]) : new QueryResultOfEventDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfEventDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfEventDTO;
}

export class QueryResultOfEventDTO implements IQueryResultOfEventDTO {
    items!: EventDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EventDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfEventDTO {
    items: EventDTO[];
    totalItems: number;
}

export class ResponseModelOfAthletesInfoDTO implements IResponseModelOfAthletesInfoDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: AthletesInfoDTO;

    constructor(data?: IResponseModelOfAthletesInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new AthletesInfoDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? AthletesInfoDTO.fromJS(_data["result"]) : new AthletesInfoDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfAthletesInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfAthletesInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfAthletesInfoDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: AthletesInfoDTO;
}

export class AthletesInfoDTO implements IAthletesInfoDTO {
    imageFileGuid?: string | undefined;
    fullName!: string;
    personId!: number;

    constructor(data?: IAthletesInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageFileGuid = _data["imageFileGuid"];
            this.fullName = _data["fullName"];
            this.personId = _data["personId"];
        }
    }

    static fromJS(data: any): AthletesInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AthletesInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageFileGuid"] = this.imageFileGuid;
        data["fullName"] = this.fullName;
        data["personId"] = this.personId;
        return data;
    }
}

export interface IAthletesInfoDTO {
    imageFileGuid?: string | undefined;
    fullName: string;
    personId: number;
}

export class AthleteCameraPhoto implements IAthleteCameraPhoto {
    personId!: number;
    photoSrcBase64!: string;
    enterStatus!: EnterStatus;

    constructor(data?: IAthleteCameraPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            this.photoSrcBase64 = _data["photoSrcBase64"];
            this.enterStatus = _data["enterStatus"];
        }
    }

    static fromJS(data: any): AthleteCameraPhoto {
        data = typeof data === 'object' ? data : {};
        let result = new AthleteCameraPhoto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["photoSrcBase64"] = this.photoSrcBase64;
        data["enterStatus"] = this.enterStatus;
        return data;
    }
}

export interface IAthleteCameraPhoto {
    personId: number;
    photoSrcBase64: string;
    enterStatus: EnterStatus;
}

export enum EnterStatus {
    Start = 0,
    Finish = 1,
}

export class ExtraPhotoAndroidDTO implements IExtraPhotoAndroidDTO {
    personId!: string;
    photoSrcBase64!: string;
    enterStatus!: EnterStatus;

    constructor(data?: IExtraPhotoAndroidDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            this.photoSrcBase64 = _data["photoSrcBase64"];
            this.enterStatus = _data["enterStatus"];
        }
    }

    static fromJS(data: any): ExtraPhotoAndroidDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExtraPhotoAndroidDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["photoSrcBase64"] = this.photoSrcBase64;
        data["enterStatus"] = this.enterStatus;
        return data;
    }
}

export interface IExtraPhotoAndroidDTO {
    personId: string;
    photoSrcBase64: string;
    enterStatus: EnterStatus;
}

export class ResponseModelOfQueryResultOfFeedBackDTO implements IResponseModelOfQueryResultOfFeedBackDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfFeedBackDTO;

    constructor(data?: IResponseModelOfQueryResultOfFeedBackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfFeedBackDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfFeedBackDTO.fromJS(_data["result"]) : new QueryResultOfFeedBackDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfFeedBackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfFeedBackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfFeedBackDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfFeedBackDTO;
}

export class QueryResultOfFeedBackDTO implements IQueryResultOfFeedBackDTO {
    items!: FeedBackDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfFeedBackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FeedBackDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfFeedBackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfFeedBackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfFeedBackDTO {
    items: FeedBackDTO[];
    totalItems: number;
}

export class FeedBackDTO implements IFeedBackDTO {
    id!: number;
    createdDate?: Date | undefined;
    athletesId?: number | undefined;
    organizationName?: string | undefined;
    organizationEmail?: string | undefined;
    text!: string;
    answerText?: string | undefined;
    phoneNumber?: string | undefined;
    athletesFullName?: string | undefined;
    feedbackId?: number | undefined;
    type?: FeedType | undefined;
    deviceType?: DeviceType | undefined;
    answerUserId?: number | undefined;
    feedStatus?: FeedStatus | undefined;
    messageId?: number | undefined;
    fileId?: string | undefined;
    answerFileId?: string | undefined;

    constructor(data?: IFeedBackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.athletesId = _data["athletesId"];
            this.organizationName = _data["organizationName"];
            this.organizationEmail = _data["organizationEmail"];
            this.text = _data["text"];
            this.answerText = _data["answerText"];
            this.phoneNumber = _data["phoneNumber"];
            this.athletesFullName = _data["athletesFullName"];
            this.feedbackId = _data["feedbackId"];
            this.type = _data["type"];
            this.deviceType = _data["deviceType"];
            this.answerUserId = _data["answerUserId"];
            this.feedStatus = _data["feedStatus"];
            this.messageId = _data["messageId"];
            this.fileId = _data["fileId"];
            this.answerFileId = _data["answerFileId"];
        }
    }

    static fromJS(data: any): FeedBackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new FeedBackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["athletesId"] = this.athletesId;
        data["organizationName"] = this.organizationName;
        data["organizationEmail"] = this.organizationEmail;
        data["text"] = this.text;
        data["answerText"] = this.answerText;
        data["phoneNumber"] = this.phoneNumber;
        data["athletesFullName"] = this.athletesFullName;
        data["feedbackId"] = this.feedbackId;
        data["type"] = this.type;
        data["deviceType"] = this.deviceType;
        data["answerUserId"] = this.answerUserId;
        data["feedStatus"] = this.feedStatus;
        data["messageId"] = this.messageId;
        data["fileId"] = this.fileId;
        data["answerFileId"] = this.answerFileId;
        return data;
    }
}

export interface IFeedBackDTO {
    id: number;
    createdDate?: Date | undefined;
    athletesId?: number | undefined;
    organizationName?: string | undefined;
    organizationEmail?: string | undefined;
    text: string;
    answerText?: string | undefined;
    phoneNumber?: string | undefined;
    athletesFullName?: string | undefined;
    feedbackId?: number | undefined;
    type?: FeedType | undefined;
    deviceType?: DeviceType | undefined;
    answerUserId?: number | undefined;
    feedStatus?: FeedStatus | undefined;
    messageId?: number | undefined;
    fileId?: string | undefined;
    answerFileId?: string | undefined;
}

export enum FeedType {
    Suggestion = 0,
    Error = 1,
    Question = 2,
    Facility = 3,
}

export enum DeviceType {
    Web = 0,
    Mobile = 1,
    TelegramBot = 2,
}

export enum FeedStatus {
    New = 0,
    Finish = 10,
}

export class ResponseModelOfFeedBackDTO implements IResponseModelOfFeedBackDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: FeedBackDTO;

    constructor(data?: IResponseModelOfFeedBackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new FeedBackDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? FeedBackDTO.fromJS(_data["result"]) : new FeedBackDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfFeedBackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfFeedBackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfFeedBackDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: FeedBackDTO;
}

export class FileBase64 implements IFileBase64 {
    base64Image!: string;

    constructor(data?: IFileBase64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.base64Image = _data["base64Image"];
        }
    }

    static fromJS(data: any): FileBase64 {
        data = typeof data === 'object' ? data : {};
        let result = new FileBase64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["base64Image"] = this.base64Image;
        return data;
    }
}

export interface IFileBase64 {
    base64Image: string;
}

export class JoinEventBibDTO implements IJoinEventBibDTO {
    eventId!: number;
    bibCode!: number;
    smenaId!: number;
    selectBibType!: SelectBibType;

    constructor(data?: IJoinEventBibDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.bibCode = _data["bibCode"];
            this.smenaId = _data["smenaId"];
            this.selectBibType = _data["selectBibType"];
        }
    }

    static fromJS(data: any): JoinEventBibDTO {
        data = typeof data === 'object' ? data : {};
        let result = new JoinEventBibDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["bibCode"] = this.bibCode;
        data["smenaId"] = this.smenaId;
        data["selectBibType"] = this.selectBibType;
        return data;
    }
}

export interface IJoinEventBibDTO {
    eventId: number;
    bibCode: number;
    smenaId: number;
    selectBibType: SelectBibType;
}

export enum SelectBibType {
    SelectAutomaticOrder = 1,
    SelectNumber = 2,
}

export class ResponseModelOfQueryResultOfNewsDTO implements IResponseModelOfQueryResultOfNewsDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfNewsDTO;

    constructor(data?: IResponseModelOfQueryResultOfNewsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfNewsDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfNewsDTO.fromJS(_data["result"]) : new QueryResultOfNewsDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfNewsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfNewsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfNewsDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfNewsDTO;
}

export class QueryResultOfNewsDTO implements IQueryResultOfNewsDTO {
    items!: NewsDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfNewsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NewsDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfNewsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfNewsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfNewsDTO {
    items: NewsDTO[];
    totalItems: number;
}

export class NewsDTO implements INewsDTO {
    id!: number;
    titleUZ!: string;
    titleRU!: string;
    titleEN!: string;
    textUZ!: string;
    textRU!: string;
    textEN!: string;
    sendTime!: Date;
    newsStatus!: NewsStatus;

    constructor(data?: INewsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleUZ = _data["titleUZ"];
            this.titleRU = _data["titleRU"];
            this.titleEN = _data["titleEN"];
            this.textUZ = _data["textUZ"];
            this.textRU = _data["textRU"];
            this.textEN = _data["textEN"];
            this.sendTime = _data["sendTime"] ? new Date(_data["sendTime"].toString()) : <any>undefined;
            this.newsStatus = _data["newsStatus"];
        }
    }

    static fromJS(data: any): NewsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NewsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleUZ"] = this.titleUZ;
        data["titleRU"] = this.titleRU;
        data["titleEN"] = this.titleEN;
        data["textUZ"] = this.textUZ;
        data["textRU"] = this.textRU;
        data["textEN"] = this.textEN;
        data["sendTime"] = this.sendTime ? this.sendTime.toISOString() : <any>undefined;
        data["newsStatus"] = this.newsStatus;
        return data;
    }
}

export interface INewsDTO {
    id: number;
    titleUZ: string;
    titleRU: string;
    titleEN: string;
    textUZ: string;
    textRU: string;
    textEN: string;
    sendTime: Date;
    newsStatus: NewsStatus;
}

export enum NewsStatus {
    Active = 10,
    NotActive = 20,
}

export class ResponseModelOfNewsDTO implements IResponseModelOfNewsDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: NewsDTO;

    constructor(data?: IResponseModelOfNewsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new NewsDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? NewsDTO.fromJS(_data["result"]) : new NewsDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfNewsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfNewsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfNewsDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: NewsDTO;
}

export class NotificationDTO implements INotificationDTO {
    id!: number;
    titleUz!: string;
    titleRu!: string;
    titleEn!: string;
    text!: string;
    actionStatus!: ActionStatus;
    status!: NotificationStatus;
    notificationAthletesStatus!: NotificationAthletesStatus;
    athletesId?: number | undefined;
    authorName!: string;
    createdDate!: Date;

    constructor(data?: INotificationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.titleUz = _data["titleUz"];
            this.titleRu = _data["titleRu"];
            this.titleEn = _data["titleEn"];
            this.text = _data["text"];
            this.actionStatus = _data["actionStatus"];
            this.status = _data["status"];
            this.notificationAthletesStatus = _data["notificationAthletesStatus"];
            this.athletesId = _data["athletesId"];
            this.authorName = _data["authorName"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["titleUz"] = this.titleUz;
        data["titleRu"] = this.titleRu;
        data["titleEn"] = this.titleEn;
        data["text"] = this.text;
        data["actionStatus"] = this.actionStatus;
        data["status"] = this.status;
        data["notificationAthletesStatus"] = this.notificationAthletesStatus;
        data["athletesId"] = this.athletesId;
        data["authorName"] = this.authorName;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface INotificationDTO {
    id: number;
    titleUz: string;
    titleRu: string;
    titleEn: string;
    text: string;
    actionStatus: ActionStatus;
    status: NotificationStatus;
    notificationAthletesStatus: NotificationAthletesStatus;
    athletesId?: number | undefined;
    authorName: string;
    createdDate: Date;
}

export enum ActionStatus {
    EnterSystem = 0,
    EventJoin = 2,
    EventExit = 3,
    EventCreate = 4,
    EventPaid = 5,
    EventEdit = 6,
    UserCreate = 8,
    UserEdit = 10,
    MediaCreate = 12,
    MediaEdit = 14,
    ResultCreate = 16,
    ResultPublish = 17,
    FeedbackNew = 20,
    AskRefund = 24,
    DoneRefund = 25,
}

export enum NotificationStatus {
    All = 0,
    ForAthletes = 1,
    ForEvent = 2,
}

export enum NotificationAthletesStatus {
    New = 0,
    Seen = 1,
    Remove = 2,
}

export class ResponseModelOfQueryResultOfOrganizationDTO implements IResponseModelOfQueryResultOfOrganizationDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfOrganizationDTO;

    constructor(data?: IResponseModelOfQueryResultOfOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfOrganizationDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfOrganizationDTO.fromJS(_data["result"]) : new QueryResultOfOrganizationDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfOrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfOrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfOrganizationDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfOrganizationDTO;
}

export class QueryResultOfOrganizationDTO implements IQueryResultOfOrganizationDTO {
    items!: OrganizationDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfOrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfOrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfOrganizationDTO {
    items: OrganizationDTO[];
    totalItems: number;
}

export class ResponseModelOfOrganizationDTO implements IResponseModelOfOrganizationDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: OrganizationDTO;

    constructor(data?: IResponseModelOfOrganizationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new OrganizationDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? OrganizationDTO.fromJS(_data["result"]) : new OrganizationDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfOrganizationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfOrganizationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfOrganizationDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: OrganizationDTO;
}

export class OrganizationModelDTO implements IOrganizationModelDTO {
    spUserTypeId!: number;
    name?: string | undefined;
    spOrganizationTypeId?: number | undefined;

    constructor(data?: IOrganizationModelDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.spUserTypeId = _data["spUserTypeId"];
            this.name = _data["name"];
            this.spOrganizationTypeId = _data["spOrganizationTypeId"];
        }
    }

    static fromJS(data: any): OrganizationModelDTO {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationModelDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["spUserTypeId"] = this.spUserTypeId;
        data["name"] = this.name;
        data["spOrganizationTypeId"] = this.spOrganizationTypeId;
        return data;
    }
}

export interface IOrganizationModelDTO {
    spUserTypeId: number;
    name?: string | undefined;
    spOrganizationTypeId?: number | undefined;
}

export class PaymeResponse implements IPaymeResponse {
    id!: number;
    result!: any;
    error!: any;

    constructor(data?: IPaymeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.result = _data["result"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): PaymeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PaymeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["result"] = this.result;
        data["error"] = this.error;
        return data;
    }
}

export interface IPaymeResponse {
    id: number;
    result: any;
    error: any;
}

export class PaymeViewModel implements IPaymeViewModel {
    id!: number;
    jsonrpc?: string | undefined;
    method!: string;
    params!: Params;

    constructor(data?: IPaymeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.params = new Params();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.jsonrpc = _data["jsonrpc"];
            this.method = _data["method"];
            this.params = _data["params"] ? Params.fromJS(_data["params"]) : new Params();
        }
    }

    static fromJS(data: any): PaymeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["jsonrpc"] = this.jsonrpc;
        data["method"] = this.method;
        data["params"] = this.params ? this.params.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPaymeViewModel {
    id: number;
    jsonrpc?: string | undefined;
    method: string;
    params: Params;
}

export class Params implements IParams {
    id?: string | undefined;
    time!: number;
    from!: number;
    to!: number;
    reason!: number;
    amount!: number;
    account?: Account | undefined;

    constructor(data?: IParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.time = _data["time"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.reason = _data["reason"];
            this.amount = _data["amount"];
            this.account = _data["account"] ? Account.fromJS(_data["account"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Params {
        data = typeof data === 'object' ? data : {};
        let result = new Params();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["time"] = this.time;
        data["from"] = this.from;
        data["to"] = this.to;
        data["reason"] = this.reason;
        data["amount"] = this.amount;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data;
    }
}

export interface IParams {
    id?: string | undefined;
    time: number;
    from: number;
    to: number;
    reason: number;
    amount: number;
    account?: Account | undefined;
}

export class Account implements IAccount {
    order_id?: string | undefined;
    user_id?: string | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order_id = _data["order_id"];
            this.user_id = _data["user_id"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order_id"] = this.order_id;
        data["user_id"] = this.user_id;
        return data;
    }
}

export interface IAccount {
    order_id?: string | undefined;
    user_id?: string | undefined;
}

export class ClickResponse implements IClickResponse {
    click_trans_id!: number;
    merchant_trans_id!: string;
    merchant_prepare_id!: number;
    error!: number;
    error_note!: string;

    constructor(data?: IClickResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.click_trans_id = _data["click_trans_id"];
            this.merchant_trans_id = _data["merchant_trans_id"];
            this.merchant_prepare_id = _data["merchant_prepare_id"];
            this.error = _data["error"];
            this.error_note = _data["error_note"];
        }
    }

    static fromJS(data: any): ClickResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClickResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["click_trans_id"] = this.click_trans_id;
        data["merchant_trans_id"] = this.merchant_trans_id;
        data["merchant_prepare_id"] = this.merchant_prepare_id;
        data["error"] = this.error;
        data["error_note"] = this.error_note;
        return data;
    }
}

export interface IClickResponse {
    click_trans_id: number;
    merchant_trans_id: string;
    merchant_prepare_id: number;
    error: number;
    error_note: string;
}

export class ClickRequest implements IClickRequest {
    click_trans_id!: number;
    service_id!: number;
    click_paydoc_id!: number;
    merchant_prepare_id?: number | undefined;
    merchant_trans_id!: string;
    amount!: number;
    action!: number;
    error!: number;
    error_note!: string;
    sign_time!: string;
    sign_string!: string;

    constructor(data?: IClickRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.click_trans_id = _data["click_trans_id"];
            this.service_id = _data["service_id"];
            this.click_paydoc_id = _data["click_paydoc_id"];
            this.merchant_prepare_id = _data["merchant_prepare_id"];
            this.merchant_trans_id = _data["merchant_trans_id"];
            this.amount = _data["amount"];
            this.action = _data["action"];
            this.error = _data["error"];
            this.error_note = _data["error_note"];
            this.sign_time = _data["sign_time"];
            this.sign_string = _data["sign_string"];
        }
    }

    static fromJS(data: any): ClickRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ClickRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["click_trans_id"] = this.click_trans_id;
        data["service_id"] = this.service_id;
        data["click_paydoc_id"] = this.click_paydoc_id;
        data["merchant_prepare_id"] = this.merchant_prepare_id;
        data["merchant_trans_id"] = this.merchant_trans_id;
        data["amount"] = this.amount;
        data["action"] = this.action;
        data["error"] = this.error;
        data["error_note"] = this.error_note;
        data["sign_time"] = this.sign_time;
        data["sign_string"] = this.sign_string;
        return data;
    }
}

export interface IClickRequest {
    click_trans_id: number;
    service_id: number;
    click_paydoc_id: number;
    merchant_prepare_id?: number | undefined;
    merchant_trans_id: string;
    amount: number;
    action: number;
    error: number;
    error_note: string;
    sign_time: string;
    sign_string: string;
}

export class AthletesPaymentDTO implements IAthletesPaymentDTO {
    eventId?: number | undefined;
    eventName?: string | undefined;
    raceDistance?: string | undefined;
    athletesId!: number;
    bibCode!: number;
    fullAmount!: number;
    bibCodeAmount!: number;
    eventAmount!: number;
    paymentStatus!: PaymentStatus;
    payedDateTime!: string;

    constructor(data?: IAthletesPaymentDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.eventName = _data["eventName"];
            this.raceDistance = _data["raceDistance"];
            this.athletesId = _data["athletesId"];
            this.bibCode = _data["bibCode"];
            this.fullAmount = _data["fullAmount"];
            this.bibCodeAmount = _data["bibCodeAmount"];
            this.eventAmount = _data["eventAmount"];
            this.paymentStatus = _data["paymentStatus"];
            this.payedDateTime = _data["payedDateTime"];
        }
    }

    static fromJS(data: any): AthletesPaymentDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AthletesPaymentDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["eventName"] = this.eventName;
        data["raceDistance"] = this.raceDistance;
        data["athletesId"] = this.athletesId;
        data["bibCode"] = this.bibCode;
        data["fullAmount"] = this.fullAmount;
        data["bibCodeAmount"] = this.bibCodeAmount;
        data["eventAmount"] = this.eventAmount;
        data["paymentStatus"] = this.paymentStatus;
        data["payedDateTime"] = this.payedDateTime;
        return data;
    }
}

export interface IAthletesPaymentDTO {
    eventId?: number | undefined;
    eventName?: string | undefined;
    raceDistance?: string | undefined;
    athletesId: number;
    bibCode: number;
    fullAmount: number;
    bibCodeAmount: number;
    eventAmount: number;
    paymentStatus: PaymentStatus;
    payedDateTime: string;
}

export enum PaymentStatus {
    NotPay = 0,
    PayedFromPayme = 1,
    PayedFromClick = 2,
    Free = 3,
    PayedFromOfb = 4,
}

export class ResponseModelOfQueryResultOfPhotoVideoDTO implements IResponseModelOfQueryResultOfPhotoVideoDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfPhotoVideoDTO;

    constructor(data?: IResponseModelOfQueryResultOfPhotoVideoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfPhotoVideoDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfPhotoVideoDTO.fromJS(_data["result"]) : new QueryResultOfPhotoVideoDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfPhotoVideoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfPhotoVideoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfPhotoVideoDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfPhotoVideoDTO;
}

export class QueryResultOfPhotoVideoDTO implements IQueryResultOfPhotoVideoDTO {
    items!: PhotoVideoDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfPhotoVideoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PhotoVideoDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfPhotoVideoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfPhotoVideoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfPhotoVideoDTO {
    items: PhotoVideoDTO[];
    totalItems: number;
}

export class PhotoVideoDTO implements IPhotoVideoDTO {
    id!: number;
    fileId!: string;
    title?: string | undefined;
    description?: string | undefined;

    constructor(data?: IPhotoVideoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileId = _data["fileId"];
            this.title = _data["title"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PhotoVideoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PhotoVideoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileId"] = this.fileId;
        data["title"] = this.title;
        data["description"] = this.description;
        return data;
    }
}

export interface IPhotoVideoDTO {
    id: number;
    fileId: string;
    title?: string | undefined;
    description?: string | undefined;
}

export class PublishResultDTO implements IPublishResultDTO {
    id!: number;
    isRankOverall!: boolean;
    isBibCode!: boolean;
    isRaceDistance!: boolean;
    isName!: boolean;
    isSurname!: boolean;
    isPatronymic!: boolean;
    isSpSexId!: boolean;
    isBirthDate!: boolean;
    isAge!: boolean;
    isCategory!: boolean;
    isGroup!: boolean;
    isCountry!: boolean;
    isRegion!: boolean;
    isOrganizationName!: boolean;
    isOrganizationType!: boolean;
    isUniversityName!: boolean;
    isCourse!: boolean;
    isTeacherOTM!: boolean;
    isCheckPoint!: boolean;
    isGunTime!: boolean;
    isChipTime!: boolean;
    isStatus!: boolean;
    isComment!: boolean;
    eventId!: number;
    active!: boolean;

    constructor(data?: IPublishResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isRankOverall = _data["isRankOverall"];
            this.isBibCode = _data["isBibCode"];
            this.isRaceDistance = _data["isRaceDistance"];
            this.isName = _data["isName"];
            this.isSurname = _data["isSurname"];
            this.isPatronymic = _data["isPatronymic"];
            this.isSpSexId = _data["isSpSexId"];
            this.isBirthDate = _data["isBirthDate"];
            this.isAge = _data["isAge"];
            this.isCategory = _data["isCategory"];
            this.isGroup = _data["isGroup"];
            this.isCountry = _data["isCountry"];
            this.isRegion = _data["isRegion"];
            this.isOrganizationName = _data["isOrganizationName"];
            this.isOrganizationType = _data["isOrganizationType"];
            this.isUniversityName = _data["isUniversityName"];
            this.isCourse = _data["isCourse"];
            this.isTeacherOTM = _data["isTeacherOTM"];
            this.isCheckPoint = _data["isCheckPoint"];
            this.isGunTime = _data["isGunTime"];
            this.isChipTime = _data["isChipTime"];
            this.isStatus = _data["isStatus"];
            this.isComment = _data["isComment"];
            this.eventId = _data["eventId"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): PublishResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PublishResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isRankOverall"] = this.isRankOverall;
        data["isBibCode"] = this.isBibCode;
        data["isRaceDistance"] = this.isRaceDistance;
        data["isName"] = this.isName;
        data["isSurname"] = this.isSurname;
        data["isPatronymic"] = this.isPatronymic;
        data["isSpSexId"] = this.isSpSexId;
        data["isBirthDate"] = this.isBirthDate;
        data["isAge"] = this.isAge;
        data["isCategory"] = this.isCategory;
        data["isGroup"] = this.isGroup;
        data["isCountry"] = this.isCountry;
        data["isRegion"] = this.isRegion;
        data["isOrganizationName"] = this.isOrganizationName;
        data["isOrganizationType"] = this.isOrganizationType;
        data["isUniversityName"] = this.isUniversityName;
        data["isCourse"] = this.isCourse;
        data["isTeacherOTM"] = this.isTeacherOTM;
        data["isCheckPoint"] = this.isCheckPoint;
        data["isGunTime"] = this.isGunTime;
        data["isChipTime"] = this.isChipTime;
        data["isStatus"] = this.isStatus;
        data["isComment"] = this.isComment;
        data["eventId"] = this.eventId;
        data["active"] = this.active;
        return data;
    }
}

export interface IPublishResultDTO {
    id: number;
    isRankOverall: boolean;
    isBibCode: boolean;
    isRaceDistance: boolean;
    isName: boolean;
    isSurname: boolean;
    isPatronymic: boolean;
    isSpSexId: boolean;
    isBirthDate: boolean;
    isAge: boolean;
    isCategory: boolean;
    isGroup: boolean;
    isCountry: boolean;
    isRegion: boolean;
    isOrganizationName: boolean;
    isOrganizationType: boolean;
    isUniversityName: boolean;
    isCourse: boolean;
    isTeacherOTM: boolean;
    isCheckPoint: boolean;
    isGunTime: boolean;
    isChipTime: boolean;
    isStatus: boolean;
    isComment: boolean;
    eventId: number;
    active: boolean;
}

export class ResponseModelOfPublishResultDTO implements IResponseModelOfPublishResultDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: PublishResultDTO;

    constructor(data?: IResponseModelOfPublishResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new PublishResultDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? PublishResultDTO.fromJS(_data["result"]) : new PublishResultDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfPublishResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfPublishResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfPublishResultDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: PublishResultDTO;
}

export class ResponseModelOfQueryResultOfAllResultView implements IResponseModelOfQueryResultOfAllResultView {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfAllResultView;

    constructor(data?: IResponseModelOfQueryResultOfAllResultView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfAllResultView();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfAllResultView.fromJS(_data["result"]) : new QueryResultOfAllResultView();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfAllResultView {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfAllResultView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfAllResultView {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfAllResultView;
}

export class QueryResultOfAllResultView implements IQueryResultOfAllResultView {
    items!: AllResultView[];
    totalItems!: number;

    constructor(data?: IQueryResultOfAllResultView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AllResultView.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfAllResultView {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfAllResultView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfAllResultView {
    items: AllResultView[];
    totalItems: number;
}

export class AllResultView implements IAllResultView {
    athletesId?: number | undefined;
    rankOverall?: string | undefined;
    bibCode?: number | undefined;
    eventId?: number | undefined;
    eventName?: string | undefined;
    raceDistance?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    spSexId?: number | undefined;
    spSex?: string | undefined;
    birthDate?: Date | undefined;
    age?: number | undefined;
    category?: string | undefined;
    group?: string | undefined;
    spCountryId?: number | undefined;
    spCountry?: string | undefined;
    spRegionId?: number | undefined;
    spRegion?: string | undefined;
    universityName?: string | undefined;
    course?: string | undefined;
    teacherOTM?: string | undefined;
    organizationName?: string | undefined;
    spOrganizationType?: string | undefined;
    gunTime?: string | undefined;
    chipTime?: string | undefined;
    status?: string | undefined;
    comment?: string | undefined;
    checkPointDTOs?: CheckPointDTO[] | undefined;

    constructor(data?: IAllResultView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.athletesId = _data["athletesId"];
            this.rankOverall = _data["rankOverall"];
            this.bibCode = _data["bibCode"];
            this.eventId = _data["eventId"];
            this.eventName = _data["eventName"];
            this.raceDistance = _data["raceDistance"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.patronymic = _data["patronymic"];
            this.spSexId = _data["spSexId"];
            this.spSex = _data["spSex"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.age = _data["age"];
            this.category = _data["category"];
            this.group = _data["group"];
            this.spCountryId = _data["spCountryId"];
            this.spCountry = _data["spCountry"];
            this.spRegionId = _data["spRegionId"];
            this.spRegion = _data["spRegion"];
            this.universityName = _data["universityName"];
            this.course = _data["course"];
            this.teacherOTM = _data["teacherOTM"];
            this.organizationName = _data["organizationName"];
            this.spOrganizationType = _data["spOrganizationType"];
            this.gunTime = _data["gunTime"];
            this.chipTime = _data["chipTime"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["checkPointDTOs"])) {
                this.checkPointDTOs = [] as any;
                for (let item of _data["checkPointDTOs"])
                    this.checkPointDTOs!.push(CheckPointDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllResultView {
        data = typeof data === 'object' ? data : {};
        let result = new AllResultView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["athletesId"] = this.athletesId;
        data["rankOverall"] = this.rankOverall;
        data["bibCode"] = this.bibCode;
        data["eventId"] = this.eventId;
        data["eventName"] = this.eventName;
        data["raceDistance"] = this.raceDistance;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["patronymic"] = this.patronymic;
        data["spSexId"] = this.spSexId;
        data["spSex"] = this.spSex;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["age"] = this.age;
        data["category"] = this.category;
        data["group"] = this.group;
        data["spCountryId"] = this.spCountryId;
        data["spCountry"] = this.spCountry;
        data["spRegionId"] = this.spRegionId;
        data["spRegion"] = this.spRegion;
        data["universityName"] = this.universityName;
        data["course"] = this.course;
        data["teacherOTM"] = this.teacherOTM;
        data["organizationName"] = this.organizationName;
        data["spOrganizationType"] = this.spOrganizationType;
        data["gunTime"] = this.gunTime;
        data["chipTime"] = this.chipTime;
        data["status"] = this.status;
        data["comment"] = this.comment;
        if (Array.isArray(this.checkPointDTOs)) {
            data["checkPointDTOs"] = [];
            for (let item of this.checkPointDTOs)
                data["checkPointDTOs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllResultView {
    athletesId?: number | undefined;
    rankOverall?: string | undefined;
    bibCode?: number | undefined;
    eventId?: number | undefined;
    eventName?: string | undefined;
    raceDistance?: string | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    spSexId?: number | undefined;
    spSex?: string | undefined;
    birthDate?: Date | undefined;
    age?: number | undefined;
    category?: string | undefined;
    group?: string | undefined;
    spCountryId?: number | undefined;
    spCountry?: string | undefined;
    spRegionId?: number | undefined;
    spRegion?: string | undefined;
    universityName?: string | undefined;
    course?: string | undefined;
    teacherOTM?: string | undefined;
    organizationName?: string | undefined;
    spOrganizationType?: string | undefined;
    gunTime?: string | undefined;
    chipTime?: string | undefined;
    status?: string | undefined;
    comment?: string | undefined;
    checkPointDTOs?: CheckPointDTO[] | undefined;
}

export class CheckPointDTO implements ICheckPointDTO {
    id!: number;
    resultId!: number;
    checkPointTime!: string;
    checkPointStatus!: CheckPointStatus;

    constructor(data?: ICheckPointDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.resultId = _data["resultId"];
            this.checkPointTime = _data["checkPointTime"];
            this.checkPointStatus = _data["checkPointStatus"];
        }
    }

    static fromJS(data: any): CheckPointDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPointDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["resultId"] = this.resultId;
        data["checkPointTime"] = this.checkPointTime;
        data["checkPointStatus"] = this.checkPointStatus;
        return data;
    }
}

export interface ICheckPointDTO {
    id: number;
    resultId: number;
    checkPointTime: string;
    checkPointStatus: CheckPointStatus;
}

export enum CheckPointStatus {
    Start = 0,
    CheckPoint = 1,
    Finish = 2,
}

export class PublishFilterFormulaDTO implements IPublishFilterFormulaDTO {
    formulaId?: number | undefined;
    eventId!: number;
    nameUZ!: string;
    nameRU!: string;
    nameEN!: string;
    filterStatus!: FilterStatus;
    isGender!: boolean;
    isCategory!: boolean;
    isGroup!: boolean;
    isRegion!: boolean;
    isCountry!: boolean;
    isUniversityName!: boolean;
    isCourse!: boolean;
    isTeacherOTM!: boolean;
    isOrganizationName!: boolean;
    isOrganizationType!: boolean;

    constructor(data?: IPublishFilterFormulaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.formulaId = _data["formulaId"];
            this.eventId = _data["eventId"];
            this.nameUZ = _data["nameUZ"];
            this.nameRU = _data["nameRU"];
            this.nameEN = _data["nameEN"];
            this.filterStatus = _data["filterStatus"];
            this.isGender = _data["isGender"];
            this.isCategory = _data["isCategory"];
            this.isGroup = _data["isGroup"];
            this.isRegion = _data["isRegion"];
            this.isCountry = _data["isCountry"];
            this.isUniversityName = _data["isUniversityName"];
            this.isCourse = _data["isCourse"];
            this.isTeacherOTM = _data["isTeacherOTM"];
            this.isOrganizationName = _data["isOrganizationName"];
            this.isOrganizationType = _data["isOrganizationType"];
        }
    }

    static fromJS(data: any): PublishFilterFormulaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new PublishFilterFormulaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["formulaId"] = this.formulaId;
        data["eventId"] = this.eventId;
        data["nameUZ"] = this.nameUZ;
        data["nameRU"] = this.nameRU;
        data["nameEN"] = this.nameEN;
        data["filterStatus"] = this.filterStatus;
        data["isGender"] = this.isGender;
        data["isCategory"] = this.isCategory;
        data["isGroup"] = this.isGroup;
        data["isRegion"] = this.isRegion;
        data["isCountry"] = this.isCountry;
        data["isUniversityName"] = this.isUniversityName;
        data["isCourse"] = this.isCourse;
        data["isTeacherOTM"] = this.isTeacherOTM;
        data["isOrganizationName"] = this.isOrganizationName;
        data["isOrganizationType"] = this.isOrganizationType;
        return data;
    }
}

export interface IPublishFilterFormulaDTO {
    formulaId?: number | undefined;
    eventId: number;
    nameUZ: string;
    nameRU: string;
    nameEN: string;
    filterStatus: FilterStatus;
    isGender: boolean;
    isCategory: boolean;
    isGroup: boolean;
    isRegion: boolean;
    isCountry: boolean;
    isUniversityName: boolean;
    isCourse: boolean;
    isTeacherOTM: boolean;
    isOrganizationName: boolean;
    isOrganizationType: boolean;
}

export enum FilterStatus {
    MainWinner = 0,
    OtherWinner = 1,
}

export class ResponseModelOfPublishFilterFormulaDTO implements IResponseModelOfPublishFilterFormulaDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: PublishFilterFormulaDTO;

    constructor(data?: IResponseModelOfPublishFilterFormulaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new PublishFilterFormulaDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? PublishFilterFormulaDTO.fromJS(_data["result"]) : new PublishFilterFormulaDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfPublishFilterFormulaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfPublishFilterFormulaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfPublishFilterFormulaDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: PublishFilterFormulaDTO;
}

export class SelectPublishFilterFormula implements ISelectPublishFilterFormula {
    id!: number;
    nameUZ!: string;
    nameEN!: string;
    nameRU!: string;
    filterStatus!: FilterStatus;

    constructor(data?: ISelectPublishFilterFormula) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameUZ = _data["nameUZ"];
            this.nameEN = _data["nameEN"];
            this.nameRU = _data["nameRU"];
            this.filterStatus = _data["filterStatus"];
        }
    }

    static fromJS(data: any): SelectPublishFilterFormula {
        data = typeof data === 'object' ? data : {};
        let result = new SelectPublishFilterFormula();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameUZ"] = this.nameUZ;
        data["nameEN"] = this.nameEN;
        data["nameRU"] = this.nameRU;
        data["filterStatus"] = this.filterStatus;
        return data;
    }
}

export interface ISelectPublishFilterFormula {
    id: number;
    nameUZ: string;
    nameEN: string;
    nameRU: string;
    filterStatus: FilterStatus;
}

export class ResponseModelOfQueryResultOfPublishFilterFormulaDTO implements IResponseModelOfQueryResultOfPublishFilterFormulaDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfPublishFilterFormulaDTO;

    constructor(data?: IResponseModelOfQueryResultOfPublishFilterFormulaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfPublishFilterFormulaDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfPublishFilterFormulaDTO.fromJS(_data["result"]) : new QueryResultOfPublishFilterFormulaDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfPublishFilterFormulaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfPublishFilterFormulaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfPublishFilterFormulaDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfPublishFilterFormulaDTO;
}

export class QueryResultOfPublishFilterFormulaDTO implements IQueryResultOfPublishFilterFormulaDTO {
    items!: PublishFilterFormulaDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfPublishFilterFormulaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PublishFilterFormulaDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfPublishFilterFormulaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfPublishFilterFormulaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfPublishFilterFormulaDTO {
    items: PublishFilterFormulaDTO[];
    totalItems: number;
}

export class ResponseModelOfListOfUniversityDTO implements IResponseModelOfListOfUniversityDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: UniversityDTO[];

    constructor(data?: IResponseModelOfListOfUniversityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(UniversityDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfUniversityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfUniversityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfUniversityDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: UniversityDTO[];
}

export class UniversityDTO implements IUniversityDTO {
    universityCode!: string;
    universityName!: string;

    constructor(data?: IUniversityDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.universityCode = _data["universityCode"];
            this.universityName = _data["universityName"];
        }
    }

    static fromJS(data: any): UniversityDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["universityCode"] = this.universityCode;
        data["universityName"] = this.universityName;
        return data;
    }
}

export interface IUniversityDTO {
    universityCode: string;
    universityName: string;
}

export class ResponseModelOfQueryResultOfRegistationEventDTO implements IResponseModelOfQueryResultOfRegistationEventDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfRegistationEventDTO;

    constructor(data?: IResponseModelOfQueryResultOfRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfRegistationEventDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfRegistationEventDTO.fromJS(_data["result"]) : new QueryResultOfRegistationEventDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfRegistationEventDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfRegistationEventDTO;
}

export class QueryResultOfRegistationEventDTO implements IQueryResultOfRegistationEventDTO {
    items!: RegistationEventDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RegistationEventDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfRegistationEventDTO {
    items: RegistationEventDTO[];
    totalItems: number;
}

export class RegistationEventDTO implements IRegistationEventDTO {
    id!: number;
    eventId!: number;
    athletesId!: number;
    athletes?: AthletesDTO | undefined;
    eventBibId!: number;
    eventBib?: EventBibDTO | undefined;
    comment?: string | undefined;
    event?: EventDTO | undefined;
    registrationDateTime?: Date | undefined;
    bibCodeAmount!: number;
    eventPacketAmount!: number;
    smenaName!: string;
    oldBibCode?: number | undefined;
    eventPacketName!: string;
    payedDateTime?: Date | undefined;
    isPrice!: boolean;
    isGivenNumber!: boolean;
    orderId?: number | undefined;
    status!: Status;

    constructor(data?: IRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.eventId = _data["eventId"];
            this.athletesId = _data["athletesId"];
            this.athletes = _data["athletes"] ? AthletesDTO.fromJS(_data["athletes"]) : <any>undefined;
            this.eventBibId = _data["eventBibId"];
            this.eventBib = _data["eventBib"] ? EventBibDTO.fromJS(_data["eventBib"]) : <any>undefined;
            this.comment = _data["comment"];
            this.event = _data["event"] ? EventDTO.fromJS(_data["event"]) : <any>undefined;
            this.registrationDateTime = _data["registrationDateTime"] ? new Date(_data["registrationDateTime"].toString()) : <any>undefined;
            this.bibCodeAmount = _data["bibCodeAmount"];
            this.eventPacketAmount = _data["eventPacketAmount"];
            this.smenaName = _data["smenaName"];
            this.oldBibCode = _data["oldBibCode"];
            this.eventPacketName = _data["eventPacketName"];
            this.payedDateTime = _data["payedDateTime"] ? new Date(_data["payedDateTime"].toString()) : <any>undefined;
            this.isPrice = _data["isPrice"];
            this.isGivenNumber = _data["isGivenNumber"];
            this.orderId = _data["orderId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["eventId"] = this.eventId;
        data["athletesId"] = this.athletesId;
        data["athletes"] = this.athletes ? this.athletes.toJSON() : <any>undefined;
        data["eventBibId"] = this.eventBibId;
        data["eventBib"] = this.eventBib ? this.eventBib.toJSON() : <any>undefined;
        data["comment"] = this.comment;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["registrationDateTime"] = this.registrationDateTime ? this.registrationDateTime.toISOString() : <any>undefined;
        data["bibCodeAmount"] = this.bibCodeAmount;
        data["eventPacketAmount"] = this.eventPacketAmount;
        data["smenaName"] = this.smenaName;
        data["oldBibCode"] = this.oldBibCode;
        data["eventPacketName"] = this.eventPacketName;
        data["payedDateTime"] = this.payedDateTime ? this.payedDateTime.toISOString() : <any>undefined;
        data["isPrice"] = this.isPrice;
        data["isGivenNumber"] = this.isGivenNumber;
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        return data;
    }
}

export interface IRegistationEventDTO {
    id: number;
    eventId: number;
    athletesId: number;
    athletes?: AthletesDTO | undefined;
    eventBibId: number;
    eventBib?: EventBibDTO | undefined;
    comment?: string | undefined;
    event?: EventDTO | undefined;
    registrationDateTime?: Date | undefined;
    bibCodeAmount: number;
    eventPacketAmount: number;
    smenaName: string;
    oldBibCode?: number | undefined;
    eventPacketName: string;
    payedDateTime?: Date | undefined;
    isPrice: boolean;
    isGivenNumber: boolean;
    orderId?: number | undefined;
    status: Status;
}

export class ResponseModelOfQueryCheckedResultOfRegistationEventDTO implements IResponseModelOfQueryCheckedResultOfRegistationEventDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryCheckedResultOfRegistationEventDTO;

    constructor(data?: IResponseModelOfQueryCheckedResultOfRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryCheckedResultOfRegistationEventDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryCheckedResultOfRegistationEventDTO.fromJS(_data["result"]) : new QueryCheckedResultOfRegistationEventDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryCheckedResultOfRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryCheckedResultOfRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryCheckedResultOfRegistationEventDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryCheckedResultOfRegistationEventDTO;
}

export class QueryCheckedResultOfRegistationEventDTO implements IQueryCheckedResultOfRegistationEventDTO {
    items!: RegistationEventDTO[];
    totalItems!: number;
    allCheckedVerified!: boolean;

    constructor(data?: IQueryCheckedResultOfRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RegistationEventDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
            this.allCheckedVerified = _data["allCheckedVerified"];
        }
    }

    static fromJS(data: any): QueryCheckedResultOfRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryCheckedResultOfRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        data["allCheckedVerified"] = this.allCheckedVerified;
        return data;
    }
}

export interface IQueryCheckedResultOfRegistationEventDTO {
    items: RegistationEventDTO[];
    totalItems: number;
    allCheckedVerified: boolean;
}

export class JoinRegistationEventDTO implements IJoinRegistationEventDTO {
    eventId!: number;
    smenaId!: number;
    eventPacketId!: number;
    bibCode?: number | undefined;
    athletesId?: number | undefined;
    comment?: string | undefined;
    isERPSport!: boolean;
    isVipNumber!: boolean;
    selectBibType!: SelectBibType;

    constructor(data?: IJoinRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.smenaId = _data["smenaId"];
            this.eventPacketId = _data["eventPacketId"];
            this.bibCode = _data["bibCode"];
            this.athletesId = _data["athletesId"];
            this.comment = _data["comment"];
            this.isERPSport = _data["isERPSport"];
            this.isVipNumber = _data["isVipNumber"];
            this.selectBibType = _data["selectBibType"];
        }
    }

    static fromJS(data: any): JoinRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new JoinRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["smenaId"] = this.smenaId;
        data["eventPacketId"] = this.eventPacketId;
        data["bibCode"] = this.bibCode;
        data["athletesId"] = this.athletesId;
        data["comment"] = this.comment;
        data["isERPSport"] = this.isERPSport;
        data["isVipNumber"] = this.isVipNumber;
        data["selectBibType"] = this.selectBibType;
        return data;
    }
}

export interface IJoinRegistationEventDTO {
    eventId: number;
    smenaId: number;
    eventPacketId: number;
    bibCode?: number | undefined;
    athletesId?: number | undefined;
    comment?: string | undefined;
    isERPSport: boolean;
    isVipNumber: boolean;
    selectBibType: SelectBibType;
}

export class SelectRegistationEventDTO implements ISelectRegistationEventDTO {
    eventId!: number;
    athletesId!: number;
    fullName?: string | undefined;
    bibCode?: number | undefined;

    constructor(data?: ISelectRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.athletesId = _data["athletesId"];
            this.fullName = _data["fullName"];
            this.bibCode = _data["bibCode"];
        }
    }

    static fromJS(data: any): SelectRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SelectRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["athletesId"] = this.athletesId;
        data["fullName"] = this.fullName;
        data["bibCode"] = this.bibCode;
        return data;
    }
}

export interface ISelectRegistationEventDTO {
    eventId: number;
    athletesId: number;
    fullName?: string | undefined;
    bibCode?: number | undefined;
}

export class ResponseModelOfQueryResultOfCartInformationDTO implements IResponseModelOfQueryResultOfCartInformationDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfCartInformationDTO;

    constructor(data?: IResponseModelOfQueryResultOfCartInformationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfCartInformationDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfCartInformationDTO.fromJS(_data["result"]) : new QueryResultOfCartInformationDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfCartInformationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfCartInformationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfCartInformationDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfCartInformationDTO;
}

export class QueryResultOfCartInformationDTO implements IQueryResultOfCartInformationDTO {
    items!: CartInformationDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfCartInformationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CartInformationDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfCartInformationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfCartInformationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfCartInformationDTO {
    items: CartInformationDTO[];
    totalItems: number;
}

export class CartInformationDTO implements ICartInformationDTO {
    orderId!: number;
    eventBoxId!: number;
    evenBoxName!: string;
    eventId!: number;
    eventName?: string | undefined;
    raceDistance?: string | undefined;
    eventCost!: number;
    bibCode!: number;
    eventBibId!: number;
    bibCodeCost!: number;
    athletesId!: number;
    athletesFullName?: string | undefined;

    constructor(data?: ICartInformationDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.eventBoxId = _data["eventBoxId"];
            this.evenBoxName = _data["evenBoxName"];
            this.eventId = _data["eventId"];
            this.eventName = _data["eventName"];
            this.raceDistance = _data["raceDistance"];
            this.eventCost = _data["eventCost"];
            this.bibCode = _data["bibCode"];
            this.eventBibId = _data["eventBibId"];
            this.bibCodeCost = _data["bibCodeCost"];
            this.athletesId = _data["athletesId"];
            this.athletesFullName = _data["athletesFullName"];
        }
    }

    static fromJS(data: any): CartInformationDTO {
        data = typeof data === 'object' ? data : {};
        let result = new CartInformationDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["eventBoxId"] = this.eventBoxId;
        data["evenBoxName"] = this.evenBoxName;
        data["eventId"] = this.eventId;
        data["eventName"] = this.eventName;
        data["raceDistance"] = this.raceDistance;
        data["eventCost"] = this.eventCost;
        data["bibCode"] = this.bibCode;
        data["eventBibId"] = this.eventBibId;
        data["bibCodeCost"] = this.bibCodeCost;
        data["athletesId"] = this.athletesId;
        data["athletesFullName"] = this.athletesFullName;
        return data;
    }
}

export interface ICartInformationDTO {
    orderId: number;
    eventBoxId: number;
    evenBoxName: string;
    eventId: number;
    eventName?: string | undefined;
    raceDistance?: string | undefined;
    eventCost: number;
    bibCode: number;
    eventBibId: number;
    bibCodeCost: number;
    athletesId: number;
    athletesFullName?: string | undefined;
}

export class ResponseModelOfBibCodeInfoModel implements IResponseModelOfBibCodeInfoModel {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: BibCodeInfoModel;

    constructor(data?: IResponseModelOfBibCodeInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new BibCodeInfoModel();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? BibCodeInfoModel.fromJS(_data["result"]) : new BibCodeInfoModel();
        }
    }

    static fromJS(data: any): ResponseModelOfBibCodeInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfBibCodeInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfBibCodeInfoModel {
    statusCode: HttpStatusCode;
    error: string;
    result: BibCodeInfoModel;
}

export class BibCodeInfoModel implements IBibCodeInfoModel {
    activeBibCodes!: number[];
    bibCode!: number;
    status!: BibStatus;
    bibType!: BibType;
    isPrice!: boolean;
    eventPrice?: number | undefined;
    platinumNumberPrice?: number | undefined;
    goldenNumberPrice?: number | undefined;
    silverNumberPrice?: number | undefined;
    orderId?: number | undefined;

    constructor(data?: IBibCodeInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activeBibCodes = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["activeBibCodes"])) {
                this.activeBibCodes = [] as any;
                for (let item of _data["activeBibCodes"])
                    this.activeBibCodes!.push(item);
            }
            this.bibCode = _data["bibCode"];
            this.status = _data["status"];
            this.bibType = _data["bibType"];
            this.isPrice = _data["isPrice"];
            this.eventPrice = _data["eventPrice"];
            this.platinumNumberPrice = _data["platinumNumberPrice"];
            this.goldenNumberPrice = _data["goldenNumberPrice"];
            this.silverNumberPrice = _data["silverNumberPrice"];
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): BibCodeInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new BibCodeInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.activeBibCodes)) {
            data["activeBibCodes"] = [];
            for (let item of this.activeBibCodes)
                data["activeBibCodes"].push(item);
        }
        data["bibCode"] = this.bibCode;
        data["status"] = this.status;
        data["bibType"] = this.bibType;
        data["isPrice"] = this.isPrice;
        data["eventPrice"] = this.eventPrice;
        data["platinumNumberPrice"] = this.platinumNumberPrice;
        data["goldenNumberPrice"] = this.goldenNumberPrice;
        data["silverNumberPrice"] = this.silverNumberPrice;
        data["orderId"] = this.orderId;
        return data;
    }
}

export interface IBibCodeInfoModel {
    activeBibCodes: number[];
    bibCode: number;
    status: BibStatus;
    bibType: BibType;
    isPrice: boolean;
    eventPrice?: number | undefined;
    platinumNumberPrice?: number | undefined;
    goldenNumberPrice?: number | undefined;
    silverNumberPrice?: number | undefined;
    orderId?: number | undefined;
}

export class AthleteEventDto implements IAthleteEventDto {
    eventId!: number;
    athleteId?: number | undefined;

    constructor(data?: IAthleteEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.athleteId = _data["athleteId"];
        }
    }

    static fromJS(data: any): AthleteEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new AthleteEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["athleteId"] = this.athleteId;
        return data;
    }
}

export interface IAthleteEventDto {
    eventId: number;
    athleteId?: number | undefined;
}

export class ResponseModelOfRegistationEventDTO implements IResponseModelOfRegistationEventDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: RegistationEventDTO;

    constructor(data?: IResponseModelOfRegistationEventDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new RegistationEventDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? RegistationEventDTO.fromJS(_data["result"]) : new RegistationEventDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfRegistationEventDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfRegistationEventDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfRegistationEventDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: RegistationEventDTO;
}

export class ResponseModelOfQueryResultOfSmenaDTO implements IResponseModelOfQueryResultOfSmenaDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfSmenaDTO;

    constructor(data?: IResponseModelOfQueryResultOfSmenaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfSmenaDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfSmenaDTO.fromJS(_data["result"]) : new QueryResultOfSmenaDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfSmenaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfSmenaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfSmenaDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfSmenaDTO;
}

export class QueryResultOfSmenaDTO implements IQueryResultOfSmenaDTO {
    items!: SmenaDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfSmenaDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SmenaDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfSmenaDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfSmenaDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfSmenaDTO {
    items: SmenaDTO[];
    totalItems: number;
}

export class ResponseModelOfListOfEventPacketDTO implements IResponseModelOfListOfEventPacketDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: EventPacketDTO[];

    constructor(data?: IResponseModelOfListOfEventPacketDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EventPacketDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfEventPacketDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfEventPacketDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfEventPacketDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: EventPacketDTO[];
}

export class ResponseModelOfAllResultViewDTO implements IResponseModelOfAllResultViewDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: AllResultViewDTO;

    constructor(data?: IResponseModelOfAllResultViewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new AllResultViewDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? AllResultViewDTO.fromJS(_data["result"]) : new AllResultViewDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfAllResultViewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfAllResultViewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfAllResultViewDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: AllResultViewDTO;
}

export class AllResultViewDTO implements IAllResultViewDTO {
    id!: number;
    athletesId?: number | undefined;
    rankOverall?: string | undefined;
    bibCode!: number;
    gunTime?: string | undefined;
    chipTime?: string | undefined;
    totalAthletesCount!: number;
    startAthletesCount?: number | undefined;
    finishAthletesCount?: number | undefined;
    myEventBox!: SelectEvent;
    checkPoints?: CheckPointDTO[] | undefined;
    athletesRankings?: AthletesRankingDTO[] | undefined;

    constructor(data?: IAllResultViewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.myEventBox = new SelectEvent();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.athletesId = _data["athletesId"];
            this.rankOverall = _data["rankOverall"];
            this.bibCode = _data["bibCode"];
            this.gunTime = _data["gunTime"];
            this.chipTime = _data["chipTime"];
            this.totalAthletesCount = _data["totalAthletesCount"];
            this.startAthletesCount = _data["startAthletesCount"];
            this.finishAthletesCount = _data["finishAthletesCount"];
            this.myEventBox = _data["myEventBox"] ? SelectEvent.fromJS(_data["myEventBox"]) : new SelectEvent();
            if (Array.isArray(_data["checkPoints"])) {
                this.checkPoints = [] as any;
                for (let item of _data["checkPoints"])
                    this.checkPoints!.push(CheckPointDTO.fromJS(item));
            }
            if (Array.isArray(_data["athletesRankings"])) {
                this.athletesRankings = [] as any;
                for (let item of _data["athletesRankings"])
                    this.athletesRankings!.push(AthletesRankingDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllResultViewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AllResultViewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["athletesId"] = this.athletesId;
        data["rankOverall"] = this.rankOverall;
        data["bibCode"] = this.bibCode;
        data["gunTime"] = this.gunTime;
        data["chipTime"] = this.chipTime;
        data["totalAthletesCount"] = this.totalAthletesCount;
        data["startAthletesCount"] = this.startAthletesCount;
        data["finishAthletesCount"] = this.finishAthletesCount;
        data["myEventBox"] = this.myEventBox ? this.myEventBox.toJSON() : <any>undefined;
        if (Array.isArray(this.checkPoints)) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        if (Array.isArray(this.athletesRankings)) {
            data["athletesRankings"] = [];
            for (let item of this.athletesRankings)
                data["athletesRankings"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllResultViewDTO {
    id: number;
    athletesId?: number | undefined;
    rankOverall?: string | undefined;
    bibCode: number;
    gunTime?: string | undefined;
    chipTime?: string | undefined;
    totalAthletesCount: number;
    startAthletesCount?: number | undefined;
    finishAthletesCount?: number | undefined;
    myEventBox: SelectEvent;
    checkPoints?: CheckPointDTO[] | undefined;
    athletesRankings?: AthletesRankingDTO[] | undefined;
}

export class AthletesRankingDTO implements IAthletesRankingDTO {
    allResultId!: number;
    formulaNameUZ!: string;
    formulaNameEN!: string;
    formulaNameRu!: string;
    ranking?: string | undefined;
    athletesCount!: number;
    malesCount!: number;
    femalesCount!: number;
    filterStatus!: FilterStatus;

    constructor(data?: IAthletesRankingDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allResultId = _data["allResultId"];
            this.formulaNameUZ = _data["formulaNameUZ"];
            this.formulaNameEN = _data["formulaNameEN"];
            this.formulaNameRu = _data["formulaNameRu"];
            this.ranking = _data["ranking"];
            this.athletesCount = _data["athletesCount"];
            this.malesCount = _data["malesCount"];
            this.femalesCount = _data["femalesCount"];
            this.filterStatus = _data["filterStatus"];
        }
    }

    static fromJS(data: any): AthletesRankingDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AthletesRankingDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allResultId"] = this.allResultId;
        data["formulaNameUZ"] = this.formulaNameUZ;
        data["formulaNameEN"] = this.formulaNameEN;
        data["formulaNameRu"] = this.formulaNameRu;
        data["ranking"] = this.ranking;
        data["athletesCount"] = this.athletesCount;
        data["malesCount"] = this.malesCount;
        data["femalesCount"] = this.femalesCount;
        data["filterStatus"] = this.filterStatus;
        return data;
    }
}

export interface IAthletesRankingDTO {
    allResultId: number;
    formulaNameUZ: string;
    formulaNameEN: string;
    formulaNameRu: string;
    ranking?: string | undefined;
    athletesCount: number;
    malesCount: number;
    femalesCount: number;
    filterStatus: FilterStatus;
}

export class ResponseModelOfQueryResultOfAllResultViewDTO implements IResponseModelOfQueryResultOfAllResultViewDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfAllResultViewDTO;

    constructor(data?: IResponseModelOfQueryResultOfAllResultViewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfAllResultViewDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfAllResultViewDTO.fromJS(_data["result"]) : new QueryResultOfAllResultViewDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfAllResultViewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfAllResultViewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfAllResultViewDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfAllResultViewDTO;
}

export class QueryResultOfAllResultViewDTO implements IQueryResultOfAllResultViewDTO {
    items!: AllResultViewDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfAllResultViewDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AllResultViewDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfAllResultViewDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfAllResultViewDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfAllResultViewDTO {
    items: AllResultViewDTO[];
    totalItems: number;
}

export class ResponseModelOfQueryResultOfAllResultDTO implements IResponseModelOfQueryResultOfAllResultDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfAllResultDTO;

    constructor(data?: IResponseModelOfQueryResultOfAllResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfAllResultDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfAllResultDTO.fromJS(_data["result"]) : new QueryResultOfAllResultDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfAllResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfAllResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfAllResultDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfAllResultDTO;
}

export class QueryResultOfAllResultDTO implements IQueryResultOfAllResultDTO {
    items!: AllResultDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfAllResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AllResultDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfAllResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfAllResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfAllResultDTO {
    items: AllResultDTO[];
    totalItems: number;
}

export class AllResultDTO implements IAllResultDTO {
    id!: number;
    athletesId?: number | undefined;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    spSexId?: number | undefined;
    age?: number | undefined;
    universityName?: string | undefined;
    course?: string | undefined;
    isOrganizationName?: string | undefined;
    isOrganizationType?: number | undefined;
    rankOverall?: string | undefined;
    bibCode!: number;
    eventId!: number;
    gunTime?: string | undefined;
    chipTime?: string | undefined;
    active!: boolean;
    checkPoints!: CheckPointDTO[];

    constructor(data?: IAllResultDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.checkPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.athletesId = _data["athletesId"];
            this.surname = _data["surname"];
            this.name = _data["name"];
            this.patronymic = _data["patronymic"];
            this.spSexId = _data["spSexId"];
            this.age = _data["age"];
            this.universityName = _data["universityName"];
            this.course = _data["course"];
            this.isOrganizationName = _data["isOrganizationName"];
            this.isOrganizationType = _data["isOrganizationType"];
            this.rankOverall = _data["rankOverall"];
            this.bibCode = _data["bibCode"];
            this.eventId = _data["eventId"];
            this.gunTime = _data["gunTime"];
            this.chipTime = _data["chipTime"];
            this.active = _data["active"];
            if (Array.isArray(_data["checkPoints"])) {
                this.checkPoints = [] as any;
                for (let item of _data["checkPoints"])
                    this.checkPoints!.push(CheckPointDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllResultDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AllResultDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["athletesId"] = this.athletesId;
        data["surname"] = this.surname;
        data["name"] = this.name;
        data["patronymic"] = this.patronymic;
        data["spSexId"] = this.spSexId;
        data["age"] = this.age;
        data["universityName"] = this.universityName;
        data["course"] = this.course;
        data["isOrganizationName"] = this.isOrganizationName;
        data["isOrganizationType"] = this.isOrganizationType;
        data["rankOverall"] = this.rankOverall;
        data["bibCode"] = this.bibCode;
        data["eventId"] = this.eventId;
        data["gunTime"] = this.gunTime;
        data["chipTime"] = this.chipTime;
        data["active"] = this.active;
        if (Array.isArray(this.checkPoints)) {
            data["checkPoints"] = [];
            for (let item of this.checkPoints)
                data["checkPoints"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAllResultDTO {
    id: number;
    athletesId?: number | undefined;
    surname?: string | undefined;
    name?: string | undefined;
    patronymic?: string | undefined;
    spSexId?: number | undefined;
    age?: number | undefined;
    universityName?: string | undefined;
    course?: string | undefined;
    isOrganizationName?: string | undefined;
    isOrganizationType?: number | undefined;
    rankOverall?: string | undefined;
    bibCode: number;
    eventId: number;
    gunTime?: string | undefined;
    chipTime?: string | undefined;
    active: boolean;
    checkPoints: CheckPointDTO[];
}

export class ResponseModelOfStatisticsAll implements IResponseModelOfStatisticsAll {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: StatisticsAll;

    constructor(data?: IResponseModelOfStatisticsAll) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new StatisticsAll();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? StatisticsAll.fromJS(_data["result"]) : new StatisticsAll();
        }
    }

    static fromJS(data: any): ResponseModelOfStatisticsAll {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfStatisticsAll();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfStatisticsAll {
    statusCode: HttpStatusCode;
    error: string;
    result: StatisticsAll;
}

export class StatisticsAll implements IStatisticsAll {
    usersCount!: number;
    eventCount!: number;
    participants!: number;
    organizationCount!: number;
    malesCount!: number;
    femalesCount!: number;
    statisticsByRegions!: StatisticsByAllRegions;

    constructor(data?: IStatisticsAll) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.statisticsByRegions = new StatisticsByAllRegions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usersCount = _data["usersCount"];
            this.eventCount = _data["eventCount"];
            this.participants = _data["participants"];
            this.organizationCount = _data["organizationCount"];
            this.malesCount = _data["malesCount"];
            this.femalesCount = _data["femalesCount"];
            this.statisticsByRegions = _data["statisticsByRegions"] ? StatisticsByAllRegions.fromJS(_data["statisticsByRegions"]) : new StatisticsByAllRegions();
        }
    }

    static fromJS(data: any): StatisticsAll {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsAll();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usersCount"] = this.usersCount;
        data["eventCount"] = this.eventCount;
        data["participants"] = this.participants;
        data["organizationCount"] = this.organizationCount;
        data["malesCount"] = this.malesCount;
        data["femalesCount"] = this.femalesCount;
        data["statisticsByRegions"] = this.statisticsByRegions ? this.statisticsByRegions.toJSON() : <any>undefined;
        return data;
    }
}

export interface IStatisticsAll {
    usersCount: number;
    eventCount: number;
    participants: number;
    organizationCount: number;
    malesCount: number;
    femalesCount: number;
    statisticsByRegions: StatisticsByAllRegions;
}

export class StatisticsByAllRegions implements IStatisticsByAllRegions {
    menCountByRegions!: number[];
    womenCountByRegions!: number[];
    foreignWomenCount!: number;
    foreignMenCount!: number;

    constructor(data?: IStatisticsByAllRegions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.menCountByRegions = [];
            this.womenCountByRegions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["menCountByRegions"])) {
                this.menCountByRegions = [] as any;
                for (let item of _data["menCountByRegions"])
                    this.menCountByRegions!.push(item);
            }
            if (Array.isArray(_data["womenCountByRegions"])) {
                this.womenCountByRegions = [] as any;
                for (let item of _data["womenCountByRegions"])
                    this.womenCountByRegions!.push(item);
            }
            this.foreignWomenCount = _data["foreignWomenCount"];
            this.foreignMenCount = _data["foreignMenCount"];
        }
    }

    static fromJS(data: any): StatisticsByAllRegions {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticsByAllRegions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.menCountByRegions)) {
            data["menCountByRegions"] = [];
            for (let item of this.menCountByRegions)
                data["menCountByRegions"].push(item);
        }
        if (Array.isArray(this.womenCountByRegions)) {
            data["womenCountByRegions"] = [];
            for (let item of this.womenCountByRegions)
                data["womenCountByRegions"].push(item);
        }
        data["foreignWomenCount"] = this.foreignWomenCount;
        data["foreignMenCount"] = this.foreignMenCount;
        return data;
    }
}

export interface IStatisticsByAllRegions {
    menCountByRegions: number[];
    womenCountByRegions: number[];
    foreignWomenCount: number;
    foreignMenCount: number;
}

export class ResponseModelOfListOfActiveEventBoxStatistics implements IResponseModelOfListOfActiveEventBoxStatistics {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: ActiveEventBoxStatistics[];

    constructor(data?: IResponseModelOfListOfActiveEventBoxStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(ActiveEventBoxStatistics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfActiveEventBoxStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfActiveEventBoxStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfActiveEventBoxStatistics {
    statusCode: HttpStatusCode;
    error: string;
    result: ActiveEventBoxStatistics[];
}

export class ActiveEventBoxStatistics implements IActiveEventBoxStatistics {
    nameUZ!: string;
    nameRU!: string;
    nameEN!: string;
    totalCapacity!: number;
    registeredAthletesCount!: number;
    fullnessPercentage!: number;
    date!: Date;

    constructor(data?: IActiveEventBoxStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameUZ = _data["nameUZ"];
            this.nameRU = _data["nameRU"];
            this.nameEN = _data["nameEN"];
            this.totalCapacity = _data["totalCapacity"];
            this.registeredAthletesCount = _data["registeredAthletesCount"];
            this.fullnessPercentage = _data["fullnessPercentage"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ActiveEventBoxStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveEventBoxStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameUZ"] = this.nameUZ;
        data["nameRU"] = this.nameRU;
        data["nameEN"] = this.nameEN;
        data["totalCapacity"] = this.totalCapacity;
        data["registeredAthletesCount"] = this.registeredAthletesCount;
        data["fullnessPercentage"] = this.fullnessPercentage;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IActiveEventBoxStatistics {
    nameUZ: string;
    nameRU: string;
    nameEN: string;
    totalCapacity: number;
    registeredAthletesCount: number;
    fullnessPercentage: number;
    date: Date;
}

export class Filter implements IFilter {
    key!: string;
    value!: string;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IFilter {
    key: string;
    value: string;
}

export class QueryResultOfResultStatistics implements IQueryResultOfResultStatistics {
    items!: ResultStatistics[];
    totalItems!: number;

    constructor(data?: IQueryResultOfResultStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResultStatistics.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfResultStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfResultStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfResultStatistics {
    items: ResultStatistics[];
    totalItems: number;
}

export class ResultStatistics implements IResultStatistics {
    eventBoxId!: number;
    eventBoxName!: string;
    eventId!: number;
    eventDistance!: string;
    bibCode!: number;
    athletesId!: number;
    fullName!: string;

    constructor(data?: IResultStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventBoxId = _data["eventBoxId"];
            this.eventBoxName = _data["eventBoxName"];
            this.eventId = _data["eventId"];
            this.eventDistance = _data["eventDistance"];
            this.bibCode = _data["bibCode"];
            this.athletesId = _data["athletesId"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ResultStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResultStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventBoxId"] = this.eventBoxId;
        data["eventBoxName"] = this.eventBoxName;
        data["eventId"] = this.eventId;
        data["eventDistance"] = this.eventDistance;
        data["bibCode"] = this.bibCode;
        data["athletesId"] = this.athletesId;
        data["fullName"] = this.fullName;
        return data;
    }
}

export interface IResultStatistics {
    eventBoxId: number;
    eventBoxName: string;
    eventId: number;
    eventDistance: string;
    bibCode: number;
    athletesId: number;
    fullName: string;
}

export class ResponseModelOfRegionStatistics implements IResponseModelOfRegionStatistics {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: RegionStatistics;

    constructor(data?: IResponseModelOfRegionStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new RegionStatistics();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? RegionStatistics.fromJS(_data["result"]) : new RegionStatistics();
        }
    }

    static fromJS(data: any): ResponseModelOfRegionStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfRegionStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfRegionStatistics {
    statusCode: HttpStatusCode;
    error: string;
    result: RegionStatistics;
}

export class RegionStatistics implements IRegionStatistics {
    regionNameUZ!: string;
    regionNameRU!: string;
    regionNameEN!: string;
    totalAthletesCount!: number;
    maleAthletesCount!: number;
    femaleAthletesCount!: number;
    eventBoxesCount!: number;

    constructor(data?: IRegionStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionNameUZ = _data["regionNameUZ"];
            this.regionNameRU = _data["regionNameRU"];
            this.regionNameEN = _data["regionNameEN"];
            this.totalAthletesCount = _data["totalAthletesCount"];
            this.maleAthletesCount = _data["maleAthletesCount"];
            this.femaleAthletesCount = _data["femaleAthletesCount"];
            this.eventBoxesCount = _data["eventBoxesCount"];
        }
    }

    static fromJS(data: any): RegionStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new RegionStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionNameUZ"] = this.regionNameUZ;
        data["regionNameRU"] = this.regionNameRU;
        data["regionNameEN"] = this.regionNameEN;
        data["totalAthletesCount"] = this.totalAthletesCount;
        data["maleAthletesCount"] = this.maleAthletesCount;
        data["femaleAthletesCount"] = this.femaleAthletesCount;
        data["eventBoxesCount"] = this.eventBoxesCount;
        return data;
    }
}

export interface IRegionStatistics {
    regionNameUZ: string;
    regionNameRU: string;
    regionNameEN: string;
    totalAthletesCount: number;
    maleAthletesCount: number;
    femaleAthletesCount: number;
    eventBoxesCount: number;
}

export class ResponseModelOfInt32Of implements IResponseModelOfInt32Of {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: number[];

    constructor(data?: IResponseModelOfInt32Of) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(item);
            }
        }
    }

    static fromJS(data: any): ResponseModelOfInt32Of {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfInt32Of();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        return data;
    }
}

export interface IResponseModelOfInt32Of {
    statusCode: HttpStatusCode;
    error: string;
    result: number[];
}

export class ResponseModelOfEventBoxPaymentStatistics implements IResponseModelOfEventBoxPaymentStatistics {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: EventBoxPaymentStatistics;

    constructor(data?: IResponseModelOfEventBoxPaymentStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new EventBoxPaymentStatistics();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? EventBoxPaymentStatistics.fromJS(_data["result"]) : new EventBoxPaymentStatistics();
        }
    }

    static fromJS(data: any): ResponseModelOfEventBoxPaymentStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfEventBoxPaymentStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfEventBoxPaymentStatistics {
    statusCode: HttpStatusCode;
    error: string;
    result: EventBoxPaymentStatistics;
}

export class EventBoxPaymentStatistics implements IEventBoxPaymentStatistics {
    totalItems!: number;
    dailyPayments!: DailyPaymentStatistics[];
    totalPaidAmountByPayme!: number;
    totalPaidAmountByClick!: number;
    totalPaidAmountByOfb!: number;

    constructor(data?: IEventBoxPaymentStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dailyPayments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
            if (Array.isArray(_data["dailyPayments"])) {
                this.dailyPayments = [] as any;
                for (let item of _data["dailyPayments"])
                    this.dailyPayments!.push(DailyPaymentStatistics.fromJS(item));
            }
            this.totalPaidAmountByPayme = _data["totalPaidAmountByPayme"];
            this.totalPaidAmountByClick = _data["totalPaidAmountByClick"];
            this.totalPaidAmountByOfb = _data["totalPaidAmountByOfb"];
        }
    }

    static fromJS(data: any): EventBoxPaymentStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new EventBoxPaymentStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        if (Array.isArray(this.dailyPayments)) {
            data["dailyPayments"] = [];
            for (let item of this.dailyPayments)
                data["dailyPayments"].push(item.toJSON());
        }
        data["totalPaidAmountByPayme"] = this.totalPaidAmountByPayme;
        data["totalPaidAmountByClick"] = this.totalPaidAmountByClick;
        data["totalPaidAmountByOfb"] = this.totalPaidAmountByOfb;
        return data;
    }
}

export interface IEventBoxPaymentStatistics {
    totalItems: number;
    dailyPayments: DailyPaymentStatistics[];
    totalPaidAmountByPayme: number;
    totalPaidAmountByClick: number;
    totalPaidAmountByOfb: number;
}

export class DailyPaymentStatistics implements IDailyPaymentStatistics {
    date!: string;
    totalPaidAmountForBibNumber!: number;
    totalPaidAmountForEventPacket!: number;

    constructor(data?: IDailyPaymentStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.totalPaidAmountForBibNumber = _data["totalPaidAmountForBibNumber"];
            this.totalPaidAmountForEventPacket = _data["totalPaidAmountForEventPacket"];
        }
    }

    static fromJS(data: any): DailyPaymentStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new DailyPaymentStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["totalPaidAmountForBibNumber"] = this.totalPaidAmountForBibNumber;
        data["totalPaidAmountForEventPacket"] = this.totalPaidAmountForEventPacket;
        return data;
    }
}

export interface IDailyPaymentStatistics {
    date: string;
    totalPaidAmountForBibNumber: number;
    totalPaidAmountForEventPacket: number;
}

export class ResponseModelOfListOfAthleteStatistics implements IResponseModelOfListOfAthleteStatistics {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: AthleteStatistics[];

    constructor(data?: IResponseModelOfListOfAthleteStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AthleteStatistics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfAthleteStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfAthleteStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfAthleteStatistics {
    statusCode: HttpStatusCode;
    error: string;
    result: AthleteStatistics[];
}

export class AthleteStatistics implements IAthleteStatistics {
    name?: string | undefined;
    eventBoxNameUZ?: string | undefined;
    eventBoxNameRU?: string | undefined;
    eventBoxNameEN?: string | undefined;
    time?: string | undefined;
    participatedEventsCount?: number | undefined;

    constructor(data?: IAthleteStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.eventBoxNameUZ = _data["eventBoxNameUZ"];
            this.eventBoxNameRU = _data["eventBoxNameRU"];
            this.eventBoxNameEN = _data["eventBoxNameEN"];
            this.time = _data["time"];
            this.participatedEventsCount = _data["participatedEventsCount"];
        }
    }

    static fromJS(data: any): AthleteStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new AthleteStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["eventBoxNameUZ"] = this.eventBoxNameUZ;
        data["eventBoxNameRU"] = this.eventBoxNameRU;
        data["eventBoxNameEN"] = this.eventBoxNameEN;
        data["time"] = this.time;
        data["participatedEventsCount"] = this.participatedEventsCount;
        return data;
    }
}

export interface IAthleteStatistics {
    name?: string | undefined;
    eventBoxNameUZ?: string | undefined;
    eventBoxNameRU?: string | undefined;
    eventBoxNameEN?: string | undefined;
    time?: string | undefined;
    participatedEventsCount?: number | undefined;
}

export class ResponseModelOfStatisticsByAllRegions implements IResponseModelOfStatisticsByAllRegions {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: StatisticsByAllRegions;

    constructor(data?: IResponseModelOfStatisticsByAllRegions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new StatisticsByAllRegions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? StatisticsByAllRegions.fromJS(_data["result"]) : new StatisticsByAllRegions();
        }
    }

    static fromJS(data: any): ResponseModelOfStatisticsByAllRegions {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfStatisticsByAllRegions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfStatisticsByAllRegions {
    statusCode: HttpStatusCode;
    error: string;
    result: StatisticsByAllRegions;
}

export class ResponseModelOfQueryResultOfTopAthleteInfoDTO implements IResponseModelOfQueryResultOfTopAthleteInfoDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfTopAthleteInfoDTO;

    constructor(data?: IResponseModelOfQueryResultOfTopAthleteInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfTopAthleteInfoDTO();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfTopAthleteInfoDTO.fromJS(_data["result"]) : new QueryResultOfTopAthleteInfoDTO();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfTopAthleteInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfTopAthleteInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfTopAthleteInfoDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfTopAthleteInfoDTO;
}

export class QueryResultOfTopAthleteInfoDTO implements IQueryResultOfTopAthleteInfoDTO {
    items!: TopAthleteInfoDTO[];
    totalItems!: number;

    constructor(data?: IQueryResultOfTopAthleteInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TopAthleteInfoDTO.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfTopAthleteInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfTopAthleteInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfTopAthleteInfoDTO {
    items: TopAthleteInfoDTO[];
    totalItems: number;
}

export class TopAthleteInfoDTO implements ITopAthleteInfoDTO {
    athleteId?: number | undefined;
    name?: string | undefined;
    universityName?: string | undefined;
    course?: string | undefined;
    eventBoxNameUZ?: string | undefined;
    eventBoxNameRU?: string | undefined;
    eventBoxNameEN?: string | undefined;
    eventRaceDistance?: string | undefined;
    result?: string | undefined;
    date?: Date | undefined;
    sex?: number | undefined;

    constructor(data?: ITopAthleteInfoDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.athleteId = _data["athleteId"];
            this.name = _data["name"];
            this.universityName = _data["universityName"];
            this.course = _data["course"];
            this.eventBoxNameUZ = _data["eventBoxNameUZ"];
            this.eventBoxNameRU = _data["eventBoxNameRU"];
            this.eventBoxNameEN = _data["eventBoxNameEN"];
            this.eventRaceDistance = _data["eventRaceDistance"];
            this.result = _data["result"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.sex = _data["sex"];
        }
    }

    static fromJS(data: any): TopAthleteInfoDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TopAthleteInfoDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["athleteId"] = this.athleteId;
        data["name"] = this.name;
        data["universityName"] = this.universityName;
        data["course"] = this.course;
        data["eventBoxNameUZ"] = this.eventBoxNameUZ;
        data["eventBoxNameRU"] = this.eventBoxNameRU;
        data["eventBoxNameEN"] = this.eventBoxNameEN;
        data["eventRaceDistance"] = this.eventRaceDistance;
        data["result"] = this.result;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["sex"] = this.sex;
        return data;
    }
}

export interface ITopAthleteInfoDTO {
    athleteId?: number | undefined;
    name?: string | undefined;
    universityName?: string | undefined;
    course?: string | undefined;
    eventBoxNameUZ?: string | undefined;
    eventBoxNameRU?: string | undefined;
    eventBoxNameEN?: string | undefined;
    eventRaceDistance?: string | undefined;
    result?: string | undefined;
    date?: Date | undefined;
    sex?: number | undefined;
}

export class ResponseModelOfQueryResultOfUniversityStatistics implements IResponseModelOfQueryResultOfUniversityStatistics {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: QueryResultOfUniversityStatistics;

    constructor(data?: IResponseModelOfQueryResultOfUniversityStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new QueryResultOfUniversityStatistics();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? QueryResultOfUniversityStatistics.fromJS(_data["result"]) : new QueryResultOfUniversityStatistics();
        }
    }

    static fromJS(data: any): ResponseModelOfQueryResultOfUniversityStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfQueryResultOfUniversityStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfQueryResultOfUniversityStatistics {
    statusCode: HttpStatusCode;
    error: string;
    result: QueryResultOfUniversityStatistics;
}

export class QueryResultOfUniversityStatistics implements IQueryResultOfUniversityStatistics {
    items!: UniversityStatistics[];
    totalItems!: number;

    constructor(data?: IQueryResultOfUniversityStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UniversityStatistics.fromJS(item));
            }
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): QueryResultOfUniversityStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new QueryResultOfUniversityStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface IQueryResultOfUniversityStatistics {
    items: UniversityStatistics[];
    totalItems: number;
}

export class UniversityStatistics implements IUniversityStatistics {
    year!: number;
    universityName!: string;
    universityCode!: string;
    totalAthletesCount!: number;
    malesCount!: number;
    femalesCount!: number;
    totalAthletesCountByCourses!: CourseStatistics[];

    constructor(data?: IUniversityStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.totalAthletesCountByCourses = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.universityName = _data["universityName"];
            this.universityCode = _data["universityCode"];
            this.totalAthletesCount = _data["totalAthletesCount"];
            this.malesCount = _data["malesCount"];
            this.femalesCount = _data["femalesCount"];
            if (Array.isArray(_data["totalAthletesCountByCourses"])) {
                this.totalAthletesCountByCourses = [] as any;
                for (let item of _data["totalAthletesCountByCourses"])
                    this.totalAthletesCountByCourses!.push(CourseStatistics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UniversityStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new UniversityStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["universityName"] = this.universityName;
        data["universityCode"] = this.universityCode;
        data["totalAthletesCount"] = this.totalAthletesCount;
        data["malesCount"] = this.malesCount;
        data["femalesCount"] = this.femalesCount;
        if (Array.isArray(this.totalAthletesCountByCourses)) {
            data["totalAthletesCountByCourses"] = [];
            for (let item of this.totalAthletesCountByCourses)
                data["totalAthletesCountByCourses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUniversityStatistics {
    year: number;
    universityName: string;
    universityCode: string;
    totalAthletesCount: number;
    malesCount: number;
    femalesCount: number;
    totalAthletesCountByCourses: CourseStatistics[];
}

export class CourseStatistics implements ICourseStatistics {
    courseCode!: string;
    totalAthletesCount!: number;

    constructor(data?: ICourseStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseCode = _data["courseCode"];
            this.totalAthletesCount = _data["totalAthletesCount"];
        }
    }

    static fromJS(data: any): CourseStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new CourseStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseCode"] = this.courseCode;
        data["totalAthletesCount"] = this.totalAthletesCount;
        return data;
    }
}

export interface ICourseStatistics {
    courseCode: string;
    totalAthletesCount: number;
}

export class ResponseModelOfListOfFinishedEventBoxStatistics implements IResponseModelOfListOfFinishedEventBoxStatistics {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: FinishedEventBoxStatistics[];

    constructor(data?: IResponseModelOfListOfFinishedEventBoxStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(FinishedEventBoxStatistics.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfFinishedEventBoxStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfFinishedEventBoxStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfFinishedEventBoxStatistics {
    statusCode: HttpStatusCode;
    error: string;
    result: FinishedEventBoxStatistics[];
}

export class FinishedEventBoxStatistics implements IFinishedEventBoxStatistics {
    nameUZ!: string;
    nameRU!: string;
    nameEN!: string;
    totalAthletes!: number;
    athletesCountAtStart!: number;
    atletesCountAtFinish!: number;

    constructor(data?: IFinishedEventBoxStatistics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameUZ = _data["nameUZ"];
            this.nameRU = _data["nameRU"];
            this.nameEN = _data["nameEN"];
            this.totalAthletes = _data["totalAthletes"];
            this.athletesCountAtStart = _data["athletesCountAtStart"];
            this.atletesCountAtFinish = _data["atletesCountAtFinish"];
        }
    }

    static fromJS(data: any): FinishedEventBoxStatistics {
        data = typeof data === 'object' ? data : {};
        let result = new FinishedEventBoxStatistics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameUZ"] = this.nameUZ;
        data["nameRU"] = this.nameRU;
        data["nameEN"] = this.nameEN;
        data["totalAthletes"] = this.totalAthletes;
        data["athletesCountAtStart"] = this.athletesCountAtStart;
        data["atletesCountAtFinish"] = this.atletesCountAtFinish;
        return data;
    }
}

export interface IFinishedEventBoxStatistics {
    nameUZ: string;
    nameRU: string;
    nameEN: string;
    totalAthletes: number;
    athletesCountAtStart: number;
    atletesCountAtFinish: number;
}

export class SelectModel implements ISelectModel {
    eventId!: number;
    eventBibId!: number;
    bibCode!: number;
    athletesId?: number | undefined;

    constructor(data?: ISelectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.eventBibId = _data["eventBibId"];
            this.bibCode = _data["bibCode"];
            this.athletesId = _data["athletesId"];
        }
    }

    static fromJS(data: any): SelectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SelectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["eventBibId"] = this.eventBibId;
        data["bibCode"] = this.bibCode;
        data["athletesId"] = this.athletesId;
        return data;
    }
}

export interface ISelectModel {
    eventId: number;
    eventBibId: number;
    bibCode: number;
    athletesId?: number | undefined;
}

export class ResponseModelOfSelectRegistationEvent implements IResponseModelOfSelectRegistationEvent {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: SelectRegistationEvent;

    constructor(data?: IResponseModelOfSelectRegistationEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = new SelectRegistationEvent();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            this.result = _data["result"] ? SelectRegistationEvent.fromJS(_data["result"]) : new SelectRegistationEvent();
        }
    }

    static fromJS(data: any): ResponseModelOfSelectRegistationEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfSelectRegistationEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponseModelOfSelectRegistationEvent {
    statusCode: HttpStatusCode;
    error: string;
    result: SelectRegistationEvent;
}

export class SelectRegistationEvent implements ISelectRegistationEvent {
    eventId!: number;
    eventBibId!: number;
    bibCode!: number;
    bibStatus!: BibStatus;
    bibType!: BibType;
    athletesId?: number | undefined;
    fullName?: string | undefined;
    athleteStatus?: Status | undefined;

    constructor(data?: ISelectRegistationEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eventId = _data["eventId"];
            this.eventBibId = _data["eventBibId"];
            this.bibCode = _data["bibCode"];
            this.bibStatus = _data["bibStatus"];
            this.bibType = _data["bibType"];
            this.athletesId = _data["athletesId"];
            this.fullName = _data["fullName"];
            this.athleteStatus = _data["athleteStatus"];
        }
    }

    static fromJS(data: any): SelectRegistationEvent {
        data = typeof data === 'object' ? data : {};
        let result = new SelectRegistationEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eventId"] = this.eventId;
        data["eventBibId"] = this.eventBibId;
        data["bibCode"] = this.bibCode;
        data["bibStatus"] = this.bibStatus;
        data["bibType"] = this.bibType;
        data["athletesId"] = this.athletesId;
        data["fullName"] = this.fullName;
        data["athleteStatus"] = this.athleteStatus;
        return data;
    }
}

export interface ISelectRegistationEvent {
    eventId: number;
    eventBibId: number;
    bibCode: number;
    bibStatus: BibStatus;
    bibType: BibType;
    athletesId?: number | undefined;
    fullName?: string | undefined;
    athleteStatus?: Status | undefined;
}

export class ResponseModelOfListOfSelectRegistationEvent implements IResponseModelOfListOfSelectRegistationEvent {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: SelectRegistationEvent[];

    constructor(data?: IResponseModelOfListOfSelectRegistationEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(SelectRegistationEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfSelectRegistationEvent {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfSelectRegistationEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfSelectRegistationEvent {
    statusCode: HttpStatusCode;
    error: string;
    result: SelectRegistationEvent[];
}

export class ResponseModelOfListOfEventBibDTO implements IResponseModelOfListOfEventBibDTO {
    statusCode!: HttpStatusCode;
    error!: string;
    result!: EventBibDTO[];

    constructor(data?: IResponseModelOfListOfEventBibDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.result = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusCode = _data["statusCode"];
            this.error = _data["error"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(EventBibDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseModelOfListOfEventBibDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseModelOfListOfEventBibDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusCode"] = this.statusCode;
        data["error"] = this.error;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponseModelOfListOfEventBibDTO {
    statusCode: HttpStatusCode;
    error: string;
    result: EventBibDTO[];
}

export class SendEmail implements ISendEmail {
    emailTo?: string | undefined;
    subject!: string;
    message!: string;
    athletesIds?: number[] | undefined;

    constructor(data?: ISendEmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTo = _data["emailTo"];
            this.subject = _data["subject"];
            this.message = _data["message"];
            if (Array.isArray(_data["athletesIds"])) {
                this.athletesIds = [] as any;
                for (let item of _data["athletesIds"])
                    this.athletesIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmail {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTo"] = this.emailTo;
        data["subject"] = this.subject;
        data["message"] = this.message;
        if (Array.isArray(this.athletesIds)) {
            data["athletesIds"] = [];
            for (let item of this.athletesIds)
                data["athletesIds"].push(item);
        }
        return data;
    }
}

export interface ISendEmail {
    emailTo?: string | undefined;
    subject: string;
    message: string;
    athletesIds?: number[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}